<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pyfasst.SeparateLeadStereo.SeparateLeadStereoTF &mdash; pyFASST 0.1 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="pyFASST 0.1 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">pyFASST 0.1 documentation</a> &raquo;</li>
          <li><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for pyfasst.SeparateLeadStereo.SeparateLeadStereoTF</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;SeparateLeadStereo, with Time-Frequency choice</span>

<span class="sd">Provides a class (``SeparateLeadProcess``) within which several</span>
<span class="sd">processings can be run on an audio file, in order to extract the</span>
<span class="sd">lead instrument/main voice from a (stereophonic) audio mixture.</span>

<span class="sd">copyright (C) 2011 - 2013 Jean-Louis Durrieu</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c"># Importing necessary packages:</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">scipy.io.wavfile</span> <span class="kn">as</span> <span class="nn">wav</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">scipy</span>
    <span class="n">spver</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">__version__</span>
    <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s">&#39;Version of scipy is </span><span class="si">%s</span><span class="s">, &#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">spver</span><span class="p">)</span> <span class="o">+</span> \
                      <span class="s">&#39;to read WAV files, one needs &gt;= 0.7.0&#39;</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.SIMM</span> <span class="kn">import</span> <span class="n">SIMM</span> <span class="k">as</span> <span class="n">SIMM</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="c"># importing the cython version of tracking:</span>
<span class="c">#from tracking import viterbiTrackingArray</span>
<span class="kn">from</span> <span class="nn">.tracking._tracking</span> <span class="kn">import</span> <span class="n">viterbiTracking</span> <span class="k">as</span> <span class="n">viterbiTrackingArray</span>
<span class="c"># the following import gets useful functions for this class:</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">separateLeadFunctions</span> <span class="k">as</span> <span class="n">slf</span>
<span class="kn">import</span> <span class="nn">scipy.optimize</span>
<span class="kn">from</span> <span class="nn">..tftransforms</span> <span class="kn">import</span> <span class="n">tft</span> <span class="c"># time-freq transforms</span>

<span class="n">eps</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="o">-</span><span class="mi">9</span>

<span class="n">knownTransfos</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;stft&#39;</span><span class="p">,</span> <span class="s">&#39;hybridcqt&#39;</span><span class="p">,</span> <span class="s">&#39;minqt&#39;</span><span class="p">,</span>
                 <span class="s">&#39;cqt&#39;</span><span class="p">,</span> <span class="s">&#39;mqt&#39;</span><span class="p">]</span> <span class="c"># TODO: &#39;cqt&#39;, &#39;erb&#39;?</span>

<div class="viewcode-block" id="SeparateLeadProcess"><a class="viewcode-back" href="../../../reference/separateleadstereo.html#pyfasst.SeparateLeadStereo.SeparateLeadStereoTF.SeparateLeadProcess">[docs]</a><span class="k">class</span> <span class="nc">SeparateLeadProcess</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;SeparateLeadProcess</span>
<span class="sd">    </span>
<span class="sd">    class which implements the source separation algorithm, separating the</span>
<span class="sd">    &#39;lead&#39; voice from the &#39;accompaniment&#39;. It can deal automatically with the</span>
<span class="sd">    task (the &#39;lead&#39; voice becomes the most energetic one), or can be manually</span>
<span class="sd">    told what the &#39;lead&#39; is (through the melody line).</span>
<span class="sd">    </span>
<span class="sd">    **Attributes**</span>
<span class="sd">     dataType : dtype</span>
<span class="sd">        this is the input data type (usually the same as the audio encoding)</span>
<span class="sd">    </span>
<span class="sd">     displayEvolution : boolean</span>
<span class="sd">        display the evolution of the arrays (notably HF0)</span>
<span class="sd">    </span>
<span class="sd">     F, N : integer, integer</span>
<span class="sd">        F the number of frequency bins in the time-frequency representation</span>
<span class="sd">          (this is half the Fourier bins, + 1)</span>
<span class="sd">          </span>
<span class="sd">        N the number of analysis input frames</span>
<span class="sd">    </span>
<span class="sd">     files :</span>
<span class="sd">        dictionary containing the filenames of the output files for the</span>
<span class="sd">        separated signals, with the following keys (after initialization)</span>
<span class="sd">        </span>
<span class="sd">            &#39;inputAudioFilename&#39; : input filename</span>
<span class="sd">            </span>
<span class="sd">            &#39;mus_output_file&#39; : output filename for the estimated</span>
<span class="sd">            &#39;accompaniment&#39;, appending &#39;_acc.wav&#39; to the radical.</span>
<span class="sd">                </span>
<span class="sd">            &#39;outputDirSuffix&#39; : the subfolder name to be appended to the path</span>
<span class="sd">            of the directory of the input file, the output files will be</span>
<span class="sd">            written in that subfolder</span>
<span class="sd">                </span>
<span class="sd">            &#39;outputDir&#39; : the full path of the output files directory</span>
<span class="sd">            </span>
<span class="sd">            &#39;pathBaseName&#39; : base name for the output files</span>
<span class="sd">            (full path + radical for all output files)</span>
<span class="sd">            </span>
<span class="sd">            &#39;pitch_output_file&#39; : output filename for the estimated melody line</span>
<span class="sd">            appending &#39;_pitches.txt&#39; to the radical.</span>
<span class="sd">                </span>
<span class="sd">            &#39;voc_output_file&#39; : output filename for the estimated &#39;lead</span>
<span class="sd">            instrument&#39;, appending &#39;_voc.wav&#39; to the radical.</span>
<span class="sd">        </span>
<span class="sd">        Additionally, the estimated &#39;accompaniment&#39; and &#39;lead&#39; with unvoiced</span>
<span class="sd">        parts estimation are written to the corresponding filename without</span>
<span class="sd">        these unvoiced parts, to which &#39;_VUIMM.wav&#39; is appended.</span>
<span class="sd">        </span>
<span class="sd">     imageCanvas : instance from MplCanvas or MplCanvas3Axes</span>
<span class="sd">        canvas used to draw the image of HF0</span>
<span class="sd">        </span>
<span class="sd">     scaleData : double</span>
<span class="sd">        maximum value of the input data array.</span>
<span class="sd">        With scipy.io.wavfile, the data array type is integer, and does not</span>
<span class="sd">        fit well with the algorithm, so we need this scaleData parameter to</span>
<span class="sd">        navigate back and forth between the double and integer representation.</span>
<span class="sd">        </span>
<span class="sd">     scopeAllowedHF0 : double</span>
<span class="sd">        scope of allowed F0s around the estimated/given melody line </span>
<span class="sd">    </span>
<span class="sd">     stftParams : dictionary with the parameters for the time-frequency</span>
<span class="sd">     representation (Short-Time Fourier Transform - STFT), with the keys:</span>
<span class="sd">            </span>
<span class="sd">            &#39;hopsize&#39; : the step, in number of samples, between analysis</span>
<span class="sd">            frames for the STFT</span>
<span class="sd">            </span>
<span class="sd">            &#39;NFT&#39; : the number of Fourier bins on which the Fourier transforms</span>
<span class="sd">            are computed.</span>
<span class="sd">            </span>
<span class="sd">            &#39;windowSizeInSamples&#39; : analysis frame length, in samples</span>
<span class="sd">    </span>
<span class="sd">     SIMMParams : dictionary with the parameters of the SIMM model</span>
<span class="sd">     (Smoothed Instantaneous Mixture Model [DRDF2010]_), with following keys:</span>
<span class="sd">            </span>
<span class="sd">            &#39;alphaL&#39;, &#39;alphaR&#39; : double</span>
<span class="sd">                stereo model, panoramic parameters for the lead part</span>
<span class="sd">                </span>
<span class="sd">            &#39;betaL&#39;, &#39;betaR&#39; : (R,) ndarray</span>
<span class="sd">                stereo model, panoramic parameters for each of the component of</span>
<span class="sd">                the accompaniment part.</span>
<span class="sd">                </span>
<span class="sd">            </span>
<span class="sd">            &#39;chirpPerF0&#39; : integer</span>
<span class="sd">                number of F0s between two &#39;stable&#39; F0s, modelled</span>
<span class="sd">                as chirps.</span>
<span class="sd">                </span>
<span class="sd">            &#39;F0Table&#39; : (NF0,) ndarray</span>
<span class="sd">                frequency in Hz for each of the F0s appearing in WF0</span>
<span class="sd">            </span>
<span class="sd">            &#39;HF0&#39; : (NF0*chirpPerF0, N) ndarray, *estimated*</span>
<span class="sd">                amplitude array corresponding to the different F0s (this is</span>
<span class="sd">                what you want if you want the visualisation representation of</span>
<span class="sd">                the pitch saliances).</span>
<span class="sd">                </span>
<span class="sd">            &#39;HF00&#39; : (NF0*chirpPerF0, N) ndarray, *estimated*</span>
<span class="sd">                amplitude array HF0, after being zeroed everywhere outside</span>
<span class="sd">                the given scope from the estimated melody</span>
<span class="sd">                </span>
<span class="sd">            &#39;HGAMMA&#39; : (P, K) ndarray, *estimated*</span>
<span class="sd">                amplitude array corresponding to the different smooth shapes,</span>
<span class="sd">                decomposition of the filters on the smooth shapes in WGAMMA</span>
<span class="sd">                </span>
<span class="sd">            &#39;HM&#39; : (R, N) ndarray, *estimated*</span>
<span class="sd">                amplitude array corresponding to the decomposition of the</span>
<span class="sd">                accompaniment on the spectral shapes in WM</span>
<span class="sd">                </span>
<span class="sd">            &#39;HPHI&#39; : (K, N) ndarray, *estimated*</span>
<span class="sd">                amplitude array corresponding to the decomposition of the</span>
<span class="sd">                filter part on the filter spectral shapes in WPHI, defined</span>
<span class="sd">                as np.dot(WGAMMA, HGAMMA)</span>
<span class="sd">            </span>
<span class="sd">            &#39;K&#39; : integer</span>
<span class="sd">                number of filters for the filter part decomposition</span>

<span class="sd">            &#39;maxF0&#39; : double</span>
<span class="sd">                the highest F0 candidate</span>

<span class="sd">            &#39;minF0&#39; : double</span>
<span class="sd">                the lowest F0 candidate</span>

<span class="sd">            &#39;NF0&#39; : integer</span>
<span class="sd">                number of F0s in total</span>

<span class="sd">            &#39;niter&#39; : integer</span>
<span class="sd">                number of iterations for the estimation algorithm</span>

<span class="sd">            &#39;P&#39; : integer</span>
<span class="sd">                number of smooth spectral shapes for the filter part (in WGAMMA)</span>

<span class="sd">            &#39;R&#39; : integer</span>
<span class="sd">                number of spectral shapes for the accompaniment part (in WM)</span>

<span class="sd">            &#39;stepNotes&#39; : integer</span>
<span class="sd">                number of F0s between two semitones</span>
<span class="sd">            </span>
<span class="sd">            &#39;WF0&#39; : (F, NF0*chirpPerF0) ndarray, *fixed*</span>
<span class="sd">                &#39;dictionary&#39; of harmonic spectral shapes for the F0 candidates</span>
<span class="sd">                generated thanks to the KLGLOTT88 model [DRDF2010]</span>

<span class="sd">            &#39;WGAMMA&#39; : (F, P) ndarray, *fixed*</span>
<span class="sd">                &#39;dictionary&#39; of smooth spectral shapes for the filter part</span>

<span class="sd">            &#39;WM&#39; : (F, R) ndarray, *estimated*</span>
<span class="sd">                array of spectral shapes that are directly *estimated* on the</span>
<span class="sd">                signal</span>
<span class="sd">                </span>
<span class="sd">     verbose : boolean</span>
<span class="sd">        if True, the program writes some information about what is happening</span>
<span class="sd">    </span>
<span class="sd">     wavCanvas : instance from MplCanvas or MplCanvas3Axes</span>
<span class="sd">        the canvas that is going to be used to draw the input audio waveform</span>
<span class="sd">        </span>
<span class="sd">    </span>
<span class="sd">     XL, XR : (F, N) ndarray</span>
<span class="sd">        resp. left and right channel STFT arrays</span>
<span class="sd">    </span>
<span class="sd">    **Methods**</span>
<span class="sd">    </span>
<span class="sd">     Constructor : reads the input audio file, computes the STFT,</span>
<span class="sd">        generates the different dictionaries (for the source part,</span>
<span class="sd">        harmonic patterns WF0, and for the filter part, smooth</span>
<span class="sd">        patterns WGAMMA).</span>
<span class="sd">        </span>
<span class="sd">     automaticMelodyAndSeparation :</span>
<span class="sd">        launches sequence of methods to estimate the parameters, estimate the</span>
<span class="sd">        melody, then re-estimate the parameters and at last separate the</span>
<span class="sd">        lead from the rest, considering the lead is the most energetic source</span>
<span class="sd">        of the mixture (with some continuity regularity)</span>
<span class="sd">        </span>
<span class="sd">     estimSIMMParams :</span>
<span class="sd">        estimates the parameters of the SIMM, i.e. HF0, HPHI, HGAMMA, HM and WM</span>
<span class="sd">        </span>
<span class="sd">     estimStereoSIMMParams :</span>
<span class="sd">        estimates the parameters of the stereo version of the SIMM,</span>
<span class="sd">        i.e. same parameters as estimSIMMParams, with the alphas and betas </span>

<span class="sd">     estimStereoSUIMMParams :</span>
<span class="sd">        same as above, but first adds &#39;noise&#39; components to the source part</span>

<span class="sd">     initiateHF0WithIndexBestPath :</span>
<span class="sd">        computes the initial HF0, before the estimation, given the melody line</span>
<span class="sd">        (estimated or not)</span>

<span class="sd">     runViterbi :</span>
<span class="sd">        estimates the melody line from HF0, the energies of each F0 candidates</span>

<span class="sd">     setOutputFileNames :</span>
<span class="sd">        triggered when the text fields are changed, changing the output</span>
<span class="sd">        filenames</span>

<span class="sd">     writeSeparatedSignals :</span>
<span class="sd">        computing and writing the adaptive Wiener filtered separated files</span>

<span class="sd">     :py:func:`writeSeparatedSignalsWithUnvoice` :</span>
<span class="sd">        computing and writing the adaptive Wiener filtered separated files,</span>
<span class="sd">        unvoiced parts.</span>
<span class="sd">    </span>
<span class="sd">    **References**</span>
<span class="sd">    </span>
<span class="sd">    This is a class that encapsulates our work on source separation,</span>
<span class="sd">    published as:</span>
<span class="sd">    </span>
<span class="sd">    .. [DDR2011] J.-L. Durrieu, B. David and G. Richard,</span>
<span class="sd">       A Musically Motivated Mid-Level Representation</span>
<span class="sd">       For Pitch Estimation And Musical Audio Source Separation,</span>
<span class="sd">       IEEE Journal of Selected Topics on Signal Processing,</span>
<span class="sd">       October 2011, Vol. 5 (6), pp. 1180 - 1191.</span>
<span class="sd">        </span>
<span class="sd">    and</span>
<span class="sd">        </span>
<span class="sd">    .. [DRDF2010] J.-L. Durrieu, G. Richard, B. David and C. F\&#39;evotte,</span>
<span class="sd">       Source/Filter Model for Main Melody Extraction</span>
<span class="sd">       From Polyphonic Audio Signals,</span>
<span class="sd">       IEEE Transactions on Audio, Speech and Language Processing,</span>
<span class="sd">       special issue on Signal Models and Representations of Musical</span>
<span class="sd">       and Environmental Sounds, March 2010, vol. 18 (3), pp. 564 -- 575.</span>
<span class="sd">       </span>
<span class="sd">    As of 3/1/2012, available at http://www.durrieu.ch/research</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># files : dict containing filename to I/O</span>
    <span class="c"># stftParams : dict containing the parameters for the STFT</span>
    <span class="n">files</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">stftParams</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">SIMMParams</span> <span class="o">=</span> <span class="p">{}</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputAudioFilename</span><span class="p">,</span>
                 <span class="n">windowSize</span><span class="o">=</span><span class="mf">0.0464</span><span class="p">,</span> <span class="n">hopsize</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">NFT</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">nbIter</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                 <span class="n">numCompAccomp</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span>
                 <span class="n">minF0</span><span class="o">=</span><span class="mi">39</span><span class="p">,</span> <span class="n">maxF0</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> <span class="n">stepNotes</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span>
                 <span class="n">chirpPerF0</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">K_numFilters</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                 <span class="n">P_numAtomFilters</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>
                 <span class="n">imageCanvas</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">wavCanvas</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">progressBar</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">verbose</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                 <span class="n">outputDirSuffix</span><span class="o">=</span><span class="s">&#39;/&#39;</span><span class="p">,</span>
                 <span class="n">minF0search</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">maxF0search</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">tfrepresentation</span><span class="o">=</span><span class="s">&#39;stft&#39;</span><span class="p">,</span>
                 <span class="n">cqtfmax</span><span class="o">=</span><span class="mi">4000</span><span class="p">,</span>
                 <span class="n">cqtfmin</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
                 <span class="n">cqtbins</span><span class="o">=</span><span class="mi">48</span><span class="p">,</span>
                 <span class="n">cqtWinFunc</span><span class="o">=</span><span class="n">slf</span><span class="o">.</span><span class="n">minqt</span><span class="o">.</span><span class="n">sqrt_blackmanharris</span><span class="p">,</span>
                 <span class="n">cqtAtomHopFactor</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span>
                 <span class="n">initHF00</span><span class="o">=</span><span class="s">&#39;random&#39;</span><span class="p">,</span>
                 <span class="n">freeMemory</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;During init, process is initiated, STFTs are computed,</span>
<span class="sd">        and the parameters are stored.</span>
<span class="sd">        </span>
<span class="sd">        **Parameters**</span>
<span class="sd">        </span>
<span class="sd">         inputAudioFilename : string</span>
<span class="sd">            filename of the input audio file</span>
<span class="sd">         windowSize : double, optional</span>
<span class="sd">            analysis frame (&#39;windows&#39;) size, in s. By default, 0.0464s</span>
<span class="sd">         nbIter : integer, optional</span>
<span class="sd">            number of iterations for the estimation algorithm. By default, 10</span>
<span class="sd">         numCompAccomp : integer, optional</span>
<span class="sd">            number of components for the accompaniment, default = 40</span>
<span class="sd">         minF0 : double/integer, optional</span>
<span class="sd">            lowest F0 candidate (in Hz), default=60Hz</span>
<span class="sd">         maxF0 : double/integer, optional</span>
<span class="sd">            highest F0 candidate (in Hz), default=2000Hz</span>
<span class="sd">         stepNotes : integer, optional</span>
<span class="sd">            number of F0 candidates in one semitone, default=16 F0s/semitone</span>
<span class="sd">         K_numFilters : integer, optional</span>
<span class="sd">            number of filter spectral shapes, default=4</span>
<span class="sd">         P_numAtomFilters : integer, optional</span>
<span class="sd">            number of atomic filter smooth spectral shapes, default=30</span>
<span class="sd">         imageCanvas : MplCanvas/MplCanvas3Axes, optional</span>
<span class="sd">            an instance of the MplCanvas/MplCanvas3Axes, giving access to the</span>
<span class="sd">            axes where to draw the HF0 image. By default=None</span>
<span class="sd">         wavCanvas : MplCanvas/MplCanvas3Axes, optional</span>
<span class="sd">            an instance of the MplCanvas/MplCanvas3Axes, giving access to the</span>
<span class="sd">            axes to draw the waveform of the input signal.</span>
<span class="sd">         progressBar : boolean, optional ???</span>
<span class="sd">            ???</span>
<span class="sd">         verbose : boolean, optional</span>
<span class="sd">            Whether to write out or not information about the evolution of the</span>
<span class="sd">            algorithm. By default=False.</span>
<span class="sd">         outputDirSuffix : string, optional</span>
<span class="sd">            the subfolder name (to be appended to the full path to the audio</span>
<span class="sd">            signal), where the output files are going to be written. By default</span>
<span class="sd">            =&#39;/&#39;</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># discarding upper case letters from the input stri</span>
        <span class="n">tfrepresentation</span> <span class="o">=</span> <span class="n">tfrepresentation</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">tfrepresentation</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">knownTransfos</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s">&quot;The desired Time-Freq representation &quot;</span><span class="o">+</span>
                                 <span class="n">tfrepresentation</span><span class="o">+</span><span class="s">&quot; is not a recognized one.</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">+</span>
                                 <span class="s">&quot;Please choose from &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">knownTransfos</span><span class="p">))</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">tfrepresentation</span> <span class="o">=</span> <span class="n">tfrepresentation</span>
        <span class="c"># representation specific parameters:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfrepresentation</span> <span class="ow">in</span> <span class="n">knownTransfos</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;cqtfmin&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cqtfmin</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;cqtfmax&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cqtfmax</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;cqtbins&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cqtbins</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;cqtWinFunc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cqtWinFunc</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;cqtAtomHopFactor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cqtAtomHopFactor</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;inputAudioFilename&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">inputAudioFilename</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">imageCanvas</span> <span class="o">=</span> <span class="n">imageCanvas</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wavCanvas</span> <span class="o">=</span> <span class="n">wavCanvas</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">displayEvolution</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">imageCanvas</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">displayEvolution</span> <span class="o">=</span> <span class="bp">False</span>
        
        <span class="k">if</span> <span class="n">inputAudioFilename</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span> <span class="o">!=</span> <span class="s">&quot;.wav&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;File not WAV file? Only WAV format support, &quot;</span><span class="o">+</span>\
                             <span class="s">&quot;for now...&quot;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;outputDirSuffix&#39;</span><span class="p">]</span>  <span class="o">=</span> <span class="n">outputDirSuffix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;outputDir&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>\
            <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;inputAudioFilename&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span>\
            <span class="s">&#39;/&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;outputDirSuffix&#39;</span><span class="p">]</span> <span class="o">+</span><span class="s">&#39;/&#39;</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;outputDir&#39;</span><span class="p">]):</span>
            <span class="k">print</span> <span class="s">&quot;Output directory already existing - &quot;</span><span class="o">+</span>\
                  <span class="s">&quot;NB: overwriting files in:&quot;</span>
            <span class="k">print</span> <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;outputDir&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Creating output directory&quot;</span>
            <span class="k">print</span> <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;outputDir&#39;</span><span class="p">]</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;outputDir&#39;</span><span class="p">])</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;pathBaseName&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;outputDir&#39;</span><span class="p">]</span> <span class="o">+</span> \
                                     <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;inputAudioFilename&#39;</span>\
                                                <span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">][:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;mus_output_file&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;pathBaseName&#39;</span><span class="p">]</span><span class="o">+</span>\
                                            <span class="s">&#39;_acc.wav&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;voc_output_file&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;pathBaseName&#39;</span><span class="p">]</span><span class="o">+</span>\
                                            <span class="s">&#39;_lead.wav&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;pitch_output_file&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;pathBaseName&#39;</span><span class="p">]</span><span class="o">+</span>\
                                              <span class="s">&#39;_pitches.txt&#39;</span><span class="p">)</span>
        
        <span class="k">print</span> <span class="s">&quot;Writing the different following output files:&quot;</span>
        <span class="k">print</span> <span class="s">&quot;    separated lead          in&quot;</span><span class="p">,</span> \
              <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;voc_output_file&#39;</span><span class="p">]</span> 
        <span class="k">print</span> <span class="s">&quot;    separated accompaniment in&quot;</span><span class="p">,</span> \
              <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;mus_output_file&#39;</span><span class="p">]</span> 
        <span class="k">print</span> <span class="s">&quot;    separated lead + unvoc  in&quot;</span><span class="p">,</span> \
              <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;voc_output_file&#39;</span><span class="p">][:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="s">&#39;_VUIMM.wav&#39;</span>
        <span class="k">print</span> <span class="s">&quot;    separated acc  - unvoc  in&quot;</span><span class="p">,</span> \
              <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;mus_output_file&#39;</span><span class="p">][:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="s">&#39;_VUIMM.wav&#39;</span>
        <span class="k">print</span> <span class="s">&quot;    estimated pitches       in&quot;</span><span class="p">,</span> \
              <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;pitch_output_file&#39;</span><span class="p">]</span> 
        
        <span class="c"># read the WAV file and store the STFT</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="n">wav</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;inputAudioFilename&#39;</span><span class="p">])</span>
        <span class="c"># for some bad format wav files, data is a str?</span>
        <span class="c"># cf. files from beat/tempo evaluation campaign of MIREX</span>
        <span class="c">## print self.fs, data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scaleData</span> <span class="o">=</span> <span class="mf">1.2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="c"># to rescale the data.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataType</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaleData</span> <span class="c"># makes data vary from -1 to 1</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">data</span><span class="o">.</span><span class="n">size</span><span class="p">:</span> <span class="c"># data is multi-channel</span>
            <span class="k">print</span> <span class="s">&quot;The audio file is not stereo. Making stereo out of mono.&quot;</span>
            <span class="k">print</span> <span class="s">&quot;(You could also try the older separateLead.py...)&quot;</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">data</span><span class="p">,</span> <span class="n">data</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">numberChannels</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;The data is multichannel, but not stereo... </span><span class="se">\n</span><span class="s">&quot;</span>
            <span class="k">print</span> <span class="s">&quot;Unfortunately this program does not scale well. Data is </span><span class="se">\n</span><span class="s">&quot;</span>
            <span class="k">print</span> <span class="s">&quot;reduced to its 2 first channels.</span><span class="se">\n</span><span class="s">&quot;</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">numberChannels</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="c"># parameters for the STFT:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;windowSizeInSamples&#39;</span><span class="p">]</span> <span class="o">=</span> \
                 <span class="n">slf</span><span class="o">.</span><span class="n">nextpow2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">windowSize</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">hopsize</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;hopsize&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;windowSizeInSamples&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="mf">8.</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;hopsize&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="n">hopsize</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">NFT</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;NFT&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;windowSizeInSamples&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;NFT&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">NFT</span>

        <span class="c"># offsets are the number of samples added to the beginning of data</span>
        <span class="c"># during the TF representation computation:</span>
        <span class="c"># TODO: make this less of a hack?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;offsets&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s">&#39;stft&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;windowSizeInSamples&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
            <span class="s">&#39;minqt&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s">&#39;mqt&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s">&#39;hybridcqt&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s">&#39;cqt&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,}</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;niter&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nbIter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;R&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numCompAccomp</span>
        
        <span class="c">##self.XR, F, N = slf.stft(data[:,0], fs=self.fs,</span>
        <span class="c">##                hopsize=self.stftParams[&#39;hopsize&#39;] ,</span>
        <span class="c">##                window=slf.sinebell(\</span>
        <span class="c">##                       self.stftParams[&#39;windowSizeInSamples&#39;]),</span>
        <span class="c">##                nfft=self.stftParams[&#39;NFT&#39;] )</span>
        <span class="c">##self.XL, F, N = slf.stft(data[:,1], fs=self.fs,</span>
        <span class="c">##                hopsize=self.stftParams[&#39;hopsize&#39;] ,</span>
        <span class="c">##                window=slf.sinebell(\</span>
        <span class="c">##                       self.stftParams[&#39;windowSizeInSamples&#39;]),</span>
        <span class="c">##                nfft=self.stftParams[&#39;NFT&#39;] )</span>
        
        <span class="c"># non need to store this.</span>
        <span class="c">## self.SXR = np.abs(self.XR) ** 2</span>
        <span class="c">## self.SXL = np.abs(self.XL) ** 2</span>
        
        <span class="c"># drawing the waveform to wavCanvas:</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavCanvas</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavCanvas</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">imageCanvas</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wavCanvas</span><span class="o">.</span><span class="n">ax2</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wavCanvas</span><span class="o">.</span><span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> \
                                        <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;hopsize&#39;</span><span class="p">]),</span>\
                                        <span class="n">data</span><span class="p">)</span>
                <span class="c">#self.wavCanvas.ax2.plot(np.arange(data.shape[0]) / \</span>
                <span class="c">#                       np.double(self.fs), \</span>
                <span class="c">#                       data)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wavCanvas</span><span class="o">.</span><span class="n">ax2</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s">&#39;tight&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wavCanvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wavCanvas</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wavCanvas</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> \
                                       <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">),</span> \
                                       <span class="n">data</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wavCanvas</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s">&#39;tight&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wavCanvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
        
        <span class="k">del</span> <span class="n">data</span>
        
        <span class="c"># TODO: also process these as options:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;minF0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">minF0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;maxF0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">maxF0</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">F</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;NFT&#39;</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c"># self.F, self.N = self.XR.shape</span>
        <span class="c"># this is the number of F0s within one semitone</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;stepNotes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stepNotes</span>
        <span class="c"># number of spectral shapes for the filter part</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;K&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">K_numFilters</span>
        <span class="c"># number of elements in dictionary of smooth filters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;P&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">P_numAtomFilters</span>
        <span class="c"># number of chirped spectral shapes between each F0</span>
        <span class="c"># this feature should be further studied before</span>
        <span class="c"># we find a good way of doing that.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;chirpPerF0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">chirpPerF0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scopeAllowedHF0</span> <span class="o">=</span> <span class="mf">4.0</span> <span class="o">/</span> <span class="mf">1.0</span>
        
        <span class="c"># Create the harmonic combs, for each F0 between minF0 and maxF0:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;initHF00&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">initHF00</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">computeWF0</span><span class="p">()</span>
        
        <span class="c"># for debug:</span>
        <span class="k">if</span> <span class="bp">False</span><span class="p">:</span> <span class="c">#DEBUG</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">imageCanvas</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">XR</span><span class="p">)),</span>
                                       <span class="n">aspect</span><span class="o">=</span><span class="s">&#39;auto&#39;</span><span class="p">,</span><span class="n">origin</span><span class="o">=</span><span class="s">&#39;lower&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">imageCanvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
            <span class="k">raise</span> <span class="ne">KeyboardInterrupt</span><span class="p">(</span><span class="s">&quot;Check these matrices !&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">False</span><span class="p">:</span> <span class="c">#DEBUG</span>
            <span class="kn">from</span> <span class="nn">IPython.Shell</span> <span class="kn">import</span> <span class="n">IPShellEmbed</span>
            
            <span class="n">ipshell</span> <span class="o">=</span> <span class="n">IPShellEmbed</span><span class="p">()</span>
            
            <span class="n">ipshell</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;WF0&#39;</span><span class="p">]),</span>
                                       <span class="n">aspect</span><span class="o">=</span><span class="s">&#39;auto&#39;</span><span class="p">,</span>
                                       <span class="n">origin</span><span class="o">=</span><span class="s">&#39;lower&#39;</span><span class="p">,)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">XR</span><span class="p">)),</span><span class="n">aspect</span><span class="o">=</span><span class="s">&#39;auto&#39;</span><span class="p">,</span><span class="n">origin</span><span class="o">=</span><span class="s">&#39;lower&#39;</span><span class="p">)</span>
        <span class="c"># Create the dictionary of smooth filters, for the filter part of</span>
        <span class="c"># the lead isntrument:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;WGAMMA&#39;</span><span class="p">]</span> <span class="o">=</span> \
             <span class="n">slf</span><span class="o">.</span><span class="n">generateHannBasis</span><span class="p">(</span><span class="n">numberFrequencyBins</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">,</span>
                                   <span class="n">sizeOfFourier</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;NFT&#39;</span><span class="p">],</span>
                                   <span class="n">Fs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span>
                                   <span class="n">frequencyScale</span><span class="o">=</span><span class="s">&#39;linear&#39;</span><span class="p">,</span> 
                                   <span class="n">numberOfBasis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;P&#39;</span><span class="p">],</span>
                                   <span class="n">overlap</span><span class="o">=.</span><span class="mi">75</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">trackingParams</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trackingParams</span><span class="p">[</span><span class="s">&#39;minF0search&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;minF0&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trackingParams</span><span class="p">[</span><span class="s">&#39;maxF0search&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;maxF0&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">minF0search</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trackingParams</span><span class="p">[</span><span class="s">&#39;minF0search&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">minF0search</span>
        <span class="k">if</span> <span class="n">maxF0search</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trackingParams</span><span class="p">[</span><span class="s">&#39;maxF0search&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">maxF0search</span>
        
        <span class="k">print</span> <span class="s">&quot;Some parameter settings:&quot;</span>
        <span class="k">print</span> <span class="s">&quot;    Size of analysis windows: &quot;</span><span class="p">,</span> \
              <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;windowSizeInSamples&#39;</span><span class="p">]</span> 
        <span class="k">print</span> <span class="s">&quot;    Hopsize: &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;hopsize&#39;</span><span class="p">]</span> 
        <span class="k">print</span> <span class="s">&quot;    Size of Fourier transforms: &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;NFT&#39;</span><span class="p">]</span> 
        <span class="k">print</span> <span class="s">&quot;    Number of iterations to be done: &quot;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;niter&#39;</span><span class="p">]</span>  
        <span class="k">print</span> <span class="s">&quot;    Number of elements in WM: &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;R&#39;</span><span class="p">]</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">freeMemory</span> <span class="o">=</span> <span class="n">freeMemory</span>
    
<div class="viewcode-block" id="SeparateLeadProcess.setOutputFileNames"><a class="viewcode-back" href="../../../reference/separateleadstereo.html#pyfasst.SeparateLeadStereo.SeparateLeadStereoTF.SeparateLeadProcess.setOutputFileNames">[docs]</a>    <span class="k">def</span> <span class="nf">setOutputFileNames</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outputDirSuffix</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If already loaded a wav file, at this point, we can redefine</span>
<span class="sd">        where we want the output files to be written.</span>
<span class="sd">        </span>
<span class="sd">        Could be used, for instance, between the first estimation or the</span>
<span class="sd">        Viterbi smooth estimation of the melody, and the re-estimation</span>
<span class="sd">        of the parameters.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">print</span> <span class="s">&quot;Redefining the Output Filenames !&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;outputDirSuffix&#39;</span><span class="p">]</span>  <span class="o">=</span> <span class="n">outputDirSuffix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;outputDir&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>\
            <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;inputAudioFilename&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span>\
            <span class="s">&#39;/&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;outputDirSuffix&#39;</span><span class="p">]</span> <span class="o">+</span><span class="s">&#39;/&#39;</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;outputDir&#39;</span><span class="p">]):</span>
            <span class="k">print</span> <span class="s">&quot;Output directory already existing - &quot;</span><span class="o">+</span>\
                  <span class="s">&quot;NB: overwriting files in:&quot;</span>
            <span class="k">print</span> <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;outputDir&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Creating output directory&quot;</span>
            <span class="k">print</span> <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;outputDir&#39;</span><span class="p">]</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;outputDir&#39;</span><span class="p">])</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;pathBaseName&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;outputDir&#39;</span><span class="p">]</span> <span class="o">+</span> \
                                     <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span>\
                                      <span class="s">&#39;inputAudioFilename&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">][:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;mus_output_file&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;pathBaseName&#39;</span><span class="p">]</span><span class="o">+</span>\
                                            <span class="s">&#39;_acc.wav&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;voc_output_file&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;pathBaseName&#39;</span><span class="p">]</span><span class="o">+</span>\
                                            <span class="s">&#39;_lead.wav&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;pitch_output_file&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;pathBaseName&#39;</span><span class="p">]</span><span class="o">+</span>\
                                              <span class="s">&#39;_pitches.txt&#39;</span><span class="p">)</span>
        
        <span class="k">print</span> <span class="s">&quot;Writing the different following output files:&quot;</span>
        <span class="k">print</span> <span class="s">&quot;    separated lead          in&quot;</span><span class="p">,</span> \
              <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;voc_output_file&#39;</span><span class="p">]</span> 
        <span class="k">print</span> <span class="s">&quot;    separated accompaniment in&quot;</span><span class="p">,</span> \
              <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;mus_output_file&#39;</span><span class="p">]</span> 
        <span class="k">print</span> <span class="s">&quot;    separated lead + unvoc  in&quot;</span><span class="p">,</span> \
              <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;voc_output_file&#39;</span><span class="p">][:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="s">&#39;_VUIMM.wav&#39;</span>
        <span class="k">print</span> <span class="s">&quot;    separated acc  - unvoc  in&quot;</span><span class="p">,</span> \
              <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;mus_output_file&#39;</span><span class="p">][:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="s">&#39;_VUIMM.wav&#39;</span>
        <span class="k">print</span> <span class="s">&quot;    estimated pitches       in&quot;</span><span class="p">,</span> \
              <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;pitch_output_file&#39;</span><span class="p">]</span>
    </div>
<div class="viewcode-block" id="SeparateLeadProcess.computeWF0"><a class="viewcode-back" href="../../../reference/separateleadstereo.html#pyfasst.SeparateLeadStereo.SeparateLeadStereoTF.SeparateLeadProcess.computeWF0">[docs]</a>    <span class="k">def</span> <span class="nf">computeWF0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes the frequency basis for the source part of SIMM,</span>
<span class="sd">        if tfrepresentation is a CQT, it also computes the cqt/hybridcqt</span>
<span class="sd">        transform object. </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfrepresentation</span> <span class="o">==</span> <span class="s">&#39;stftold&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;F0Table&#39;</span><span class="p">],</span> <span class="n">WF0</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">slf</span><span class="o">.</span><span class="n">generate_WF0_chirped</span><span class="p">(</span>
                    <span class="n">minF0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;minF0&#39;</span><span class="p">],</span>
                    <span class="n">maxF0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;maxF0&#39;</span><span class="p">],</span>
                    <span class="n">Fs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span>
                    <span class="n">Nfft</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;NFT&#39;</span><span class="p">],</span>
                    <span class="n">stepNotes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;stepNotes&#39;</span><span class="p">],</span>
                    <span class="n">lengthWindow</span><span class="o">=</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;windowSizeInSamples&#39;</span><span class="p">],</span>
                    <span class="n">Ot</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="c"># 20130130 used to be 0.25</span>
                    <span class="n">perF0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;chirpPerF0&#39;</span><span class="p">],</span>
                    <span class="n">depthChirpInSemiTone</span><span class="o">=.</span><span class="mi">15</span><span class="p">,</span>
                    <span class="n">loadWF0</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                    <span class="n">analysisWindow</span><span class="o">=</span><span class="s">&#39;sinebell&#39;</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;WF0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">WF0</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">,</span> <span class="p">:]</span> <span class="c"># ensure same size as SX</span>
            <span class="c"># number of harmonic combs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;NF0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;F0Table&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> 
            <span class="c"># Normalization:</span>
            <span class="c"># by max or by sum?</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;WF0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;WF0&#39;</span><span class="p">]</span> <span class="o">/</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;WF0&#39;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfrepresentation</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;hybridcqt&#39;</span><span class="p">,</span> <span class="s">&#39;minqt&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="bp">False</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;    Compute WF0, with MinQT transform&quot;</span>
                <span class="k">print</span> <span class="s">&quot;        - potentially (very) long -&quot;</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">print</span> <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span>
            <span class="n">cqtwindowlength</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">/</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;cqtfmin&#39;</span><span class="p">]</span> <span class="o">*</span>
                 <span class="p">(</span><span class="mf">2.</span><span class="o">**</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;cqtbins&#39;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;F0Table&#39;</span><span class="p">],</span> <span class="n">WF0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mqt</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">slf</span><span class="o">.</span><span class="n">generate_WF0_MinQT_chirped</span><span class="p">(</span>
                    <span class="n">minF0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;minF0&#39;</span><span class="p">],</span>
                    <span class="n">maxF0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;maxF0&#39;</span><span class="p">],</span>
                    <span class="n">cqtfmax</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;cqtfmax&#39;</span><span class="p">],</span>
                    <span class="n">cqtfmin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;cqtfmin&#39;</span><span class="p">],</span>
                    <span class="n">cqtbins</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;cqtbins&#39;</span><span class="p">],</span>
                    <span class="n">Fs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span>
                    <span class="n">Nfft</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;NFT&#39;</span><span class="p">],</span>
                    <span class="n">stepNotes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;stepNotes&#39;</span><span class="p">],</span>
                    <span class="n">lengthWindow</span><span class="o">=</span><span class="n">cqtwindowlength</span><span class="p">,</span>
                    <span class="c"># self.stftParams[&#39;windowSizeInSamples&#39;],</span>
                    <span class="n">Ot</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                    <span class="n">perF0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;chirpPerF0&#39;</span><span class="p">],</span>
                    <span class="n">depthChirpInSemiTone</span><span class="o">=.</span><span class="mi">5</span><span class="p">,</span>
                    <span class="n">loadWF0</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                    <span class="n">cqtWinFunc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;cqtWinFunc&#39;</span><span class="p">],</span>
                    <span class="n">atomHopFactor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;cqtAtomHopFactor&#39;</span><span class="p">],</span>
                    <span class="n">analysisWindow</span><span class="o">=</span><span class="s">&#39;sinebell&#39;</span><span class="p">,</span>
                    <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;WF0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">WF0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">WF0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            
            <span class="c"># number of harmonic combs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;NF0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;F0Table&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
            <span class="c"># self.F is different from the STFT one, resetting it:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">F</span> <span class="o">=</span> <span class="n">WF0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;hopsize&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">cqtkernel</span><span class="o">.</span><span class="n">atomHOP</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;NFT&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">cqtkernel</span><span class="o">.</span><span class="n">linFTLen</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;windowSizeInSamples&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">cqtkernel</span><span class="o">.</span><span class="n">linFTLen</span>
                <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">octaveNr</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                <span class="p">)</span> <span class="c"># 20130405T0355 DJL should guarantee better for chunk sizes</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mqt</span> <span class="o">=</span> <span class="n">tft</span><span class="o">.</span><span class="n">tftransforms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tfrepresentation</span><span class="p">](</span>
                <span class="n">fmin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;cqtfmin&#39;</span><span class="p">],</span>
                <span class="n">fmax</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;cqtfmax&#39;</span><span class="p">],</span>
                <span class="n">bins</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;cqtbins&#39;</span><span class="p">],</span>
                <span class="n">fs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span>
                <span class="n">linFTLen</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;NFT&#39;</span><span class="p">],</span>
                <span class="n">atomHopFactor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;cqtAtomHopFactor&#39;</span><span class="p">],</span>
                <span class="n">winFunc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;cqtWinFunc&#39;</span><span class="p">],</span>
                <span class="n">perfRast</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;F0Table&#39;</span><span class="p">],</span> <span class="n">WF0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mqt</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">slf</span><span class="o">.</span><span class="n">generate_WF0_TR_chirped</span><span class="p">(</span>
                    <span class="n">transform</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="p">,</span>
                    <span class="n">minF0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;minF0&#39;</span><span class="p">],</span>
                    <span class="n">maxF0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;maxF0&#39;</span><span class="p">],</span>
                    <span class="n">stepNotes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;stepNotes&#39;</span><span class="p">],</span>
                    <span class="n">Ot</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">perF0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;chirpPerF0&#39;</span><span class="p">],</span> 
                    <span class="n">depthChirpInSemiTone</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">loadWF0</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                    <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;WF0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">WF0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">WF0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            
            <span class="c"># number of harmonic combs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;NF0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;F0Table&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
            <span class="c"># self.F is different from the STFT one, resetting it:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">F</span> <span class="o">=</span> <span class="n">WF0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="p">,</span> <span class="s">&#39;cqtkernel&#39;</span><span class="p">):</span>
                <span class="c"># updating the following parameters if the transform</span>
                <span class="c"># is a CQT type transform.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;hopsize&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">cqtkernel</span><span class="o">.</span><span class="n">atomHOP</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;NFT&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">cqtkernel</span><span class="o">.</span><span class="n">FFTLen</span>
                <span class="c">#self.stftParams[&#39;windowSizeInSamples&#39;] = (</span>
                <span class="c">#    self.mqt.cqtkernel.Nk_max</span>
                <span class="c">#    * self.mqt.octaveNr) # to be ckeched...</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;windowSizeInSamples&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">cqtkernel</span><span class="o">.</span><span class="n">FFTLen</span>
                    <span class="o">*</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">octaveNr</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                    <span class="p">)</span> <span class="c"># 20130405T0355 DJL better maybe...</span>
    </div>
<div class="viewcode-block" id="SeparateLeadProcess.computeMonoX"><a class="viewcode-back" href="../../../reference/separateleadstereo.html#pyfasst.SeparateLeadStereo.SeparateLeadStereoTF.SeparateLeadProcess.computeMonoX">[docs]</a>    <span class="k">def</span> <span class="nf">computeMonoX</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes and return SX, the mono channel or mean over the</span>
<span class="sd">        channels of the power spectrum of the signal</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fs</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="n">wav</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;inputAudioFilename&#39;</span><span class="p">])</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaleData</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfrepresentation</span> <span class="o">==</span> <span class="s">&#39;stft&#39;</span><span class="p">:</span>
            <span class="n">X</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">slf</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span>
                               <span class="n">hopsize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;hopsize&#39;</span><span class="p">]</span> <span class="p">,</span>
                               <span class="n">window</span><span class="o">=</span><span class="n">slf</span><span class="o">.</span><span class="n">sinebell</span><span class="p">(</span>\
                               <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;windowSizeInSamples&#39;</span><span class="p">]),</span>
                               <span class="n">nfft</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;NFT&#39;</span><span class="p">]</span> <span class="p">,</span>
                               <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">data</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">N</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
            <span class="c"># careful ! F and N are therefore for the whole signal!</span>
            <span class="c"># X = X[:,start:stop]</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">10</span> <span class="o">**</span> <span class="o">-</span><span class="mi">8</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfrepresentation</span> <span class="ow">in</span> <span class="n">knownTransfos</span><span class="p">:</span>
            <span class="c"># start is in frames, same for stop, therefore have to convert</span>
            <span class="c"># according to parameters of hybridcqt:</span>
            <span class="n">start</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">cqtkernel</span><span class="o">.</span><span class="n">atomHOP</span>
            <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c"># stop *= self.mqt.cqtkernel.atomHOP</span>
                <span class="n">stop</span> <span class="o">=</span> <span class="p">(</span><span class="n">stop</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">cqtkernel</span><span class="o">.</span><span class="n">atomHOP</span> 
                <span class="n">stop</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;windowSizeInSamples&#39;</span><span class="p">]</span> <span class="c">#20130318</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stop</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">computeTransform</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
            <span class="n">SX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">transfo</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
                <span class="mi">10</span> <span class="o">**</span> <span class="o">-</span><span class="mi">8</span><span class="p">)</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">transfo</span>
            <span class="k">return</span> <span class="n">SX</span>
        </div>
<div class="viewcode-block" id="SeparateLeadProcess.computeNFrames"><a class="viewcode-back" href="../../../reference/separateleadstereo.html#pyfasst.SeparateLeadStereo.SeparateLeadStereoTF.SeparateLeadProcess.computeNFrames">[docs]</a>    <span class="k">def</span> <span class="nf">computeNFrames</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        compute Nb Frames: </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;totFrames&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfrepresentation</span> <span class="ow">in</span> <span class="n">knownTransfos</span><span class="p">:</span>
                <span class="c"># NB for hybridcqt should be the same formula,</span>
                <span class="c"># but the values are a bit different in nature.</span>
                <span class="n">fs</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="n">wav</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;inputAudioFilename&#39;</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lengthData</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">totFrames</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">lengthData</span> <span class="o">-</span> 
                                      <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="c"># self.stftParams[&#39;windowSizeInSamples&#39;]) /</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;hopsize&#39;</span><span class="p">]</span>
                                     <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="c"># same number as in slf.stft</span>
                    <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">totFrames</span>
                
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">totFrames</span>
    </div>
<div class="viewcode-block" id="SeparateLeadProcess.computeStereoX"><a class="viewcode-back" href="../../../reference/separateleadstereo.html#pyfasst.SeparateLeadStereo.SeparateLeadStereoTF.SeparateLeadProcess.computeStereoX">[docs]</a>    <span class="k">def</span> <span class="nf">computeStereoX</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the transform on each of the channels.</span>
<span class="sd">        </span>
<span class="sd">        TODO this function should be modified such that we only use the</span>
<span class="sd">        :py:class:`pyfasst.tftransforms.tft.TFTransform` framework. This</span>
<span class="sd">        could prove complicated though (especially for multiple chunk</span>
<span class="sd">        processing.). Current state (20130820): hack mainly focussed on STFT</span>
<span class="sd">        as a TF representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fs</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="n">wav</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;inputAudioFilename&#39;</span><span class="p">])</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaleData</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfrepresentation</span> <span class="o">==</span> <span class="s">&#39;stft&#39;</span><span class="p">:</span>
            <span class="n">starttime</span> <span class="o">=</span> <span class="n">start</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;hopsize&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">stoptime</span> <span class="o">=</span> <span class="n">stop</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;hopsize&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stoptime</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">originalDataLen</span> <span class="o">=</span> <span class="n">stoptime</span> <span class="o">-</span> <span class="n">starttime</span>
            
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">XR</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">slf</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span>
                    <span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span><span class="c">#[starttime:stoptime,0],</span>
                    <span class="n">fs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span>
                    <span class="n">hopsize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;hopsize&#39;</span><span class="p">]</span> <span class="p">,</span>
                    <span class="n">window</span><span class="o">=</span><span class="n">slf</span><span class="o">.</span><span class="n">sinebell</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;windowSizeInSamples&#39;</span><span class="p">]),</span>
                    <span class="n">nfft</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;NFT&#39;</span><span class="p">],</span>
                    <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">stop</span> <span class="p">)</span>
                    <span class="c"># not very useful in practice</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">XR</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">slf</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span>
                    <span class="n">data</span><span class="p">,</span><span class="c">#[starttime:stoptime],</span>
                    <span class="n">fs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span>
                    <span class="n">hopsize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;hopsize&#39;</span><span class="p">]</span> <span class="p">,</span>
                    <span class="n">window</span><span class="o">=</span><span class="n">slf</span><span class="o">.</span><span class="n">sinebell</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;windowSizeInSamples&#39;</span><span class="p">]),</span>
                    <span class="n">nfft</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;NFT&#39;</span><span class="p">],</span>
                    <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">stop</span> <span class="p">)</span>
            <span class="c">#self.XR = self.XR[:,start:stop]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">XL</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">slf</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span>
                    <span class="n">data</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="c">#[starttime:stoptime,1],</span>
                    <span class="n">fs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span>
                    <span class="n">hopsize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;hopsize&#39;</span><span class="p">]</span> <span class="p">,</span>
                    <span class="n">window</span><span class="o">=</span><span class="n">slf</span><span class="o">.</span><span class="n">sinebell</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;windowSizeInSamples&#39;</span><span class="p">]),</span>
                    <span class="n">nfft</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;NFT&#39;</span><span class="p">],</span>
                    <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">XL</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">XR</span>
            <span class="k">del</span> <span class="n">F</span><span class="p">,</span> <span class="n">N</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfrepresentation</span> <span class="ow">in</span> <span class="n">knownTransfos</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">cqtkernel</span><span class="o">.</span><span class="n">atomHOP</span>
            <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c"># stop *= self.mqt.cqtkernel.atomHOP</span>
                <span class="n">stop</span> <span class="o">=</span> <span class="p">(</span><span class="n">stop</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">cqtkernel</span><span class="o">.</span><span class="n">atomHOP</span> 
                <span class="n">stop</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;windowSizeInSamples&#39;</span><span class="p">]</span> <span class="c">#20130318</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stop</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c"># also works for multi channel data:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">computeTransform</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">computeTransform</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">XR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">transfo</span><span class="p">)</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">transfo</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">computeTransform</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">XL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">transfo</span><span class="p">)</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">transfo</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># hybt.computeHybrid(data=data)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">XL</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">XR</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tfrepresentation</span>
                                 <span class="o">+</span> <span class="s">&quot; not fully implemented.&quot;</span><span class="p">)</span>
        
        <span class="c">#self.XL = self.XL[:,start:stop]</span>
        <span class="k">del</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">XR</span><span class="o">.</span><span class="n">shape</span>
        </div>
    <span class="k">def</span> <span class="nf">computeStereoSX</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="p">):</span>
        <span class="n">fs</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="n">wav</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;inputAudioFilename&#39;</span><span class="p">])</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaleData</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfrepresentation</span> <span class="o">==</span> <span class="s">&#39;stft&#39;</span><span class="p">:</span>
            <span class="n">starttime</span> <span class="o">=</span> <span class="n">start</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;hopsize&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">stoptime</span> <span class="o">=</span> <span class="n">stop</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;hopsize&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stoptime</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">originalDataLen</span> <span class="o">=</span> <span class="n">stoptime</span> <span class="o">-</span> <span class="n">starttime</span>
            
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span> <span class="c"># multichannel</span>
                <span class="n">XR</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">slf</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span>
                    <span class="n">data</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="c">#[starttime:stoptime,0],</span>
                    <span class="n">fs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span>
                    <span class="n">hopsize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;hopsize&#39;</span><span class="p">]</span> <span class="p">,</span>
                    <span class="n">window</span><span class="o">=</span><span class="n">slf</span><span class="o">.</span><span class="n">sinebell</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;windowSizeInSamples&#39;</span><span class="p">]),</span>
                    <span class="n">nfft</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;NFT&#39;</span><span class="p">]</span> <span class="p">,</span>
                    <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="c"># single channel</span>
                <span class="n">XR</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">slf</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span>
                    <span class="n">data</span><span class="p">,</span><span class="c">#[starttime:stoptime],</span>
                    <span class="n">fs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span>
                    <span class="n">hopsize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;hopsize&#39;</span><span class="p">]</span> <span class="p">,</span>
                    <span class="n">window</span><span class="o">=</span><span class="n">slf</span><span class="o">.</span><span class="n">sinebell</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;windowSizeInSamples&#39;</span><span class="p">]),</span>
                    <span class="n">nfft</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;NFT&#39;</span><span class="p">]</span> <span class="p">,</span>
                    <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">)</span>
            <span class="n">SXR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">XR</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mf">1e-8</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">XR</span>
            <span class="c">#XR = XR[:,start:stop]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">XL</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">slf</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span>
                    <span class="n">data</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="c">#[starttime:stoptime,1],</span>
                    <span class="n">fs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span>
                    <span class="n">hopsize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;hopsize&#39;</span><span class="p">]</span> <span class="p">,</span>
                    <span class="n">window</span><span class="o">=</span><span class="n">slf</span><span class="o">.</span><span class="n">sinebell</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;windowSizeInSamples&#39;</span><span class="p">]),</span>
                    <span class="n">nfft</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;NFT&#39;</span><span class="p">]</span> <span class="p">,</span>
                    <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">)</span>
                <span class="n">SXL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">XL</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mf">1e-8</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">XL</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">N</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">SXL</span> <span class="o">=</span> <span class="n">SXR</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfrepresentation</span> <span class="ow">in</span> <span class="n">knownTransfos</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">cqtkernel</span><span class="o">.</span><span class="n">atomHOP</span>
            <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">stop</span> <span class="o">=</span> <span class="p">(</span><span class="n">stop</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">cqtkernel</span><span class="o">.</span><span class="n">atomHOP</span> 
                <span class="n">stop</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;windowSizeInSamples&#39;</span><span class="p">]</span> <span class="c">#20130318</span>
            <span class="k">else</span><span class="p">:</span> 
                <span class="n">stop</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c"># also works for multi channel data:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">computeTransform</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">computeTransform</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
            <span class="n">SXR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">transfo</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="mi">10</span> <span class="o">**</span> <span class="o">-</span><span class="mi">8</span><span class="p">)</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">transfo</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">computeTransform</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">SXL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">transfo</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="mi">10</span> <span class="o">**</span> <span class="o">-</span><span class="mi">8</span><span class="p">)</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">transfo</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># hybt.computeHybrid(data=data)</span>
                <span class="n">SXL</span> <span class="o">=</span> <span class="n">SXR</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Transform </span><span class="si">%s</span><span class="s"> not fully implemented&quot;</span>
                                      <span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">tfrepresentation</span><span class="p">)</span>
        
        <span class="c">#XL = XL[:,start:stop]</span>
        <span class="k">del</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">SXR</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">return</span> <span class="n">SXR</span><span class="p">,</span> <span class="n">SXL</span>
    
    <span class="k">def</span> <span class="nf">estimSIMMParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="c">## section to estimate the melody, on monophonic algo:</span>
        <span class="n">SX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">computeMonoX</span><span class="p">()</span>
        <span class="c"># First round of parameter estimation:</span>
        <span class="k">print</span> <span class="s">&quot;    Estimating IMM parameters, on mean of channels, with&quot;</span><span class="p">,</span><span class="n">R</span><span class="p">,</span>\
              <span class="s">&quot;</span><span class="se">\n</span><span class="s">    accompaniment components.&quot;</span>
        <span class="n">HGAMMA</span><span class="p">,</span> <span class="n">HPHI</span><span class="p">,</span> <span class="n">HF0</span><span class="p">,</span> <span class="n">HM</span><span class="p">,</span> <span class="n">WM</span><span class="p">,</span> <span class="n">recoError1</span> <span class="o">=</span> <span class="n">SIMM</span><span class="o">.</span><span class="n">SIMM</span><span class="p">(</span>
            <span class="c"># the data to be fitted to:</span>
            <span class="n">SX</span><span class="p">,</span>
            <span class="c"># the basis matrices for the spectral combs</span>
            <span class="n">WF0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;WF0&#39;</span><span class="p">],</span>
            <span class="c"># and for the elementary filters:</span>
            <span class="n">WGAMMA</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;WGAMMA&#39;</span><span class="p">],</span>
            <span class="c"># number of desired filters, accompaniment spectra:</span>
            <span class="n">numberOfFilters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;K&#39;</span><span class="p">],</span>
            <span class="n">numberOfAccompanimentSpectralShapes</span><span class="o">=</span><span class="n">R</span><span class="p">,</span><span class="c">#self.SIMMParams[&#39;R&#39;],</span>
            <span class="c"># putting only 2 elements in accompaniment for a start...</span>
            <span class="c"># if any, initial amplitude matrices for </span>
            <span class="n">HGAMMA0</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">HPHI0</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="n">HF00</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="n">WM0</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">HM0</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="c"># Some more optional arguments, to control the &quot;convergence&quot;</span>
            <span class="c"># of the algo</span>
            <span class="n">numberOfIterations</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;niter&#39;</span><span class="p">],</span>
            <span class="n">updateRulePower</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span>
            <span class="n">stepNotes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;stepNotes&#39;</span><span class="p">],</span> 
            <span class="n">lambdaHF0</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">SX</span><span class="o">.</span><span class="n">max</span><span class="p">()),</span> <span class="n">alphaHF0</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">,</span>
            <span class="n">displayEvolution</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">displayEvolution</span><span class="p">,</span>
            <span class="n">imageCanvas</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">imageCanvas</span><span class="p">,</span>
            <span class="n">F0Table</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;F0Table&#39;</span><span class="p">],</span>
            <span class="n">chirpPerF0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;chirpPerF0&#39;</span><span class="p">])</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HGAMMA&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">HGAMMA</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HPHI&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">HPHI</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HF0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">HF0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HM&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">HM</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;WM&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">WM</span>
        <span class="k">del</span> <span class="n">SX</span>

<div class="viewcode-block" id="SeparateLeadProcess.estimHF0"><a class="viewcode-back" href="../../../reference/separateleadstereo.html#pyfasst.SeparateLeadStereo.SeparateLeadStereoTF.SeparateLeadProcess.estimHF0">[docs]</a>    <span class="k">def</span> <span class="nf">estimHF0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">maxFrames</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        estimating and storing only HF0 for the whole excerpt,</span>
<span class="sd">        with only </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">## section to estimate the melody, on monophonic algo:</span>
        <span class="c">#SX = self.computeMonoX() # too heavy, try to guess before hand instead</span>
        <span class="c">#totFrames = SX.shape[1]</span>
        <span class="n">totFrames</span><span class="p">,</span> <span class="n">nChunks</span><span class="p">,</span> <span class="n">maxFrames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkChunkSize</span><span class="p">(</span><span class="n">maxFrames</span><span class="p">)</span>
        <span class="c"># First round of parameter estimation:</span>
        <span class="k">print</span> <span class="s">&quot;    Estimating IMM parameters, on mean of channels, with&quot;</span><span class="p">,</span><span class="n">R</span><span class="p">,</span>\
              <span class="s">&quot;</span><span class="se">\n</span><span class="s">    accompaniment components.&quot;</span><span class="o">+</span>\
              <span class="s">&quot;    Nb of chunks: </span><span class="si">%d</span><span class="s">.&quot;</span> <span class="o">%</span><span class="n">nChunks</span>
        <span class="c"># del SX</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HF0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;NF0&#39;</span><span class="p">]</span> <span class="o">*</span> \
                                           <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;chirpPerF0&#39;</span><span class="p">],</span>
                                           <span class="n">totFrames</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nChunks</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;Chunk nb&quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;out of&quot;</span><span class="p">,</span> <span class="n">nChunks</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">n</span><span class="o">*</span><span class="n">maxFrames</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">((</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">maxFrames</span><span class="p">,</span> <span class="n">totFrames</span><span class="p">)</span>
            <span class="n">SX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">computeMonoX</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;initHF00&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;nnls&#39;</span><span class="p">:</span>
                <span class="c"># probably slower than running from random...</span>
                <span class="n">HF00</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;NF0&#39;</span><span class="p">]</span>
                                <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;chirpPerF0&#39;</span><span class="p">],</span>
                                <span class="n">stop</span><span class="o">-</span><span class="n">start</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">framenb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">stop</span><span class="o">-</span><span class="n">start</span><span class="p">):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                        <span class="k">print</span> <span class="s">&quot;frame&quot;</span><span class="p">,</span> <span class="n">framenb</span>
                    <span class="n">HF00</span><span class="p">[:,</span><span class="n">framenb</span><span class="p">],</span> <span class="n">_</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">nnls</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;WF0&#39;</span><span class="p">],</span>
                        <span class="n">SX</span><span class="p">[:,</span><span class="n">framenb</span><span class="p">])</span>
                <span class="n">HF00</span> <span class="o">+=</span> <span class="n">eps</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">HF00</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">HGAMMA</span><span class="p">,</span> <span class="n">HPHI</span><span class="p">,</span> <span class="n">HF0</span><span class="p">,</span> <span class="n">HM</span><span class="p">,</span> <span class="n">WM</span><span class="p">,</span> <span class="n">recoError1</span> <span class="o">=</span> <span class="n">SIMM</span><span class="o">.</span><span class="n">SIMM</span><span class="p">(</span>
                <span class="c"># the data to be fitted to:</span>
                <span class="n">SX</span><span class="p">,</span>
                <span class="c"># the basis matrices for the spectral combs</span>
                <span class="n">WF0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;WF0&#39;</span><span class="p">],</span>
                <span class="c"># and for the elementary filters:</span>
                <span class="n">WGAMMA</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;WGAMMA&#39;</span><span class="p">],</span>
                <span class="c"># number of desired filters, accompaniment spectra:</span>
                <span class="n">numberOfFilters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;K&#39;</span><span class="p">],</span>
                <span class="n">numberOfAccompanimentSpectralShapes</span><span class="o">=</span><span class="n">R</span><span class="p">,</span><span class="c">#self.SIMMParams[&#39;R&#39;],</span>
                <span class="c"># putting only 2 elements in accompaniment for a start...</span>
                <span class="c"># if any, initial amplitude matrices for </span>
                <span class="n">HGAMMA0</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">HPHI0</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                <span class="n">HF00</span><span class="o">=</span><span class="n">HF00</span><span class="p">,</span> 
                <span class="n">WM0</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">HM0</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                <span class="c"># Some more optional arguments, to control the &quot;convergence&quot;</span>
                <span class="c"># of the algo</span>
                <span class="n">numberOfIterations</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;niter&#39;</span><span class="p">],</span>
                <span class="n">updateRulePower</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span>
                <span class="n">stepNotes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;stepNotes&#39;</span><span class="p">],</span> 
                <span class="n">lambdaHF0</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">SX</span><span class="o">.</span><span class="n">max</span><span class="p">()),</span> <span class="n">alphaHF0</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">,</span>
                <span class="n">displayEvolution</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">displayEvolution</span><span class="p">,</span>
                <span class="n">imageCanvas</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">imageCanvas</span><span class="p">,</span>
                <span class="n">F0Table</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;F0Table&#39;</span><span class="p">],</span>
                <span class="n">chirpPerF0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;chirpPerF0&#39;</span><span class="p">])</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfrepresentation</span> <span class="o">==</span> <span class="s">&#39;stft&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HF0&#39;</span><span class="p">][:,</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">HF0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfrepresentation</span> <span class="ow">in</span> <span class="n">knownTransfos</span><span class="p">:</span>
                <span class="c"># the first frame of interest in the CQT representation,</span>
                <span class="c"># for our purpose at least</span>
                <span class="n">startincqt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">time_stamps</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c"># and the last:</span>
                <span class="n">stopincqt</span> <span class="o">=</span> <span class="p">(</span><span class="n">startincqt</span>
                             <span class="o">+</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HF0&#39;</span><span class="p">][:,</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">HF0</span><span class="p">[:,</span><span class="n">startincqt</span><span class="p">:</span><span class="n">stopincqt</span><span class="p">]))</span>
            
            <span class="k">del</span> <span class="n">SX</span>
        
        <span class="n">F0Table</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;F0Table&#39;</span><span class="p">]</span>
        <span class="n">NF0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;NF0&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;chirpPerF0&#39;</span><span class="p">]</span>
        <span class="n">db</span> <span class="o">=</span> <span class="n">SIMM</span><span class="o">.</span><span class="n">db</span>
        <span class="n">imgYticks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">NF0</span><span class="o">/</span><span class="mi">5</span><span class="p">,</span> <span class="n">NF0</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">5</span><span class="p">))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">notesFreqs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">notesFreqs</span><span class="p">[</span><span class="s">&#39;A4&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">442</span>
        <span class="n">notesFreqs</span><span class="p">[</span><span class="s">&#39;A2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">notesFreqs</span><span class="p">[</span><span class="s">&#39;A4&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="mi">4</span>
        <span class="n">notesFreqs</span><span class="p">[</span><span class="s">&#39;A3&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">notesFreqs</span><span class="p">[</span><span class="s">&#39;A4&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">notesFreqs</span><span class="p">[</span><span class="s">&#39;A5&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">notesFreqs</span><span class="p">[</span><span class="s">&#39;A4&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="n">notesFreqs</span><span class="p">[</span><span class="s">&#39;A6&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">notesFreqs</span><span class="p">[</span><span class="s">&#39;A4&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">F0Table</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">):</span>
            <span class="n">imgYticklabels</span> <span class="o">=</span> <span class="n">imgYticks</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">imgYticklabels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">F0Table</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">imgYticks</span><span class="p">)</span><span class="o">/</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;chirpPerF0&#39;</span><span class="p">]</span>
                                              <span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">notesFreqs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">closestIndex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">F0Table</span><span class="o">-</span><span class="n">v</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="mi">12</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">F0Table</span><span class="p">[</span><span class="n">closestIndex</span><span class="p">])</span><span class="o">-</span>\
                          <span class="mi">12</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="o">&lt;</span> <span class="o">.</span><span class="mi">25</span><span class="p">:</span>
                    <span class="n">imgYticks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">closestIndex</span><span class="p">)</span>
                    <span class="n">imgYticklabels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">imageCanvas</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">imageCanvas</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">imageCanvas</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">db</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HF0&#39;</span><span class="p">]),</span>
                                       <span class="n">origin</span><span class="o">=</span><span class="s">&#39;lower&#39;</span><span class="p">,</span>
                                       <span class="n">cmap</span><span class="o">=</span><span class="s">&#39;jet&#39;</span><span class="p">,</span>
                                       <span class="n">aspect</span><span class="o">=</span><span class="s">&#39;auto&#39;</span><span class="p">,</span>
                                       <span class="n">interpolation</span><span class="o">=</span><span class="s">&#39;nearest&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">imageCanvas</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">get_images</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_clim</span><span class="p">(</span>\
                <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">db</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HF0&#39;</span><span class="p">]))</span><span class="o">-</span><span class="mi">100</span><span class="p">,</span>\
                <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">db</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HF0&#39;</span><span class="p">])))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">imageCanvas</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="n">imgYticks</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">imageCanvas</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">(</span><span class="n">imgYticklabels</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">imageCanvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
            <span class="c"># self.imageCanvas.updateGeometry()</span>
    </div>
<div class="viewcode-block" id="SeparateLeadProcess.computeChroma"><a class="viewcode-back" href="../../../reference/separateleadstereo.html#pyfasst.SeparateLeadStereo.SeparateLeadStereoTF.SeparateLeadProcess.computeChroma">[docs]</a>    <span class="k">def</span> <span class="nf">computeChroma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maxFrames</span><span class="o">=</span><span class="mi">3000</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the chroma matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;SIMMParams&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="s">&#39;HF0&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">estimHF0</span><span class="p">(</span><span class="n">maxFrames</span><span class="o">=</span><span class="n">maxFrames</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s">&quot;The parameters for the SIMM are not&quot;</span><span class="o">+</span>\
                                 <span class="s">&quot; well initialized&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;N&#39;</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Issues with the attributes, running again&quot;</span><span class="o">+</span>\
                          <span class="s">&quot; the estimation.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">estimHF0</span><span class="p">(</span><span class="n">maxFrames</span><span class="o">=</span><span class="n">maxFrames</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">chroma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">12</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;stepNotes&#39;</span><span class="p">],</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">computeNFrames</span><span class="p">()])</span><span class="c">#self.N])</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;stepNotes&#39;</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">chroma</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HF0&#39;</span><span class="p">][</span>\
                <span class="n">n</span><span class="p">::(</span><span class="mi">12</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;stepNotes&#39;</span><span class="p">])]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chroma</span> <span class="o">/=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chroma</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        </div>
<div class="viewcode-block" id="SeparateLeadProcess.determineTuning"><a class="viewcode-back" href="../../../reference/separateleadstereo.html#pyfasst.SeparateLeadStereo.SeparateLeadStereoTF.SeparateLeadProcess.determineTuning">[docs]</a>    <span class="k">def</span> <span class="nf">determineTuning</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determine Tuning by checking the peaks corresponding</span>
<span class="sd">        to all possible patterns</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;chroma&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">computeChroma</span><span class="p">()</span>
            
        <span class="n">chromaSummary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chroma</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="n">patterns</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">patterns</span><span class="p">[</span><span class="s">&#39;minorHarmoPattern&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span>
        <span class="n">patterns</span><span class="p">[</span><span class="s">&#39;minorMelodPattern&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">11</span><span class="p">])</span>
        <span class="n">patterns</span><span class="p">[</span><span class="s">&#39;majorPattern&#39;</span><span class="p">]</span>      <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">11</span><span class="p">])</span>
        <span class="n">patterns</span><span class="p">[</span><span class="s">&#39;andalusPattern&#39;</span><span class="p">]</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">11</span><span class="p">])</span>
        
        <span class="n">nbPattern</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">patterns</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">nbTunings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;stepNotes&#39;</span><span class="p">]</span>
        <span class="n">nbKey</span> <span class="o">=</span> <span class="mi">12</span>
        <span class="n">scoresPerTuning</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nbPattern</span><span class="p">,</span> <span class="n">nbTunings</span><span class="o">*</span><span class="n">nbKey</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">ntun</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbTunings</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">nk</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbKey</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">npatt</span><span class="p">,</span> <span class="n">pattern</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">patterns</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                    <span class="n">scoresPerTuning</span><span class="p">[</span><span class="n">npatt</span><span class="p">,</span> <span class="n">ntun</span><span class="o">+</span><span class="n">nk</span><span class="o">*</span><span class="n">nbTunings</span><span class="p">]</span> <span class="o">=</span> \
                        <span class="n">chromaSummary</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">((</span><span class="n">patterns</span><span class="p">[</span><span class="n">pattern</span><span class="p">]</span><span class="o">+</span><span class="n">nk</span><span class="p">)</span><span class="o">*</span>\
                                             <span class="n">nbTunings</span><span class="o">+</span>\
                                             <span class="n">ntun</span><span class="p">,</span> <span class="n">chromaSummary</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">bestTuning</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">scoresPerTuning</span><span class="p">)</span>
        <span class="n">bestPattern</span> <span class="o">=</span> <span class="n">bestTuning</span> <span class="o">/</span> <span class="p">(</span><span class="n">nbTunings</span> <span class="o">*</span> <span class="n">nbKey</span><span class="p">)</span>
        <span class="n">bestTuning</span> <span class="o">=</span> <span class="n">bestTuning</span> <span class="o">-</span> <span class="n">bestPattern</span> <span class="o">*</span> <span class="p">(</span><span class="n">nbTunings</span> <span class="o">*</span> <span class="n">nbKey</span><span class="p">)</span>
        <span class="n">bestKey</span> <span class="o">=</span> <span class="n">bestTuning</span> <span class="o">/</span> <span class="n">nbTunings</span>
        <span class="n">bestTuning</span> <span class="o">=</span> <span class="n">bestTuning</span> <span class="o">-</span> <span class="n">bestKey</span> <span class="o">*</span> <span class="n">nbTunings</span> 
        <span class="k">return</span> <span class="n">scoresPerTuning</span><span class="p">,</span> <span class="n">bestTuning</span><span class="p">,</span> \
               <span class="n">bestKey</span><span class="p">,</span> <span class="n">patterns</span><span class="o">.</span><span class="n">keys</span><span class="p">()[</span><span class="n">bestPattern</span><span class="p">]</span>
    </div>
<div class="viewcode-block" id="SeparateLeadProcess.automaticMelodyAndSeparation"><a class="viewcode-back" href="../../../reference/separateleadstereo.html#pyfasst.SeparateLeadStereo.SeparateLeadStereoTF.SeparateLeadProcess.automaticMelodyAndSeparation">[docs]</a>    <span class="k">def</span> <span class="nf">automaticMelodyAndSeparation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fully automated estimation of melody and separation of signals.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;This function does not work well with framed &quot;</span> <span class="o">+</span> 
                            <span class="s">&quot;estimation.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">runViterbi</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initiateHF0WithIndexBestPath</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">estimStereoSIMMParams</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">writeSeparatedSignals</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">estimStereoSUIMMParams</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">writeSeparatedSignalsWithUnvoice</span><span class="p">()</span>
    </div>
<div class="viewcode-block" id="SeparateLeadProcess.autoMelSepAndWrite"><a class="viewcode-back" href="../../../reference/separateleadstereo.html#pyfasst.SeparateLeadStereo.SeparateLeadStereoTF.SeparateLeadProcess.autoMelSepAndWrite">[docs]</a>    <span class="k">def</span> <span class="nf">autoMelSepAndWrite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maxFrames</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fully automated estimation of melody and separation of signals.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">estimHF0</span><span class="p">(</span><span class="n">maxFrames</span><span class="o">=</span><span class="n">maxFrames</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">runViterbi</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initiateHF0WithIndexBestPath</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">estimStereoSIMMParamsWriteSeps</span><span class="p">(</span><span class="n">maxFrames</span><span class="o">=</span><span class="n">maxFrames</span><span class="p">)</span>
    </div>
    <span class="k">def</span> <span class="nf">runViterbi</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="s">&#39;HF0&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s">&quot;HF0 has probably not been estimated yet.&quot;</span><span class="p">)</span>
        <span class="c">##SX = self.computeMonoX() # useless here?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">computeNFrames</span><span class="p">()</span> <span class="c"># just to be sure self.N is total nb of frames</span>
        
        <span class="c"># Viterbi decoding to estimate the predominant fundamental</span>
        <span class="c"># frequency line</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">NF0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;NF0&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;chirpPerF0&#39;</span><span class="p">]</span>
        
        <span class="c"># only considering the desired range of </span>
        <span class="n">nmaxF0</span> <span class="o">=</span> <span class="n">NF0</span>
        <span class="n">nminF0</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c"># just so that it s easier to manipulate:</span>
        <span class="n">minF0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;minF0&#39;</span><span class="p">]</span>
        <span class="n">maxF0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;maxF0&#39;</span><span class="p">]</span>
        <span class="n">minF0search</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trackingParams</span><span class="p">[</span><span class="s">&#39;minF0search&#39;</span><span class="p">]</span>
        <span class="n">maxF0search</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trackingParams</span><span class="p">[</span><span class="s">&#39;maxF0search&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">minF0search</span> <span class="o">&gt;</span> <span class="n">minF0</span> <span class="ow">and</span> <span class="n">minF0search</span> <span class="o">&lt;</span> <span class="n">maxF0</span><span class="p">:</span>
            <span class="n">nminF0</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;F0Table&#39;</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">minF0search</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;chirpPerF0&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">maxF0search</span> <span class="o">&gt;</span> <span class="n">minF0</span> <span class="ow">and</span> <span class="n">maxF0search</span> <span class="o">&lt;</span> <span class="n">maxF0</span> <span class="ow">and</span> \
               <span class="n">maxF0search</span> <span class="o">&gt;</span> <span class="n">minF0search</span><span class="p">:</span>
            <span class="n">nmaxF0</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;F0Table&#39;</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">maxF0search</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;chirpPerF0&#39;</span><span class="p">])</span>
            
        <span class="n">NF0</span> <span class="o">=</span> <span class="n">nmaxF0</span> <span class="o">-</span> <span class="n">nminF0</span>
        <span class="k">print</span> <span class="n">nminF0</span><span class="p">,</span> <span class="n">nmaxF0</span> <span class="c">#DEBUG</span>
        
        <span class="c"># filling the transitions probabilities</span>
        <span class="n">transitions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">NF0</span><span class="p">)</span><span class="o">/</span>\
                                       <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;stepNotes&#39;</span><span class="p">])</span> <span class="o">*</span> \
                             <span class="n">scale</span><span class="p">)</span>
        <span class="n">cutoffnote</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;stepNotes&#39;</span><span class="p">]</span>
        <span class="n">cutoffnote</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">NF0</span><span class="p">,</span> <span class="n">cutoffnote</span><span class="p">)</span>
        <span class="n">transitions</span><span class="p">[</span><span class="n">cutoffnote</span><span class="p">:]</span> <span class="o">=</span> <span class="n">transitions</span><span class="p">[</span><span class="n">cutoffnote</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">transitionMatrixF0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">NF0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">NF0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="c"># toeplitz matrix</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">NF0</span><span class="p">)</span>
        <span class="n">transitionMatrixF0</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">NF0</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">NF0</span><span class="p">]</span> <span class="o">=</span> \
            <span class="n">transitions</span><span class="p">[</span>\
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">NF0</span><span class="p">),</span> <span class="n">b</span><span class="p">)</span> \
                                <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">NF0</span><span class="p">))),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)]</span>
        <span class="n">pf_0</span> <span class="o">=</span> <span class="n">transitions</span><span class="p">[</span><span class="n">cutoffnote</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">90</span><span class="p">)</span>
        <span class="n">p0_0</span> <span class="o">=</span> <span class="n">transitions</span><span class="p">[</span><span class="n">cutoffnote</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">100</span><span class="p">)</span>
        <span class="n">p0_f</span> <span class="o">=</span> <span class="n">transitions</span><span class="p">[</span><span class="n">cutoffnote</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">80</span><span class="p">)</span>
        <span class="n">transitionMatrixF0</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">NF0</span><span class="p">,</span> <span class="n">NF0</span><span class="p">]</span> <span class="o">=</span> <span class="n">pf_0</span>
        <span class="n">transitionMatrixF0</span><span class="p">[</span><span class="n">NF0</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">NF0</span><span class="p">]</span> <span class="o">=</span> <span class="n">p0_f</span>
        <span class="n">transitionMatrixF0</span><span class="p">[</span><span class="n">NF0</span><span class="p">,</span> <span class="n">NF0</span><span class="p">]</span> <span class="o">=</span> <span class="n">p0_0</span>
        
        <span class="n">sumTransitionMatrixF0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">transitionMatrixF0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">transitionMatrixF0</span> <span class="o">=</span> <span class="n">transitionMatrixF0</span> \
                             <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">sumTransitionMatrixF0</span><span class="p">,</span> \
                                        <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">NF0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        
        <span class="n">priorProbabilities</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">NF0</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="n">NF0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        
        <span class="n">logHF0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">NF0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">])</span>
        <span class="n">normHF0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HF0&#39;</span><span class="p">][</span><span class="n">nminF0</span><span class="p">:</span><span class="n">nmaxF0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="n">logHF0</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">NF0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HF0&#39;</span><span class="p">][</span><span class="n">nminF0</span><span class="p">:</span><span class="n">nmaxF0</span><span class="p">])</span>
        <span class="n">logHF0</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">NF0</span><span class="p">,</span> <span class="n">normHF0</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">logHF0</span><span class="p">[</span><span class="n">logHF0</span><span class="o">&gt;-</span><span class="n">np</span><span class="o">.</span><span class="n">Inf</span><span class="p">])</span>
        <span class="n">logHF0</span><span class="p">[</span><span class="n">NF0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">logHF0</span><span class="p">[</span><span class="n">logHF0</span><span class="o">&gt;-</span><span class="n">np</span><span class="o">.</span><span class="n">Inf</span><span class="p">]),</span><span class="o">-</span><span class="mi">100</span><span class="p">)</span>
        <span class="c"># free all what s not needed anymore:</span>
        <span class="k">del</span> <span class="n">normHF0</span><span class="p">,</span> <span class="n">transitions</span><span class="p">,</span> <span class="n">b</span>
        
        <span class="k">print</span> <span class="s">&quot;Running Viterbi algorithm to track the melody, &quot;</span> <span class="o">+</span> \
              <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot; frames.&quot;</span>
        <span class="n">indexBestPath</span> <span class="o">=</span> <span class="n">viterbiTrackingArray</span><span class="p">(</span><span class="n">NF0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span>\
            <span class="n">logHF0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">priorProbabilities</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">transitionMatrixF0</span><span class="p">),</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">indexBestPath</span> <span class="o">+=</span> <span class="n">nminF0</span>
        <span class="k">print</span> <span class="s">&quot;Viterbi algorithm done...&quot;</span>
        
        <span class="c"># drawing this as a line is actually a bit confusing, on the image</span>
        <span class="c">#     TODO: think of a better representation (is contour good enough?)</span>
        <span class="c">##if self.displayEvolution and not(self.imageCanvas is None):</span>
        <span class="c">##    self.imageCanvas.ax.plot(indexBestPath, &#39;-b&#39;)</span>
        <span class="c">##    self.imageCanvas.ax.axis(&#39;tight&#39;)</span>
        <span class="c">##    self.imageCanvas.draw()</span>
        
        <span class="k">del</span> <span class="n">logHF0</span>
        
        <span class="c"># detection of silences:</span>
        <span class="k">if</span> <span class="s">&#39;HPHI&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span> <span class="ow">and</span> <span class="bp">False</span><span class="p">:</span> <span class="c"># in case not estimated</span>
            <span class="c"># TODO: this is broken, when nchunks &gt; 1</span>
            <span class="c">#     needs a fix, maybe keeping relative energy as</span>
            <span class="c">#     attribute, instead of computing it here.</span>
            <span class="n">chirpPerF0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;chirpPerF0&#39;</span><span class="p">]</span>
            <span class="n">stepNotes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;stepNotes&#39;</span><span class="p">]</span>
            <span class="n">HF00</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">NF0</span> <span class="o">*</span> <span class="n">chirpPerF0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">])</span>
            <span class="n">scopeAllowedHF0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scopeAllowedHF0</span><span class="c"># 4.0 / 1.0 # 2.0 / 1.0</span>
            <span class="n">dim1index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>\
                <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>\
                    <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span>\
                        <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">chirpPerF0</span> <span class="o">*</span> <span class="n">indexBestPath</span><span class="p">,</span>
                                 <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">chirpPerF0</span> \
                                         <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> \
                                            <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">stepNotes</span> <span class="o">/</span> \
                                                       <span class="n">scopeAllowedHF0</span><span class="p">)</span> \
                                            <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> \
                        <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">),</span>
                                   <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">chirpPerF0</span> \
                                             <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">stepNotes</span> <span class="o">/</span> \
                                                        <span class="n">scopeAllowedHF0</span><span class="p">),</span>
                                             <span class="n">chirpPerF0</span> \
                                             <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">stepNotes</span> <span class="o">/</span> \
                                                         <span class="n">scopeAllowedHF0</span><span class="p">)</span> \
                                                <span class="o">+</span> <span class="mi">1</span><span class="p">))),</span>
                        <span class="n">chirpPerF0</span> <span class="o">*</span> <span class="n">NF0</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
                    <span class="mi">0</span><span class="p">),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">*</span> <span class="n">chirpPerF0</span> \
                                   <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">stepNotes</span><span class="o">/</span><span class="n">scopeAllowedHF0</span><span class="p">)</span>\
                                      <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">dim2index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">),</span>
                                 <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">chirpPerF0</span> \
                                         <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">stepNotes</span> \
                                                         <span class="o">/</span><span class="n">scopeAllowedHF0</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span>\
                                         <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>\
                                 <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">*</span> <span class="n">chirpPerF0</span> \
                                           <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">stepNotes</span> \
                                                           <span class="o">/</span> <span class="n">scopeAllowedHF0</span><span class="p">)</span> \
                                              <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">HF00</span><span class="p">[</span><span class="n">dim1index</span><span class="p">,</span> <span class="n">dim2index</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HF0&#39;</span><span class="p">][</span><span class="n">dim1index</span><span class="p">,</span>
                                                                <span class="n">dim2index</span><span class="p">]</span>
            
            <span class="n">HF00</span><span class="p">[:,</span> <span class="n">indexBestPath</span> <span class="o">==</span> <span class="p">(</span><span class="n">NF0</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">HF00</span><span class="p">[:,</span> <span class="n">indexBestPath</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            
            <span class="n">thres_energy</span> <span class="o">=</span> <span class="mf">0.000584</span>
            <span class="n">SF0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;WF0&#39;</span><span class="p">],</span> <span class="n">HF00</span><span class="p">),</span> <span class="n">eps</span><span class="p">)</span>
            <span class="n">SPHI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;WGAMMA&#39;</span><span class="p">],</span> \
                                     <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HGAMMA&#39;</span><span class="p">],</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HPHI&#39;</span><span class="p">])),</span> <span class="n">eps</span><span class="p">)</span>
            <span class="n">SM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;WM&#39;</span><span class="p">],</span> \
                                   <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HM&#39;</span><span class="p">]),</span> <span class="n">eps</span><span class="p">)</span>
            <span class="n">hatSX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">SPHI</span> <span class="o">*</span> <span class="n">SF0</span> <span class="o">+</span> <span class="n">SM</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
            <span class="n">SX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">computeMonoX</span><span class="p">()</span>
            <span class="n">energyMel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((((</span><span class="n">SPHI</span> <span class="o">*</span> <span class="n">SF0</span><span class="p">)</span><span class="o">/</span><span class="n">hatSX</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">SX</span><span class="p">),</span>
                               <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">energyMelSorted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">energyMel</span><span class="p">)</span>
            <span class="n">energyMelCumul</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">energyMelSorted</span><span class="p">)</span>
            <span class="n">energyMelCumulNorm</span> <span class="o">=</span> <span class="n">energyMelCumul</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="n">energyMelCumul</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">eps</span><span class="p">)</span>
            <span class="c"># normalized to the maximum of energy:</span>
            <span class="c"># expressed in 0.01 times the percentage</span>
            <span class="n">ind_999</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">energyMelCumulNorm</span><span class="o">&gt;</span><span class="n">thres_energy</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ind_999</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">ind_999</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>
                
            <span class="n">melNotPresent</span> <span class="o">=</span> <span class="p">(</span><span class="n">energyMel</span> <span class="o">&lt;=</span> <span class="n">energyMelCumulNorm</span><span class="p">[</span><span class="n">ind_999</span><span class="p">])</span>
            <span class="n">indexBestPath</span><span class="p">[</span><span class="n">melNotPresent</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;    Not using energy threshold, since &quot;</span><span class="o">+</span>\
                      <span class="s">&quot;parameters were deleted.&quot;</span>
        
        <span class="n">freqMelody</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;F0Table&#39;</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">indexBestPath</span>
            <span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;chirpPerF0&#39;</span><span class="p">],</span>
            <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)]</span>
        <span class="n">freqMelody</span><span class="p">[</span><span class="n">indexBestPath</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">freqMelody</span><span class="p">[</span><span class="n">indexBestPath</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;pitch_output_file&#39;</span><span class="p">],</span>
                   <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span> <span class="o">*</span> \
                             <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;hopsize&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">),</span>
                             <span class="n">freqMelody</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">indexBestPath</span> <span class="o">=</span> <span class="n">indexBestPath</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">freqMelody</span> <span class="o">=</span> <span class="n">freqMelody</span>
    
    <span class="k">def</span> <span class="nf">initiateHF0WithIndexBestPath</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># Second round of parameter estimation, with specific</span>
        <span class="c"># initial HF00:</span>
        <span class="n">NF0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;NF0&#39;</span><span class="p">]</span>
        <span class="n">chirpPerF0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;chirpPerF0&#39;</span><span class="p">]</span>
        <span class="n">stepNotes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;stepNotes&#39;</span><span class="p">]</span>
        
        <span class="n">HF00</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">NF0</span> <span class="o">*</span> <span class="n">chirpPerF0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">])</span>
        
        <span class="n">scopeAllowedHF0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scopeAllowedHF0</span> <span class="c"># 2.0 / 1.0</span>
        
        <span class="c"># indexes for HF00:</span>
        <span class="c"># TODO: reprogram this with a &#39;where&#39;?...</span>
        <span class="n">dim1index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>\
            <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>\
            <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span>\
                <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indexBestPath</span><span class="p">,</span><span class="c"># * chirpPerF0 #20130610 DJL???</span>
                         <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">chirpPerF0</span> \
                                 <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> \
                                    <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">stepNotes</span> <span class="o">/</span> <span class="n">scopeAllowedHF0</span><span class="p">)</span> \
                                    <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> \
                <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">),</span>
                           <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">chirpPerF0</span> \
                                     <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">stepNotes</span> <span class="o">/</span> <span class="n">scopeAllowedHF0</span><span class="p">),</span>
                                     <span class="n">chirpPerF0</span> \
                                     <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">stepNotes</span> <span class="o">/</span> <span class="n">scopeAllowedHF0</span><span class="p">)</span> \
                                        <span class="o">+</span> <span class="mi">1</span><span class="p">))),</span>
                <span class="n">chirpPerF0</span> <span class="o">*</span> <span class="n">NF0</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
            <span class="mi">0</span><span class="p">),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">dim1index</span> <span class="o">=</span> <span class="n">dim1index</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indexBestPath</span><span class="o">!=</span><span class="mi">0</span><span class="p">,:]</span>
        <span class="n">dim1index</span> <span class="o">=</span> <span class="n">dim1index</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">dim1index</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        
        <span class="n">dim2index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">),</span>
                             <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">chirpPerF0</span> \
                                     <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">stepNotes</span> \
                                                     <span class="o">/</span> <span class="n">scopeAllowedHF0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> \
                                     <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>\
                             <span class="p">)</span>
        <span class="n">dim2index</span> <span class="o">=</span> <span class="n">dim2index</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indexBestPath</span><span class="o">!=</span><span class="mi">0</span><span class="p">,:]</span>
        <span class="n">dim2index</span> <span class="o">=</span> <span class="n">dim2index</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">dim2index</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        
        <span class="n">HF00</span><span class="p">[</span><span class="n">dim1index</span><span class="p">,</span> <span class="n">dim2index</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HF0&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        
        <span class="n">HF00</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexBestPath</span> <span class="o">==</span> <span class="p">(</span><span class="n">NF0</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">HF00</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexBestPath</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HF00&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">HF00</span>
    
<div class="viewcode-block" id="SeparateLeadProcess.estimStereoSIMMParamsWriteSeps"><a class="viewcode-back" href="../../../reference/separateleadstereo.html#pyfasst.SeparateLeadStereo.SeparateLeadStereoTF.SeparateLeadProcess.estimStereoSIMMParamsWriteSeps">[docs]</a>    <span class="k">def</span> <span class="nf">estimStereoSIMMParamsWriteSeps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maxFrames</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimates the parameters little by little, by chunks,</span>
<span class="sd">        and sequentially writes the signals. In the end, concatenates all these</span>
<span class="sd">        separated signals into the desired output files</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#SX = self.computeMonoX()</span>
        <span class="n">totFrames</span><span class="p">,</span> <span class="n">nChunks</span><span class="p">,</span> <span class="n">maxFrames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkChunkSize</span><span class="p">(</span><span class="n">maxFrames</span><span class="p">)</span>
        <span class="c"># del SX</span>
        
        <span class="c"># First round of parameter estimation:</span>
        <span class="k">print</span> <span class="s">&quot;    Estimating IMM parameters, on stereo channels, with&quot;</span><span class="p">,</span>\
              <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;R&#39;</span><span class="p">],</span>\
              <span class="s">&quot;</span><span class="se">\n</span><span class="s">    accompaniment components.&quot;</span><span class="o">+</span>\
              <span class="s">&quot;    Nb of chunks: </span><span class="si">%d</span><span class="s">.&quot;</span> <span class="o">%</span><span class="n">nChunks</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HGAMMA&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nChunks</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;Chunk nb&quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;out of&quot;</span><span class="p">,</span> <span class="n">nChunks</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">n</span><span class="o">*</span><span class="n">maxFrames</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">((</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">maxFrames</span><span class="p">,</span> <span class="n">totFrames</span><span class="p">)</span>
            <span class="c"># computing only the power spectra for each channel:</span>
            <span class="c">#    - not storing the complex spectra -</span>
            <span class="n">SXR</span><span class="p">,</span> <span class="n">SXL</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">computeStereoSX</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">)</span>
            <span class="n">HF00</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;NF0&#39;</span><span class="p">]</span>
                             <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;chirpPerF0&#39;</span><span class="p">],</span>
                             <span class="n">SXR</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfrepresentation</span> <span class="o">==</span> <span class="s">&#39;stft&#39;</span><span class="p">:</span>
                <span class="n">startinHF00</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">stopinHF00</span> <span class="o">=</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfrepresentation</span> <span class="ow">in</span> <span class="n">knownTransfos</span><span class="p">:</span>
                <span class="n">startinHF00</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">time_stamps</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">stopinHF00</span> <span class="o">=</span> <span class="n">startinHF00</span> <span class="o">+</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tfrepresentation</span>
                                     <span class="o">+</span> <span class="s">&quot; not fully implemented.&quot;</span><span class="p">)</span>
            <span class="n">HF00</span><span class="p">[:,</span><span class="n">startinHF00</span><span class="p">:</span><span class="n">stopinHF00</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HF00&#39;</span><span class="p">][:,</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">])</span>
            <span class="n">alphaR</span><span class="p">,</span> <span class="n">alphaL</span><span class="p">,</span> <span class="n">HGAMMA</span><span class="p">,</span> <span class="n">HPHI</span><span class="p">,</span> <span class="n">HF0</span><span class="p">,</span> \
                <span class="n">betaR</span><span class="p">,</span> <span class="n">betaL</span><span class="p">,</span> <span class="n">HM</span><span class="p">,</span> <span class="n">WM</span><span class="p">,</span> <span class="n">recoError2</span> <span class="o">=</span> <span class="n">SIMM</span><span class="o">.</span><span class="n">Stereo_SIMM</span><span class="p">(</span>
                <span class="c"># the data to be fitted to:</span>
                <span class="n">SXR</span><span class="p">,</span> <span class="n">SXL</span><span class="p">,</span>
                <span class="c"># the basis matrices for the spectral combs</span>
                <span class="n">WF0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;WF0&#39;</span><span class="p">],</span>
                <span class="c"># and for the elementary filters:</span>
                <span class="n">WGAMMA</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;WGAMMA&#39;</span><span class="p">],</span>
                <span class="c"># number of desired filters, accompaniment spectra:</span>
                <span class="n">numberOfFilters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;K&#39;</span><span class="p">],</span>
                <span class="n">numberOfAccompanimentSpectralShapes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;R&#39;</span><span class="p">],</span> 
                <span class="c"># if any, initial amplitude matrices for</span>
                <span class="n">HGAMMA0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HGAMMA&#39;</span><span class="p">],</span>
                <span class="n">HPHI0</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                <span class="n">HF00</span><span class="o">=</span><span class="n">HF00</span><span class="p">,</span>
                <span class="n">WM0</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">HM0</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                <span class="c"># Some more optional arguments, to control the &quot;convergence&quot;</span>
                <span class="c"># of the algo</span>
                <span class="n">numberOfIterations</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;niter&#39;</span><span class="p">],</span>
                <span class="n">updateRulePower</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                <span class="n">stepNotes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;stepNotes&#39;</span><span class="p">],</span>
                <span class="n">lambdaHF0</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">SXR</span><span class="o">.</span><span class="n">max</span><span class="p">()),</span> <span class="n">alphaHF0</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">,</span> <span class="n">displayEvolution</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HGAMMA&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">HGAMMA</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HPHI&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">HPHI</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HF0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">HF0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HM&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">HM</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;WM&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">WM</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;alphaR&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">alphaR</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;alphaL&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">alphaL</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;betaR&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">betaR</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;betaL&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">betaL</span>
            
            <span class="c"># keeping the estimated HF0 in memory:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HF00&#39;</span><span class="p">][:,</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">HF0</span><span class="p">[:,</span><span class="n">startinHF00</span><span class="p">:</span><span class="n">stopinHF00</span><span class="p">]))</span>
            
            
            <span class="k">del</span> <span class="n">SXR</span><span class="p">,</span> <span class="n">SXL</span><span class="p">,</span> <span class="n">HF00</span>
            
            <span class="c"># computing and storing the complex spectra</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">computeStereoX</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">)</span>
            
            <span class="c"># writing the separated signals as output wavfile with suffix</span>
            <span class="c"># equal to the chunk number</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">writeSeparatedSignals</span><span class="p">(</span><span class="n">suffix</span><span class="o">=</span><span class="s">&#39;</span><span class="si">%05d</span><span class="s">.wav&#39;</span><span class="o">%</span><span class="n">n</span><span class="p">)</span>
            
            <span class="c"># freeing memory</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">XR</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">XL</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">freeMemory</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HM&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HF0&#39;</span><span class="p">]</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HPHI&#39;</span><span class="p">]</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;alphaR&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;alphaL&#39;</span><span class="p">]</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;betaR&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;betaL&#39;</span><span class="p">]</span>
                                
        <span class="c"># Now concatenating the wav files</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">overlapAddChunks</span><span class="p">(</span>
            <span class="n">nChunks</span><span class="o">=</span><span class="n">nChunks</span><span class="p">,</span>
            <span class="n">suffixIsSUIMM</span><span class="o">=</span><span class="s">&#39;.wav&#39;</span><span class="p">)</span>
        </div>
    <span class="k">def</span> <span class="nf">overlapAddChunks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nChunks</span><span class="p">,</span>
                         <span class="n">suffixIsSUIMM</span><span class="o">=</span><span class="s">&#39;.wav&#39;</span><span class="p">):</span>
        <span class="c"># Now concatenating the wav files</span>
        <span class="n">wlen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;windowSizeInSamples&#39;</span><span class="p">]</span>
        <span class="n">offsetTF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;offsets&#39;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">tfrepresentation</span><span class="p">]</span>
        <span class="c"># overlap add on the chunks:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfrepresentation</span> <span class="o">==</span> <span class="s">&#39;stft&#39;</span><span class="p">:</span>
            <span class="n">hopsize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;hopsize&#39;</span><span class="p">]</span>
            <span class="n">overlapSamp</span> <span class="o">=</span> <span class="n">wlen</span> <span class="o">-</span> <span class="n">hopsize</span>
            <span class="c"># for stft, the overlap is taken into account at computation</span>
            <span class="c"># using rectangle synthesis function:</span>
            <span class="n">overlapFunc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">overlapSamp</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfrepresentation</span> <span class="ow">in</span> <span class="n">knownTransfos</span><span class="p">:</span>
            <span class="n">hopsize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">cqtkernel</span><span class="o">.</span><span class="n">atomHOP</span>
            <span class="c"># for hybridcqt, have to compensate the overlap procedure:</span>
            <span class="n">overlapSamp</span> <span class="o">=</span> <span class="n">wlen</span> <span class="o">-</span> <span class="n">hopsize</span>
            <span class="c"># using sinebell ** 2 for overlapping function</span>
            <span class="c"># (rectangle as analysis function for hybridcqt):</span>
            <span class="n">overlapFunc</span> <span class="o">=</span> <span class="n">slf</span><span class="o">.</span><span class="n">sinebell</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">overlapSamp</span><span class="p">)[</span><span class="n">overlapSamp</span><span class="p">:]</span><span class="o">**</span><span class="mi">2</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">3</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;[DEBUG] check that window adds to 1:&quot;</span><span class="p">,</span>
                <span class="k">print</span> <span class="n">overlapFunc</span> <span class="o">+</span> <span class="n">overlapFunc</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">nuDataLen</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">totFrames</span> <span class="o">*</span> <span class="n">hopsize</span>
            <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">wlen</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nuDataLen</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
        
        <span class="n">cumulframe</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c">##data = []</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nChunks</span><span class="p">):</span>
            <span class="n">suffix</span><span class="o">=</span><span class="s">&#39;</span><span class="si">%05d%s</span><span class="s">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">suffixIsSUIMM</span><span class="p">)</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;voc_output_file&#39;</span><span class="p">][:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="n">suffix</span>
            <span class="c"># data.append(wav.read(fname)[1])</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">datatmp</span> <span class="o">=</span> <span class="n">wav</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
            <span class="n">datatype</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">datatmp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">print</span> <span class="n">datatype</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">nChunks</span><span class="o">!=</span><span class="mi">1</span><span class="p">:</span>
                <span class="c"># weighing by the overlapping function</span>
                <span class="n">datatmp</span><span class="p">[</span><span class="o">-</span><span class="n">overlapSamp</span><span class="p">:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">datatype</span><span class="p">(</span>
                    <span class="n">datatmp</span><span class="p">[</span><span class="o">-</span><span class="n">overlapSamp</span><span class="p">:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span> <span class="n">overlapFunc</span><span class="p">)</span>
                <span class="n">datatmp</span><span class="p">[</span><span class="o">-</span><span class="n">overlapSamp</span><span class="p">:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">datatype</span><span class="p">(</span>
                    <span class="n">datatmp</span><span class="p">[</span><span class="o">-</span><span class="n">overlapSamp</span><span class="p">:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span> <span class="n">overlapFunc</span><span class="p">)</span>
                <span class="n">lendatatmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">datatmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">offsetTF</span><span class="p">)</span> <span class="c"># (datatmp.shape[0] - wlen/2)</span>
                <span class="n">data</span><span class="p">[:</span><span class="n">lendatatmp</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
                    <span class="n">datatmp</span><span class="p">[</span><span class="n">offsetTF</span><span class="p">:,</span> <span class="p">:])</span><span class="c"># datatmp[wlen/2:, :])</span>
                <span class="n">cumulframe</span> <span class="o">=</span> <span class="n">lendatatmp</span>
            <span class="k">elif</span> <span class="n">nChunks</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c"># weighing by the overlapping function</span>
                <span class="k">if</span> <span class="n">n</span><span class="o">!=</span><span class="n">nChunks</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">datatmp</span><span class="p">[</span><span class="o">-</span><span class="n">overlapSamp</span><span class="p">:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">datatype</span><span class="p">(</span>
                        <span class="n">datatmp</span><span class="p">[</span><span class="o">-</span><span class="n">overlapSamp</span><span class="p">:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">overlapFunc</span><span class="p">)</span>
                    <span class="n">datatmp</span><span class="p">[</span><span class="o">-</span><span class="n">overlapSamp</span><span class="p">:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">datatype</span><span class="p">(</span>
                        <span class="n">datatmp</span><span class="p">[</span><span class="o">-</span><span class="n">overlapSamp</span><span class="p">:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span> <span class="n">overlapFunc</span><span class="p">)</span>
                <span class="n">datatmp</span><span class="p">[:</span><span class="n">overlapSamp</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">datatype</span><span class="p">(</span>
                    <span class="n">datatmp</span><span class="p">[:</span><span class="n">overlapSamp</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">overlapFunc</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">datatmp</span><span class="p">[:</span><span class="n">overlapSamp</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">datatype</span><span class="p">(</span>
                    <span class="n">datatmp</span><span class="p">[:</span><span class="n">overlapSamp</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">overlapFunc</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">cumulframe</span> <span class="o">-</span> <span class="n">wlen</span> <span class="o">+</span> <span class="n">hopsize</span>
                <span class="n">lendatatmp</span> <span class="o">=</span> <span class="n">datatmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">stop</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">lendatatmp</span>
                <span class="n">data</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">datatmp</span>
                <span class="n">cumulframe</span> <span class="o">=</span> <span class="n">stop</span>
            <span class="k">else</span><span class="p">:</span> <span class="c"># n=0 and nChunks = 1:</span>
                <span class="n">lendatatmp</span> <span class="o">=</span> <span class="n">datatmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">offsetTF</span>
                <span class="n">data</span><span class="p">[:</span><span class="n">lendatatmp</span><span class="p">]</span> <span class="o">=</span> <span class="n">datatmp</span><span class="p">[</span><span class="n">offsetTF</span><span class="p">:,</span> <span class="p">:]</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="c"># data = np.vstack(data)</span>
        <span class="n">wav</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;voc_output_file&#39;</span><span class="p">][:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="n">suffixIsSUIMM</span><span class="p">,</span>
                  <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span>
                  <span class="n">data</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">lengthData</span><span class="p">,:])</span>
        
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nuDataLen</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
        <span class="c"># overlap add on the chunks:</span>
        <span class="n">cumulframe</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c">##data = []</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nChunks</span><span class="p">):</span>
            <span class="n">suffix</span><span class="o">=</span><span class="s">&#39;</span><span class="si">%05d%s</span><span class="s">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">suffixIsSUIMM</span><span class="p">)</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;mus_output_file&#39;</span><span class="p">][:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="n">suffix</span>
            <span class="c">#data.append(wav.read(fname)[1])</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">datatmp</span> <span class="o">=</span> <span class="n">wav</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
            <span class="n">datatype</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">datatmp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">nChunks</span><span class="o">!=</span><span class="mi">1</span><span class="p">:</span>
                <span class="c"># weighing by the overlapping function</span>
                <span class="n">datatmp</span><span class="p">[</span><span class="o">-</span><span class="n">overlapSamp</span><span class="p">:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">datatype</span><span class="p">(</span>
                    <span class="n">datatmp</span><span class="p">[</span><span class="o">-</span><span class="n">overlapSamp</span><span class="p">:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span> <span class="n">overlapFunc</span><span class="p">)</span>
                <span class="n">datatmp</span><span class="p">[</span><span class="o">-</span><span class="n">overlapSamp</span><span class="p">:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">datatype</span><span class="p">(</span>
                    <span class="n">datatmp</span><span class="p">[</span><span class="o">-</span><span class="n">overlapSamp</span><span class="p">:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span> <span class="n">overlapFunc</span><span class="p">)</span>
                <span class="n">lendatatmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">datatmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">offsetTF</span><span class="p">)</span> <span class="c"># (datatmp.shape[0] - wlen/2)</span>
                <span class="n">data</span><span class="p">[:</span><span class="n">lendatatmp</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
                    <span class="n">datatmp</span><span class="p">[</span><span class="n">offsetTF</span><span class="p">:,</span> <span class="p">:])</span><span class="c"># datatmp[wlen/2:, :])</span>
                <span class="n">cumulframe</span> <span class="o">=</span> <span class="n">lendatatmp</span>
            <span class="k">elif</span> <span class="n">nChunks</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c"># weighing by the overlapping function</span>
                <span class="k">if</span> <span class="n">n</span><span class="o">!=</span><span class="n">nChunks</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">datatmp</span><span class="p">[</span><span class="o">-</span><span class="n">overlapSamp</span><span class="p">:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">datatype</span><span class="p">(</span>
                        <span class="n">datatmp</span><span class="p">[</span><span class="o">-</span><span class="n">overlapSamp</span><span class="p">:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">overlapFunc</span><span class="p">)</span>
                    <span class="n">datatmp</span><span class="p">[</span><span class="o">-</span><span class="n">overlapSamp</span><span class="p">:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">datatype</span><span class="p">(</span>
                        <span class="n">datatmp</span><span class="p">[</span><span class="o">-</span><span class="n">overlapSamp</span><span class="p">:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">overlapFunc</span><span class="p">)</span>
                <span class="n">datatmp</span><span class="p">[:</span><span class="n">overlapSamp</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">datatype</span><span class="p">(</span>
                    <span class="n">datatmp</span><span class="p">[:</span><span class="n">overlapSamp</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">overlapFunc</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">datatmp</span><span class="p">[:</span><span class="n">overlapSamp</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">datatype</span><span class="p">(</span>
                    <span class="n">datatmp</span><span class="p">[:</span><span class="n">overlapSamp</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">overlapFunc</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">cumulframe</span> <span class="o">-</span> <span class="n">wlen</span> <span class="o">+</span> <span class="n">hopsize</span>
                <span class="n">lendatatmp</span> <span class="o">=</span> <span class="n">datatmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">stop</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">lendatatmp</span>
                <span class="n">data</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">datatmp</span>
                <span class="n">cumulframe</span> <span class="o">=</span> <span class="n">stop</span>
            <span class="k">else</span><span class="p">:</span> <span class="c"># n=0 and nChunks = 1:</span>
                <span class="n">lendatatmp</span> <span class="o">=</span> <span class="n">datatmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">offsetTF</span>
                <span class="n">data</span><span class="p">[:</span><span class="n">lendatatmp</span><span class="p">]</span> <span class="o">=</span> <span class="n">datatmp</span><span class="p">[</span><span class="n">offsetTF</span><span class="p">:,</span> <span class="p">:]</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="c">#data = np.vstack(data)</span>
        <span class="n">wav</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;mus_output_file&#39;</span><span class="p">][:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="n">suffixIsSUIMM</span><span class="p">,</span>
                  <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span>
                  <span class="n">data</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">lengthData</span><span class="p">,:])</span>
    
<div class="viewcode-block" id="SeparateLeadProcess.estimStereoSUIMMParamsWriteSeps"><a class="viewcode-back" href="../../../reference/separateleadstereo.html#pyfasst.SeparateLeadStereo.SeparateLeadStereoTF.SeparateLeadProcess.estimStereoSUIMMParamsWriteSeps">[docs]</a>    <span class="k">def</span> <span class="nf">estimStereoSUIMMParamsWriteSeps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maxFrames</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;same as estimStereoSIMMParamsWriteSeps, but adds the unvoiced</span>
<span class="sd">        element in HF0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">totFrames</span><span class="p">,</span> <span class="n">nChunks</span><span class="p">,</span> <span class="n">maxFrames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkChunkSize</span><span class="p">(</span><span class="n">maxFrames</span><span class="p">)</span>
        <span class="k">print</span> <span class="s">&quot;    Estimating IMM parameters, on stereo channels, with&quot;</span><span class="p">,</span>\
              <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;R&#39;</span><span class="p">],</span>\
              <span class="s">&quot;</span><span class="se">\n</span><span class="s">    accompaniment components.&quot;</span><span class="o">+</span>\
              <span class="s">&quot;    Nb of chunks: </span><span class="si">%d</span><span class="s">.&quot;</span> <span class="o">%</span><span class="n">nChunks</span>
        
        <span class="n">WUF0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;WF0&#39;</span><span class="p">],</span>
                          <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;WF0&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">])])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;WUF0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">WUF0</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nChunks</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;Chunk nb&quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;out of&quot;</span><span class="p">,</span> <span class="n">nChunks</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">n</span><span class="o">*</span><span class="n">maxFrames</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">((</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">maxFrames</span><span class="p">,</span> <span class="n">totFrames</span><span class="p">)</span>
            <span class="n">SXR</span><span class="p">,</span> <span class="n">SXL</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">computeStereoSX</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">)</span>
            <span class="n">HUF0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;NF0&#39;</span><span class="p">]</span>
                             <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;chirpPerF0&#39;</span><span class="p">]</span>
                             <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                             <span class="n">SXR</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfrepresentation</span> <span class="o">==</span> <span class="s">&#39;stft&#39;</span><span class="p">:</span>
                <span class="n">startinHF00</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">stopinHF00</span> <span class="o">=</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfrepresentation</span> <span class="ow">in</span> <span class="n">knownTransfos</span><span class="p">:</span>
                <span class="n">startinHF00</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">time_stamps</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">stopinHF00</span> <span class="o">=</span> <span class="n">startinHF00</span> <span class="o">+</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tfrepresentation</span>
                                     <span class="o">+</span> <span class="s">&quot; not fully implemented.&quot;</span><span class="p">)</span>
            <span class="n">HUF0</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">startinHF00</span><span class="p">:</span><span class="n">stopinHF00</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HF00&#39;</span><span class="p">][:,</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">])</span>
            <span class="n">HUF0</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">alphaR</span><span class="p">,</span> <span class="n">alphaL</span><span class="p">,</span> <span class="n">HGAMMA</span><span class="p">,</span> <span class="n">HPHI</span><span class="p">,</span> <span class="n">HF0</span><span class="p">,</span> \
                <span class="n">betaR</span><span class="p">,</span> <span class="n">betaL</span><span class="p">,</span> <span class="n">HM</span><span class="p">,</span> <span class="n">WM</span><span class="p">,</span> <span class="n">recoError3</span> <span class="o">=</span> <span class="n">SIMM</span><span class="o">.</span><span class="n">Stereo_SIMM</span><span class="p">(</span>
                <span class="c"># the data to be fitted to:</span>
                <span class="n">SXR</span><span class="p">,</span> <span class="n">SXL</span><span class="p">,</span>
                <span class="c"># the basis matrices for the spectral combs</span>
                <span class="n">WUF0</span><span class="p">,</span>
                <span class="c"># and for the elementary filters:</span>
                <span class="n">WGAMMA</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;WGAMMA&#39;</span><span class="p">],</span>
                <span class="c"># number of desired filters, accompaniment spectra:</span>
                <span class="n">numberOfFilters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;K&#39;</span><span class="p">],</span>
                <span class="n">numberOfAccompanimentSpectralShapes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;R&#39;</span><span class="p">],</span>
                <span class="c"># if any, initial amplitude matrices for</span>
                <span class="n">HGAMMA0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HGAMMA&#39;</span><span class="p">],</span>
                <span class="n">HPHI0</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                <span class="n">HF00</span><span class="o">=</span><span class="n">HUF0</span><span class="p">,</span>
                <span class="n">WM0</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="c">#WM,</span>
                <span class="n">HM0</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="c">#HM,</span>
                <span class="c"># Some more optional arguments, to control the &quot;convergence&quot;</span>
                <span class="c"># of the algo</span>
                <span class="n">numberOfIterations</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;niter&#39;</span><span class="p">],</span>
                <span class="n">updateRulePower</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                <span class="n">stepNotes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;stepNotes&#39;</span><span class="p">],</span> 
                <span class="n">lambdaHF0</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">SXR</span><span class="o">.</span><span class="n">max</span><span class="p">()),</span> <span class="n">alphaHF0</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">,</span> <span class="n">displayEvolution</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                <span class="n">updateHGAMMA</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        
            <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HGAMMA&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">HGAMMA</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HPHI&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">HPHI</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HUF0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">HF0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HM&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">HM</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;WM&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">WM</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;alphaR&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">alphaR</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;alphaL&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">alphaL</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;betaR&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">betaR</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;betaL&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">betaL</span>
            
            <span class="k">del</span> <span class="n">SXR</span><span class="p">,</span> <span class="n">SXL</span><span class="p">,</span> <span class="n">HUF0</span>
            
            <span class="c"># computing and storing the complex spectra</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">computeStereoX</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">)</span>
            
            <span class="c"># writing the separated signals as output wavfile with suffix</span>
            <span class="c"># equal to the chunk number</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">writeSeparatedSignals</span><span class="p">(</span><span class="n">suffix</span><span class="o">=</span><span class="s">&#39;</span><span class="si">%05d</span><span class="s">_VUIMM.wav&#39;</span><span class="o">%</span><span class="n">n</span><span class="p">)</span>
            
            <span class="c"># freeing memory</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">XR</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">XL</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HM&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HUF0&#39;</span><span class="p">]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HPHI&#39;</span><span class="p">]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;alphaR&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;alphaL&#39;</span><span class="p">]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;betaR&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;betaL&#39;</span><span class="p">]</span>
        
        <span class="c"># Now concatenating the wav files</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">overlapAddChunks</span><span class="p">(</span>
            <span class="n">nChunks</span><span class="o">=</span><span class="n">nChunks</span><span class="p">,</span>
            <span class="n">suffixIsSUIMM</span><span class="o">=</span><span class="s">&#39;_VUIMM.wav&#39;</span><span class="p">)</span>
    </div>
    <span class="k">def</span> <span class="nf">estimStereoSIMMParams</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">computeStereoX</span><span class="p">()</span>
        <span class="n">SXR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">XR</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">SXL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">XL</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">alphaR</span><span class="p">,</span> <span class="n">alphaL</span><span class="p">,</span> <span class="n">HGAMMA</span><span class="p">,</span> <span class="n">HPHI</span><span class="p">,</span> <span class="n">HF0</span><span class="p">,</span> \
            <span class="n">betaR</span><span class="p">,</span> <span class="n">betaL</span><span class="p">,</span> <span class="n">HM</span><span class="p">,</span> <span class="n">WM</span><span class="p">,</span> <span class="n">recoError2</span> <span class="o">=</span> <span class="n">SIMM</span><span class="o">.</span><span class="n">Stereo_SIMM</span><span class="p">(</span>
            <span class="c"># the data to be fitted to:</span>
            <span class="n">SXR</span><span class="p">,</span> <span class="n">SXL</span><span class="p">,</span>
            <span class="c"># the basis matrices for the spectral combs</span>
            <span class="n">WF0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;WF0&#39;</span><span class="p">],</span>
            <span class="c"># and for the elementary filters:</span>
            <span class="n">WGAMMA</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;WGAMMA&#39;</span><span class="p">],</span>
            <span class="c"># number of desired filters, accompaniment spectra:</span>
            <span class="n">numberOfFilters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;K&#39;</span><span class="p">],</span>
            <span class="n">numberOfAccompanimentSpectralShapes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;R&#39;</span><span class="p">],</span> 
            <span class="c"># if any, initial amplitude matrices for</span>
            <span class="n">HGAMMA0</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">HPHI0</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="n">HF00</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HF00&#39;</span><span class="p">],</span>
            <span class="n">WM0</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">HM0</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="c"># Some more optional arguments, to control the &quot;convergence&quot;</span>
            <span class="c"># of the algo</span>
            <span class="n">numberOfIterations</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;niter&#39;</span><span class="p">],</span>
            <span class="n">updateRulePower</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
            <span class="n">stepNotes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;stepNotes&#39;</span><span class="p">],</span>
            <span class="n">lambdaHF0</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">SXR</span><span class="o">.</span><span class="n">max</span><span class="p">()),</span> <span class="n">alphaHF0</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">,</span> <span class="n">displayEvolution</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HGAMMA&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">HGAMMA</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HPHI&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">HPHI</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HF0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">HF0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HM&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">HM</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;WM&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">WM</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;alphaR&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">alphaR</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;alphaL&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">alphaL</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;betaR&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">betaR</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;betaL&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">betaL</span>
        <span class="k">del</span> <span class="n">SXR</span><span class="p">,</span> <span class="n">SXL</span>
    
    <span class="k">def</span> <span class="nf">estimStereoSUIMMParams</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        
        <span class="n">SXR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">XR</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">SXL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">XL</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="c"># adding the unvoiced part in the source basis:</span>
        <span class="n">WUF0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;WF0&#39;</span><span class="p">],</span>
                          <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;WF0&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">])])</span>
        <span class="n">HUF0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HF0&#39;</span><span class="p">],</span>
                          <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HF0&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]])])</span>
        
        <span class="n">alphaR</span><span class="p">,</span> <span class="n">alphaL</span><span class="p">,</span> <span class="n">HGAMMA</span><span class="p">,</span> <span class="n">HPHI</span><span class="p">,</span> <span class="n">HF0</span><span class="p">,</span> \
            <span class="n">betaR</span><span class="p">,</span> <span class="n">betaL</span><span class="p">,</span> <span class="n">HM</span><span class="p">,</span> <span class="n">WM</span><span class="p">,</span> <span class="n">recoError3</span> <span class="o">=</span> <span class="n">SIMM</span><span class="o">.</span><span class="n">Stereo_SIMM</span><span class="p">(</span>
            <span class="c"># the data to be fitted to:</span>
            <span class="n">SXR</span><span class="p">,</span> <span class="n">SXL</span><span class="p">,</span>
            <span class="c"># the basis matrices for the spectral combs</span>
            <span class="n">WUF0</span><span class="p">,</span>
            <span class="c"># and for the elementary filters:</span>
            <span class="n">WGAMMA</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;WGAMMA&#39;</span><span class="p">],</span>
            <span class="c"># number of desired filters, accompaniment spectra:</span>
            <span class="n">numberOfFilters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;K&#39;</span><span class="p">],</span>
            <span class="n">numberOfAccompanimentSpectralShapes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;R&#39;</span><span class="p">],</span>
            <span class="c"># if any, initial amplitude matrices for</span>
            <span class="n">HGAMMA0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HGAMMA&#39;</span><span class="p">],</span>
            <span class="n">HPHI0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HPHI&#39;</span><span class="p">],</span>
            <span class="n">HF00</span><span class="o">=</span><span class="n">HUF0</span><span class="p">,</span>
            <span class="n">WM0</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="c">#WM,</span>
            <span class="n">HM0</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="c">#HM,</span>
            <span class="c"># Some more optional arguments, to control the &quot;convergence&quot;</span>
            <span class="c"># of the algo</span>
            <span class="n">numberOfIterations</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;niter&#39;</span><span class="p">],</span>
            <span class="n">updateRulePower</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
            <span class="n">stepNotes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;stepNotes&#39;</span><span class="p">],</span> 
            <span class="n">lambdaHF0</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">SXR</span><span class="o">.</span><span class="n">max</span><span class="p">()),</span> <span class="n">alphaHF0</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">,</span> <span class="n">displayEvolution</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
            <span class="n">updateHGAMMA</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HGAMMA&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">HGAMMA</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HPHI&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">HPHI</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HUF0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">HF0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;WUF0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">WUF0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HM&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">HM</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;WM&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">WM</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;alphaR&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">alphaR</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;alphaL&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">alphaL</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;betaR&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">betaR</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;betaL&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">betaL</span>
    
<div class="viewcode-block" id="SeparateLeadProcess.writeSeparatedSignals"><a class="viewcode-back" href="../../../reference/separateleadstereo.html#pyfasst.SeparateLeadStereo.SeparateLeadStereoTF.SeparateLeadProcess.writeSeparatedSignals">[docs]</a>    <span class="k">def</span> <span class="nf">writeSeparatedSignals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="s">&#39;.wav&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Writes the separated signals to the files in self.files.</span>
<span class="sd">        If suffix contains &#39;VUIMM&#39;, then this method will take</span>
<span class="sd">        the WF0 and HF0 that contain the estimated unvoiced elements.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s">&#39;VUIMM&#39;</span> <span class="ow">in</span> <span class="n">suffix</span><span class="p">:</span>
            <span class="n">WF0</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;WUF0&#39;</span><span class="p">]</span>
            <span class="n">HF0</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HUF0&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">WF0</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;WF0&#39;</span><span class="p">]</span>
            <span class="n">HF0</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HF0&#39;</span><span class="p">]</span>
        
        <span class="n">WGAMMA</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;WGAMMA&#39;</span><span class="p">]</span>
        <span class="n">HGAMMA</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HGAMMA&#39;</span><span class="p">]</span>
        <span class="n">HPHI</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HPHI&#39;</span><span class="p">]</span>
        <span class="n">HM</span>     <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HM&#39;</span><span class="p">]</span>
        <span class="n">WM</span>     <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;WM&#39;</span><span class="p">]</span>
        <span class="n">alphaR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;alphaR&#39;</span><span class="p">]</span>
        <span class="n">alphaL</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;alphaL&#39;</span><span class="p">]</span>
        <span class="n">betaR</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;betaR&#39;</span><span class="p">]</span>
        <span class="n">betaL</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;betaL&#39;</span><span class="p">]</span>
        <span class="n">windowSizeInSamples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;windowSizeInSamples&#39;</span><span class="p">]</span>
        
        <span class="n">SPHI</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">WGAMMA</span><span class="p">,</span> <span class="n">HGAMMA</span><span class="p">),</span> <span class="n">HPHI</span><span class="p">)</span>
        <span class="n">SF0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">WF0</span><span class="p">,</span> <span class="n">HF0</span><span class="p">)</span>
        
        <span class="n">hatSXR</span> <span class="o">=</span> <span class="p">(</span><span class="n">alphaR</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">SF0</span> <span class="o">*</span> <span class="n">SPHI</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">WM</span><span class="p">,</span> <span class="n">betaR</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span><span class="n">HM</span><span class="p">)</span>
        <span class="n">hatSXL</span> <span class="o">=</span> <span class="p">(</span><span class="n">alphaL</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">SF0</span> <span class="o">*</span> <span class="n">SPHI</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">WM</span><span class="p">,</span> <span class="n">betaL</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span><span class="n">HM</span><span class="p">)</span>
        <span class="n">hatSXR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">hatSXR</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
        <span class="n">hatSXL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">hatSXL</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
        
        <span class="n">hatVR</span> <span class="o">=</span> <span class="p">(</span><span class="n">alphaR</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">SPHI</span> <span class="o">*</span> <span class="n">SF0</span> <span class="o">/</span> <span class="n">hatSXR</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">XR</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfrepresentation</span> <span class="o">==</span> <span class="s">&#39;stft&#39;</span><span class="p">:</span>
            <span class="n">vestR</span> <span class="o">=</span> <span class="n">slf</span><span class="o">.</span><span class="n">istft</span><span class="p">(</span>
                <span class="n">hatVR</span><span class="p">,</span>
                <span class="n">hopsize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;hopsize&#39;</span><span class="p">],</span>
                <span class="n">nfft</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;NFT&#39;</span><span class="p">],</span>
                <span class="n">window</span><span class="o">=</span><span class="n">slf</span><span class="o">.</span><span class="n">sinebell</span><span class="p">(</span><span class="n">windowSizeInSamples</span><span class="p">),</span>
                <span class="n">originalDataLen</span><span class="o">=</span><span class="bp">None</span><span class="p">,)</span><span class="c">#self.originalDataLen)#  / 4.0</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfrepresentation</span> <span class="ow">in</span> <span class="n">knownTransfos</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">transfo</span> <span class="o">=</span> <span class="n">hatVR</span>
            <span class="n">vestR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">invertTransform</span><span class="p">()</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">transfo</span>
            
        
        <span class="n">hatVR</span> <span class="o">=</span> <span class="p">(</span><span class="n">alphaL</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">SPHI</span> <span class="o">*</span> <span class="n">SF0</span> <span class="o">/</span> <span class="n">hatSXL</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">XL</span>
        
        <span class="k">del</span> <span class="n">SPHI</span><span class="p">,</span> <span class="n">SF0</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfrepresentation</span> <span class="o">==</span> <span class="s">&#39;stft&#39;</span><span class="p">:</span>
            <span class="n">vestL</span> <span class="o">=</span> <span class="n">slf</span><span class="o">.</span><span class="n">istft</span><span class="p">(</span>
                <span class="n">hatVR</span><span class="p">,</span> 
                <span class="n">hopsize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;hopsize&#39;</span><span class="p">],</span>
                <span class="n">nfft</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;NFT&#39;</span><span class="p">],</span>
                <span class="n">window</span><span class="o">=</span><span class="n">slf</span><span class="o">.</span><span class="n">sinebell</span><span class="p">(</span><span class="n">windowSizeInSamples</span><span class="p">),</span>
                <span class="n">originalDataLen</span><span class="o">=</span><span class="bp">None</span><span class="p">,)</span><span class="c">#self.originalDataLen)#  / 4.0</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfrepresentation</span> <span class="ow">in</span> <span class="n">knownTransfos</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">transfo</span> <span class="o">=</span> <span class="n">hatVR</span>
            <span class="n">vestL</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">invertTransform</span><span class="p">()</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">transfo</span>
        
        <span class="k">del</span> <span class="n">hatVR</span>
        
        <span class="n">vestR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">vestR</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">scaleData</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dataType</span><span class="p">)</span>
        <span class="n">vestL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">vestL</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">scaleData</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dataType</span><span class="p">)</span>
        
        <span class="n">wav</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;voc_output_file&#39;</span><span class="p">][:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="n">suffix</span><span class="p">,</span>
                  <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span>
                  <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">vestR</span><span class="p">,</span><span class="n">vestL</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        
        <span class="k">del</span> <span class="n">vestR</span><span class="p">,</span> <span class="n">vestL</span>
        
        <span class="n">hatMR</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">WM</span><span class="p">,</span><span class="n">betaR</span> <span class="o">**</span> <span class="mi">2</span><span class="p">),</span> <span class="n">HM</span><span class="p">))</span> <span class="o">/</span> <span class="n">hatSXR</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">XR</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfrepresentation</span> <span class="o">==</span> <span class="s">&#39;stft&#39;</span><span class="p">:</span>
            <span class="n">mestR</span> <span class="o">=</span> <span class="n">slf</span><span class="o">.</span><span class="n">istft</span><span class="p">(</span>
                <span class="n">hatMR</span><span class="p">,</span>
                <span class="n">hopsize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;hopsize&#39;</span><span class="p">],</span>
                <span class="n">nfft</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;NFT&#39;</span><span class="p">],</span>
                <span class="n">window</span><span class="o">=</span><span class="n">slf</span><span class="o">.</span><span class="n">sinebell</span><span class="p">(</span><span class="n">windowSizeInSamples</span><span class="p">),</span>
                <span class="n">originalDataLen</span><span class="o">=</span><span class="bp">None</span><span class="p">,)</span><span class="c">#self.originalDataLen) # / 4.0</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfrepresentation</span> <span class="ow">in</span> <span class="n">knownTransfos</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">transfo</span> <span class="o">=</span> <span class="n">hatMR</span>
            <span class="n">mestR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">invertTransform</span><span class="p">()</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">transfo</span>
        
        <span class="n">hatMR</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">WM</span><span class="p">,</span><span class="n">betaL</span> <span class="o">**</span> <span class="mi">2</span><span class="p">),</span> <span class="n">HM</span><span class="p">))</span> <span class="o">/</span> <span class="n">hatSXL</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">XL</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfrepresentation</span> <span class="o">==</span> <span class="s">&#39;stft&#39;</span><span class="p">:</span>
            <span class="n">mestL</span> <span class="o">=</span> <span class="n">slf</span><span class="o">.</span><span class="n">istft</span><span class="p">(</span>
                <span class="n">hatMR</span><span class="p">,</span> 
                <span class="n">hopsize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;hopsize&#39;</span><span class="p">],</span>
                <span class="n">nfft</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;NFT&#39;</span><span class="p">],</span>
                <span class="n">window</span><span class="o">=</span><span class="n">slf</span><span class="o">.</span><span class="n">sinebell</span><span class="p">(</span><span class="n">windowSizeInSamples</span><span class="p">),</span>
                <span class="n">originalDataLen</span><span class="o">=</span><span class="bp">None</span><span class="p">,)</span><span class="c">#self.originalDataLen) # / 4.0</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfrepresentation</span> <span class="ow">in</span> <span class="n">knownTransfos</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">transfo</span> <span class="o">=</span> <span class="n">hatMR</span>
            <span class="n">mestL</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">invertTransform</span><span class="p">()</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">mqt</span><span class="o">.</span><span class="n">transfo</span>
        
        <span class="k">del</span> <span class="n">hatMR</span>
        
        <span class="n">mestR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">mestR</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">scaleData</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dataType</span><span class="p">)</span>
        <span class="n">mestL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">mestL</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">scaleData</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dataType</span><span class="p">)</span>
        <span class="n">wav</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;mus_output_file&#39;</span><span class="p">][:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="n">suffix</span><span class="p">,</span>
                  <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span>
                  <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">mestR</span><span class="p">,</span><span class="n">mestL</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        
        <span class="k">del</span> <span class="n">mestR</span><span class="p">,</span> <span class="n">mestL</span>
    </div>
<div class="viewcode-block" id="SeparateLeadProcess.writeSeparatedSignalsWithUnvoice"><a class="viewcode-back" href="../../../reference/separateleadstereo.html#pyfasst.SeparateLeadStereo.SeparateLeadStereoTF.SeparateLeadProcess.writeSeparatedSignalsWithUnvoice">[docs]</a>    <span class="k">def</span> <span class="nf">writeSeparatedSignalsWithUnvoice</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A wrapper to give a decent name to the function: simply</span>
<span class="sd">        calling self.writeSeparatedSignals with the</span>
<span class="sd">        &#39;_VUIMM.wav&#39; suffix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">writeSeparatedSignals</span><span class="p">(</span><span class="n">suffix</span><span class="o">=</span><span class="s">&#39;_VUIMM.wav&#39;</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="SeparateLeadProcess.checkChunkSize"><a class="viewcode-back" href="../../../reference/separateleadstereo.html#pyfasst.SeparateLeadStereo.SeparateLeadStereoTF.SeparateLeadProcess.checkChunkSize">[docs]</a>    <span class="k">def</span> <span class="nf">checkChunkSize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maxFrames</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes the number of chunks of size maxFrames, and</span>
<span class="sd">        changes maxFrames in case it does not provide long enough</span>
<span class="sd">        chunks (especially the last chunk). </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">totFrames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">computeNFrames</span><span class="p">())</span>
        <span class="n">nChunks</span> <span class="o">=</span> <span class="n">totFrames</span> <span class="o">/</span> <span class="n">maxFrames</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c"># checking size of last chunk, if &quot;small&quot;, then making it</span>
        <span class="c"># more even sized chunks</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">totFrames</span><span class="o">-</span><span class="p">(</span><span class="n">nChunks</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">maxFrames</span> <span class="o">&lt;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;windowSizeInSamples&#39;</span><span class="p">]</span> <span class="o">/</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stftParams</span><span class="p">[</span><span class="s">&#39;hopsize&#39;</span><span class="p">]</span> <span class="p">):</span>
            <span class="k">print</span> <span class="s">&quot;Modifying the maxframes, such that chunks not too small&quot;</span>
            <span class="n">maxFrames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="n">totFrames</span><span class="p">)</span><span class="o">/</span><span class="n">nChunks</span><span class="p">))</span>
            <span class="n">nChunks</span> <span class="o">=</span> <span class="n">totFrames</span><span class="o">/</span><span class="n">maxFrames</span> 
            <span class="k">print</span> <span class="s">&quot;The chunks are then maximum&quot;</span><span class="p">,</span> <span class="n">maxFrames</span>
            
        <span class="k">return</span> <span class="n">totFrames</span><span class="p">,</span> <span class="n">nChunks</span><span class="p">,</span> <span class="n">maxFrames</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">pyFASST 0.1 documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Jean-Louis Durrieu.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>