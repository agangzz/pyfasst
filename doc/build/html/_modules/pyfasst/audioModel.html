<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pyfasst.audioModel &mdash; pyFASST 0.1 documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="pyFASST 0.1 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">pyFASST 0.1 documentation</a> &raquo;</li>
          <li><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for pyfasst.audioModel</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">Description</span>
<span class="sd">-----------</span>

<span class="sd">FASST (Flexible Audio Source Separation Toolbox) class</span>
<span class="sd">    subclass it to obtain your own flavoured source separation model!</span>

<span class="sd">You can find more about the technique and how to use this module in the</span>
<span class="sd">provided documentation in `doc/` (`using the python package</span>
<span class="sd">&lt;../description.html#using-the-python-package&gt;`_)</span>
<span class="sd">    </span>
<span class="sd">Adapted from the Matlab toolbox available at:</span>
<span class="sd">http://bass-db.gforge.inria.fr/fasst/</span>

<span class="sd">Contact</span>
<span class="sd">-------</span>
<span class="sd">Jean-Louis Durrieu, EPFL-STI-IEL-LTS5</span>
<span class="sd">::</span>

<span class="sd">    jean DASH louis AT durrieu DOT ch</span>

<span class="sd">2012-2013</span>
<span class="sd">http://www.durrieu.ch</span>

<span class="sd">Copyright</span>
<span class="sd">---------</span>
<span class="sd">This software is distributed under the terms of the GNU Public </span>
<span class="sd">(http://www.gnu.org/licenses/gpl.txt)</span>

<span class="sd">Reference</span>
<span class="sd">---------</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span> 
<span class="kn">from</span> <span class="nn">numpy.testing</span> <span class="kn">import</span> <span class="n">assert_array_almost_equal</span> <span class="c"># FOR DEBUG/DEV</span>
<span class="kn">import</span> <span class="nn">warnings</span><span class="o">,</span> <span class="nn">os</span>

<span class="kn">import</span> <span class="nn">audioObject</span> <span class="kn">as</span> <span class="nn">ao</span>
<span class="kn">import</span> <span class="nn">demixTF</span> <span class="kn">as</span> <span class="nn">demix</span>

<span class="kn">import</span> <span class="nn">SeparateLeadStereo.SeparateLeadStereoTF</span> <span class="kn">as</span> <span class="nn">SLS</span>

<span class="kn">from</span> <span class="nn">sourcefilter.filter</span> <span class="kn">import</span> <span class="n">generateHannBasis</span>
<span class="kn">from</span> <span class="nn">spatial.steering_vectors</span> <span class="kn">import</span> <span class="n">gen_steer_vec_far_src_uniform_linear_array</span>

<span class="kn">import</span> <span class="nn">tftransforms.tft</span> <span class="kn">as</span> <span class="nn">tft</span> <span class="c"># loads the possible transforms</span>

<span class="kn">import</span> <span class="nn">tools.signalTools</span> <span class="kn">as</span> <span class="nn">st</span>
<span class="kn">from</span> <span class="nn">tools.signalTools</span> <span class="kn">import</span> <span class="n">inv_herm_mat_2d</span>
<span class="kn">from</span> <span class="nn">tools.nmf</span> <span class="kn">import</span> <span class="n">NMF_decomp_init</span><span class="p">,</span> <span class="n">NMF_decomposition</span>

<span class="n">tftransforms</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;stftold&#39;</span><span class="p">:</span> <span class="n">tft</span><span class="o">.</span><span class="n">TFTransform</span><span class="p">,</span> <span class="c"># just making dummy, in FASST, not used</span>
    <span class="s">&#39;stft&#39;</span><span class="p">:</span> <span class="n">tft</span><span class="o">.</span><span class="n">STFT</span><span class="p">,</span>
    <span class="s">&#39;mqt&#39;</span><span class="p">:</span> <span class="n">tft</span><span class="o">.</span><span class="n">MinQTransfo</span><span class="p">,</span>
    <span class="s">&#39;minqt&#39;</span><span class="p">:</span> <span class="n">tft</span><span class="o">.</span><span class="n">MinQTransfo</span><span class="p">,</span>
    <span class="s">&#39;nsgmqt&#39;</span><span class="p">:</span> <span class="n">tft</span><span class="o">.</span><span class="n">NSGMinQT</span><span class="p">,</span>
    <span class="s">&#39;cqt&#39;</span><span class="p">:</span> <span class="n">tft</span><span class="o">.</span><span class="n">CQTransfo</span><span class="p">}</span>

<span class="n">eps</span> <span class="o">=</span> <span class="mf">1e-10</span>
<span class="n">log_prior_small_cst</span> <span class="o">=</span> <span class="mf">1e-70</span>
<span class="n">soundCelerity</span> <span class="o">=</span> <span class="mf">340.</span> <span class="c"># m/s</span>

<span class="c">########## Main classes for audio models ##########</span>
<div class="viewcode-block" id="FASST"><a class="viewcode-back" href="../../reference/audiomodel.html#pyfasst.audioModel.FASST">[docs]</a><span class="k">class</span> <span class="nc">FASST</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;**FASST**: Flexible Audio Source Separation Toolbox</span>
<span class="sd">    </span>
<span class="sd">    This is the superclass that implements the core functions for</span>
<span class="sd">    the framework for audio source separation as introduced in [Ozerov2012]_</span>
<span class="sd">    </span>
<span class="sd">        A. Ozerov, E. Vincent and F. Bimbot</span>
<span class="sd">        \&quot;A General Flexible Framework for the Handling of Prior</span>
<span class="sd">        Information in Audio Source Separation,\&quot; </span>
<span class="sd">        IEEE Transactions on Audio, Speech and Signal Processing 20(4),</span>
<span class="sd">        pp. 1118-1133 (2012)                            </span>
<span class="sd">        Available: http://hal.inria.fr/hal-00626962/</span>
<span class="sd">    </span>
<span class="sd">    In order to use it, one should sub-class this class, and in particular</span>
<span class="sd">    define several elements that are assumed by the core functions for</span>
<span class="sd">    estimation and separation in this class, see below for a list.</span>
<span class="sd">    </span>
<span class="sd">    :param audio: the audio filename </span>
<span class="sd">    :param transf:</span>
<span class="sd">        a string describing the desired Time-Frequency (TF) representation</span>
<span class="sd">    :param wlen: length of the analysis windows, mostly for STFT representation</span>
<span class="sd">    :param integer hopsize: the size of samples between two analysis frames</span>
<span class="sd">    :param integer iter_num: number of GEM iterations for parameter esitmation</span>
<span class="sd">    :param str sim_ann_opt: type of annealing strategy (`&#39;ann&#39;`. `&#39;no_ann&#39;`)</span>
<span class="sd">    :param list ann_PSD_lim:</span>
<span class="sd">        list of 2 elements, `ann_PSD_lim[0]` is the amount of added noise</span>
<span class="sd">        to the PSD at beginning, and `ann_PSD_lim[1]` is this amount at the</span>
<span class="sd">        end of the estimation.</span>
<span class="sd">    :param integer verbose:</span>
<span class="sd">        level of verbose: 0 for almost nothing, greater than 1 for debug</span>
<span class="sd">        messages</span>
<span class="sd">    :param double nmfUpdateCoeff:</span>
<span class="sd">        the exponent for the Non-Negative Matrix Factorization-type updates</span>
<span class="sd">        within the GEM iteration</span>
<span class="sd">    :param tffmin: minimum frequency for the TF representation </span>
<span class="sd">    :param tffmax: maximal frequency</span>
<span class="sd">    :param tfWinFunc: window function (please provide a python function here)</span>
<span class="sd">    :param integer tfbpo:</span>
<span class="sd">        number of bins per octave, for Constant-Q-based representations</span>
<span class="sd">    :param double lambdaCorr:</span>
<span class="sd">        penalization term to control the correlation between the sources.</span>
<span class="sd">    </span>
<span class="sd">    Some important attributes of this class are:</span>
<span class="sd">    </span>
<span class="sd">    :var dict spat_comps:</span>
<span class="sd">        a dictionary containing the spatial component parameters and</span>
<span class="sd">        variables. In particular, for a given component numbered `spat_ind`,</span>
<span class="sd">        </span>
<span class="sd">    :var dict spec_comps:</span>
<span class="sd">        the spectral component parameters dictionary. </span>
<span class="sd">    </span>
<span class="sd">    :var pyfasst.audioObject.AudioObject audioObject:</span>
<span class="sd">        the audio object that is to be processed.</span>
<span class="sd">        See :py:class:`pyfasst.audioObject.AudioObject` for details.</span>
<span class="sd">    </span>
<span class="sd">    :var sig_repr_params:</span>
<span class="sd">        Parameters for the computation of the signal TF representation. The</span>
<span class="sd">        keys in this dictionary are:</span>
<span class="sd">        </span>
<span class="sd">            `&#39;transf&#39;` - the type of TF representation</span>

<span class="sd">            `&#39;wlen&#39;` - the window length in samples</span>

<span class="sd">            `&#39;fsize&#39;` - the size of the Fourier transform (in samples)</span>

<span class="sd">            `&#39;hopsize&#39;` - the hop-size in samples between two consecutive frames</span>

<span class="sd">            `&#39;tffmin&#39;`, `&#39;tffmax&#39;`, `&#39;tfbpo&#39;`, `&#39;tfWinFunc&#39;`, `&#39;hopfactor&#39;` -</span>
<span class="sd">            variables related to specific TF representations.</span>
<span class="sd">            </span>
<span class="sd">    :var pyfasst.tftransforms.tft.TFTransform tft:</span>
<span class="sd">        The object that implements the TF transform.</span>
<span class="sd">        See :py:class:`pyfasst.tftransforms.tft.TFTransform`</span>

<span class="sd">    :var numpy.ndarray Cx:</span>
<span class="sd">        The computed transform, after :py:meth:`FASST.omp_transf_Cx` has been</span>
<span class="sd">        called. For memory management, as of 20130820, :py:attr:`FASST.Cx`,</span>
<span class="sd">        for a given frame and given frequency, is supposed to be Hermitian:</span>
<span class="sd">        only the upper diagonal is therefore kept. </span>
<span class="sd">        </span>
<span class="sd">    For examples, see also:</span>

<span class="sd">    * :py:class:`MultiChanNMFInst_FASST`</span>
<span class="sd">    * :py:class:`MultiChanNMFConv`</span>
<span class="sd">    * :py:class:`MultiChanHMM`</span>
<span class="sd">    * :py:class:`multiChanSourceF0Filter`</span>
<span class="sd">    * :py:class:`multichanLead`</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># for now only stft:</span>
    <span class="n">implemented_transf</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;stft&#39;</span><span class="p">,</span><span class="s">&#39;stftold&#39;</span><span class="p">,</span> <span class="s">&#39;mqt&#39;</span><span class="p">,</span> <span class="s">&#39;minqt&#39;</span><span class="p">,</span> <span class="s">&#39;cqt&#39;</span><span class="p">]</span>
    <span class="n">implemented_annealing</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;ann&#39;</span><span class="p">,</span> <span class="s">&#39;no_ann&#39;</span><span class="p">,</span> <span class="p">]</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">audio</span><span class="p">,</span>
                 <span class="n">transf</span><span class="o">=</span><span class="s">&#39;stft&#39;</span><span class="p">,</span>
                 <span class="n">wlen</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span>
                 <span class="n">hopsize</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span>
                 <span class="n">iter_num</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
                 <span class="n">sim_ann_opt</span><span class="o">=</span><span class="s">&#39;ann&#39;</span><span class="p">,</span>
                 <span class="n">ann_PSD_lim</span><span class="o">=</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">],</span>
                 <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                 <span class="n">nmfUpdateCoeff</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span>
                 <span class="n">tffmin</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span>
                 <span class="n">tffmax</span><span class="o">=</span><span class="mi">18000</span><span class="p">,</span>
                 <span class="n">tfWinFunc</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">tfbpo</span><span class="o">=</span><span class="mi">48</span><span class="p">,</span>
                 <span class="n">lambdaCorr</span><span class="o">=</span><span class="mf">0.</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;**FASST**: Flexible Audio Source Separation Toolbox</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nmfUpdateCoeff</span> <span class="o">=</span> <span class="n">nmfUpdateCoeff</span>
        
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">audio</span><span class="p">,</span> <span class="n">ao</span><span class="o">.</span><span class="n">AudioObject</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span> <span class="o">=</span> <span class="n">audio</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">audio</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">audio</span><span class="p">,</span> <span class="nb">unicode</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span> <span class="o">=</span> <span class="n">ao</span><span class="o">.</span><span class="n">AudioObject</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="n">audio</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s">&quot;The provided audio parameter is&quot;</span><span class="o">+</span>
                                 <span class="s">&quot;not a supported format.&quot;</span><span class="p">)</span>
        
        <span class="c"># parameters to compute the signal representation:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;transf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">transf</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>  <span class="c"># transformation type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;wlen&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ao</span><span class="o">.</span><span class="n">nextpow2</span><span class="p">(</span><span class="n">wlen</span><span class="p">)</span>      <span class="c"># window length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;fsize&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ao</span><span class="o">.</span><span class="n">nextpow2</span><span class="p">(</span><span class="n">wlen</span><span class="p">)</span> <span class="c"># Fourier length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;hopsize&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hopsize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;tffmin&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tffmin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;tffmax&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tffmax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;tfbpo&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tfbpo</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;tfWinFunc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tfWinFunc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;hopfactor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mf">1.</span> <span class="o">*</span> <span class="n">hopsize</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;wlen&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;transf&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">implemented_transf</span> \
               <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;transf&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tftransforms</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;transf&#39;</span><span class="p">]</span>
                                      <span class="o">+</span> <span class="s">&quot; not yet implemented.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;transf&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&#39;stftold&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tft</span> <span class="o">=</span> <span class="n">tftransforms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;transf&#39;</span><span class="p">]](</span>
                <span class="n">fmin</span><span class="o">=</span><span class="n">tffmin</span><span class="p">,</span>
                <span class="n">fmax</span><span class="o">=</span><span class="n">tffmax</span><span class="p">,</span>
                <span class="n">bins</span><span class="o">=</span><span class="n">tfbpo</span><span class="p">,</span>
                <span class="n">fs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">samplerate</span><span class="p">,</span>
                <span class="n">perfRast</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">linFTLen</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;fsize&#39;</span><span class="p">],</span>
                <span class="n">atomHopFactor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;hopfactor&#39;</span><span class="p">],</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;transf&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;stftold&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tft</span> <span class="o">=</span> <span class="n">tftransforms</span><span class="p">[</span><span class="s">&#39;stft&#39;</span><span class="p">](</span>
                <span class="n">fmin</span><span class="o">=</span><span class="n">tffmin</span><span class="p">,</span>
                <span class="n">fmax</span><span class="o">=</span><span class="n">tffmax</span><span class="p">,</span>
                <span class="n">bins</span><span class="o">=</span><span class="n">tfbpo</span><span class="p">,</span>
                <span class="n">fs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">samplerate</span><span class="p">,</span>
                <span class="n">perfRast</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">linFTLen</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;fsize&#39;</span><span class="p">],</span>
                <span class="n">atomHopFactor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;hopfactor&#39;</span><span class="p">],</span>
                <span class="p">)</span>
            
            
        <span class="c"># demix parameters:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">demixParams</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s">&#39;tffmin&#39;</span><span class="p">:</span> <span class="n">tffmin</span><span class="p">,</span> <span class="s">&#39;tffmax&#39;</span><span class="p">:</span> <span class="n">tffmax</span><span class="p">,</span>
            <span class="s">&#39;tfbpo&#39;</span><span class="p">:</span> <span class="n">tfbpo</span><span class="p">,</span>
            <span class="s">&#39;tfrepresentation&#39;</span><span class="p">:</span> <span class="n">transf</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="c"># &#39;stft&#39;, #transf.lower()</span>
            <span class="s">&#39;wlen&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;wlen&#39;</span><span class="p">],</span>
            <span class="s">&#39;hopsize&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;wlen&#39;</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
            <span class="s">&#39;neighbors&#39;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
            <span class="s">&#39;winFunc&#39;</span><span class="p">:</span> <span class="n">tfWinFunc</span><span class="p">,</span>
            <span class="p">}</span>
        
        <span class="c"># noise parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">noise</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;PSD&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;fsize&#39;</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;sim_ann_opt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sim_ann_opt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;ann_PSD_lim&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ann_PSD_lim</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">iter_num</span> <span class="o">=</span> <span class="n">iter_num</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lambdaCorr</span> <span class="o">=</span> <span class="n">lambdaCorr</span>
    
<div class="viewcode-block" id="FASST.comp_transf_Cx"><a class="viewcode-back" href="../../reference/audiomodel.html#pyfasst.audioModel.FASST.comp_transf_Cx">[docs]</a>    <span class="k">def</span> <span class="nf">comp_transf_Cx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes the signal representation, according</span>
<span class="sd">        to the provided signal representation flag, in</span>
<span class="sd">        :py:attr:`FASST.sig_repr_params[&#39;transf&#39;]`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="p">,</span> <span class="s">&#39;_data&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">_read</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;transf&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">implemented_transf</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;transf&#39;</span><span class="p">]</span> <span class="o">+</span>
                             <span class="s">&quot; not implemented - yet?&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span> <span class="p">(</span><span class="s">&quot;Computing the chosen signal representation:&quot;</span><span class="p">,</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;transf&#39;</span><span class="p">]</span> <span class="p">)</span>
        
        <span class="n">nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">channels</span>
        <span class="n">Xchan</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nc</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;transf&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;stftold&#39;</span><span class="p">:</span>
                <span class="n">X</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">times</span> <span class="o">=</span> <span class="n">ao</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span><span class="n">n</span><span class="p">],</span>
                    <span class="n">window</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;wlen&#39;</span><span class="p">]),</span>
                    <span class="n">hopsize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;hopsize&#39;</span><span class="p">],</span>
                    <span class="n">nfft</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;fsize&#39;</span><span class="p">],</span>
                    <span class="n">fs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">samplerate</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="o">.</span><span class="n">computeTransform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span><span class="n">n</span><span class="p">],)</span>
                <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="o">.</span><span class="n">transfo</span>
            <span class="n">Xchan</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">print</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
        <span class="c">##assert self.nbFreqsSigRepr == self.tft.freqbins</span>
        <span class="k">del</span> <span class="n">X</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">data</span>
        
        <span class="k">if</span> <span class="n">nc</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Cx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Xchan</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Cx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nc</span> <span class="o">*</span> <span class="p">(</span><span class="n">nc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">],</span>
                               <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">n1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nc</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">n2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">nc</span><span class="p">):</span>
                    <span class="c"># note : we keep only upper diagonal of Cx</span>
                    <span class="c"># lower diagonal is conjugate of upper one.</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="n">n2</span> <span class="o">-</span> <span class="n">n1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="n">nc</span><span class="o">-</span><span class="n">n1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">Xchan</span><span class="p">[</span><span class="n">n1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Xchan</span><span class="p">[</span><span class="n">n2</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;ann_PSD_lim&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;ann_PSD_lim&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">mix_psd</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c"># average power, for each frequency band, across the frames</span>
            <span class="k">if</span> <span class="n">nc</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">mix_psd</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">n1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nc</span><span class="p">):</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="n">nc</span><span class="o">-</span><span class="n">n1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="c"># n2 = n1</span>
                    <span class="n">mix_psd</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;mix_psd&quot;</span><span class="p">,</span> <span class="n">mix_psd</span>
            <span class="n">mix_psd</span> <span class="o">/=</span> <span class="n">nc</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;mix_psd/nc&quot;</span><span class="p">,</span> <span class="n">mix_psd</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;ann_PSD_lim&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;ann_PSD_lim&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">mix_psd</span><span class="p">)</span> <span class="o">/</span> <span class="mf">100.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;ann_PSD_lim&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;ann_PSD_lim&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">mix_psd</span><span class="p">)</span> <span class="o">/</span> <span class="mf">10000.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;sim_ann_opt&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;ann&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;PSD&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;ann_PSD_lim&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="c"># useless for the rest of computations:</span>
        <span class="k">del</span> <span class="n">Xchan</span>
    </div>
<div class="viewcode-block" id="FASST.estim_param_a_post_model"><a class="viewcode-back" href="../../reference/audiomodel.html#pyfasst.audioModel.FASST.estim_param_a_post_model">[docs]</a>    <span class="k">def</span> <span class="nf">estim_param_a_post_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;Estimates the `a posteriori` model for the provided</span>
<span class="sd">        audio signal. In particular, this runs self.iter_num times</span>
<span class="sd">        the Generalized Expectation-Maximisation algorithm</span>
<span class="sd">        :py:meth:`FASST.GEM_iteration`, to</span>
<span class="sd">        update the various parameters of the model, so as to</span>
<span class="sd">        maximize the likelihood of the data given these parameters.</span>
<span class="sd">        </span>
<span class="sd">        From these parameters, the posterior expectation of the</span>
<span class="sd">        \&quot;hidden\&quot; or latent variables (here the spatial and spectral</span>
<span class="sd">        components) can be computed, leading to the estimation of the</span>
<span class="sd">        separated underlying sources.</span>

<span class="sd">        Consider using :py:meth:`FASST.separate_spat_comps` or</span>
<span class="sd">        :py:meth:`FASST.separate_spatial_filter_comp` to obtain the separated time</span>
<span class="sd">        series, once the parameters have been estimated.</span>

<span class="sd">        :returns:</span>
<span class="sd">            `logliks`: The log-likelihoods as computed after each GEM iteration.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">logliks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iter_num</span><span class="p">)</span>
        
        <span class="c"># TODO: move this back in __init__, and remove from subclasses...</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;sim_ann_opt&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;ann&#39;</span><span class="p">,</span> <span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;PSD&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;ann_PSD_lim&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;sim_ann_opt&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="s">&#39;no_ann&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;PSD&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;ann_PSD_lim&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;To add noise to the signal, provide the &quot;</span><span class="o">+</span>
                          <span class="s">&quot;sim_ann_opt from any of &#39;ann&#39;, &quot;</span><span class="o">+</span>
                          <span class="s">&quot;&#39;no_ann&#39; or &#39;ann_ns_inj&#39; &quot;</span><span class="p">)</span>
            
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iter_num</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;Iteration&quot;</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;on&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_num</span>
            <span class="c"># adding the noise psd if required:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;sim_ann_opt&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;ann&#39;</span><span class="p">,</span> <span class="s">&#39;ann_ns_inj&#39;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;PSD&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;ann_PSD_lim&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span>
                     <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iter_num</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">+</span>
                     <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;ann_PSD_lim&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">/</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">iter_num</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                
            <span class="c"># running the GEM iteration:</span>
            <span class="n">logliks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GEM_iteration</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;    log-likelihood:&quot;</span><span class="p">,</span> <span class="n">logliks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="k">print</span> <span class="s">&quot;        improvement:&quot;</span><span class="p">,</span> <span class="n">logliks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">logliks</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">logliks</span>
    </div>
<div class="viewcode-block" id="FASST.GEM_iteration"><a class="viewcode-back" href="../../reference/audiomodel.html#pyfasst.audioModel.FASST.GEM_iteration">[docs]</a>    <span class="k">def</span> <span class="nf">GEM_iteration</span><span class="p">(</span><span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;GEM iteration: one iteration of the Generalized Expectation-</span>
<span class="sd">        Maximization algorithm to update the various parameters whose</span>
<span class="sd">        :py:attr:`FASST.spec_comp[spec_ind][&#39;frdm_prior&#39;]` is set to ``&#39;free&#39;``.</span>
<span class="sd">        </span>
<span class="sd">        :returns:</span>
<span class="sd">            `loglik` (double): the log-likelihood of the data,</span>
<span class="sd">            given the updated parameters</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">channels</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="n">spat_comp_powers</span><span class="p">,</span> <span class="n">mix_matrix</span><span class="p">,</span> <span class="n">rank_part_ind</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">retrieve_subsrc_params</span><span class="p">())</span>
            
            <span class="c"># compute the sufficient statistics</span>
            <span class="n">hat_Rxx</span><span class="p">,</span> <span class="n">hat_Rxs</span><span class="p">,</span> <span class="n">hat_Rss</span><span class="p">,</span> <span class="n">hat_Ws</span><span class="p">,</span> <span class="n">loglik</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">compute_suff_stat</span><span class="p">(</span><span class="n">spat_comp_powers</span><span class="p">,</span> <span class="n">mix_matrix</span><span class="p">))</span>
            
            <span class="c"># update the mixing matrix</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_mix_matrix</span><span class="p">(</span><span class="n">hat_Rxs</span><span class="p">,</span> <span class="n">hat_Rss</span><span class="p">,</span> <span class="n">mix_matrix</span><span class="p">,</span> <span class="n">rank_part_ind</span><span class="p">)</span>
            
            <span class="c"># from sub-sources to sources</span>
            <span class="c"># (as given by the different spatial comps)</span>
            <span class="c">#     had better have shape = [nbSpatComps,F,N]</span>
            <span class="n">hat_W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">rank_part_ind</span><span class="p">),</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;rank_part_in&quot;</span><span class="p">,</span> <span class="n">rank_part_ind</span>
            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rank_part_ind</span><span class="p">)):</span>
                <span class="n">hat_W</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">hat_Ws</span><span class="p">[</span><span class="n">rank_part_ind</span><span class="p">[</span><span class="n">w</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                
            <span class="k">del</span> <span class="n">spat_comp_powers</span><span class="p">,</span> <span class="n">mix_matrix</span><span class="p">,</span> <span class="n">rank_part_ind</span>
            <span class="k">del</span> <span class="n">hat_Rxx</span><span class="p">,</span> <span class="n">hat_Rxs</span><span class="p">,</span> <span class="n">hat_Rss</span><span class="p">,</span> <span class="n">hat_Ws</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s">&quot;Nb channels &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">channels</span><span class="p">)</span><span class="o">+</span>
                                 <span class="s">&quot; not implemented yet&quot;</span><span class="p">)</span>
        
        <span class="c"># update the spectral parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_spectral_components</span><span class="p">(</span><span class="n">hat_W</span><span class="p">)</span>
        
        <span class="c"># normalize parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">renormalize_parameters</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="n">loglik</span>
    </div>
<div class="viewcode-block" id="FASST.comp_spat_comp_power"><a class="viewcode-back" href="../../reference/audiomodel.html#pyfasst.audioModel.FASST.comp_spat_comp_power">[docs]</a>    <span class="k">def</span> <span class="nf">comp_spat_comp_power</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spat_comp_ind</span><span class="p">,</span>
                             <span class="n">spec_comp_ind</span><span class="o">=</span><span class="p">[],</span> <span class="n">factor_ind</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;Matlab FASST Toolbox help::</span>
<span class="sd">        </span>
<span class="sd">        % V = comp_spat_comp_power(mix_str, spat_comp_ind,                  </span>
<span class="sd">        %                          spec_comp_ind, factor_ind);            </span>
<span class="sd">        %</span>
<span class="sd">        % compute spatial component power</span>
<span class="sd">        %</span>
<span class="sd">        %</span>
<span class="sd">        % input</span>
<span class="sd">        % -----</span>
<span class="sd">        %</span>
<span class="sd">        % mix_str           : mixture structure</span>
<span class="sd">        % spat_comp_ind     : spatial component index</span>
<span class="sd">        % spec_comp_ind     : (opt) factor index (def = [], use all components)</span>
<span class="sd">        % factor_ind         : (opt) factor index (def = [], use all factors)</span>
<span class="sd">        % </span>
<span class="sd">        %</span>
<span class="sd">        % output</span>
<span class="sd">        % ------</span>
<span class="sd">        %</span>
<span class="sd">        % V                 : (F x N) spatial component power</span>

<span class="sd">        :param integer spat_comp_ind:</span>
<span class="sd">            index of the spatial component </span>
<span class="sd">        :param list spec_comp_ind:</span>
<span class="sd">            list of indices for the spectral components whose spatial component</span>
<span class="sd">            corresponds to the provided `spat_comp_ind`</span>
<span class="sd">        :param list factor_ind:</span>
<span class="sd">            list of indices of factors to be included. </span>

<span class="sd">        Note: thanks to object-oriented programming, no need to provide the</span>
<span class="sd">        structure containing all the parameters, the instance has direct access</span>
<span class="sd">        to them.</span>

<span class="sd">        Note2: this may not completely work because the factor_ind should</span>
<span class="sd">        actually also depend on the index of the spectral component. TODO?</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spec_comp_ind</span><span class="p">):</span>
            <span class="n">spec_comp_ind_arr</span> <span class="o">=</span> <span class="n">spec_comp_ind</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">spec_comp_ind_arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">spec_comp_ind_arr</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">spat_comp_ind</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s">&#39;spat_comp_ind&#39;</span><span class="p">]:</span>
                <span class="n">V_comp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">factor_ind</span><span class="p">):</span>
                    <span class="n">factors_ind_arr</span> <span class="o">=</span> <span class="n">factor_ind</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">factors_ind_arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                    
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">factors_ind_arr</span><span class="p">:</span>
                    <span class="n">factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="n">f</span><span class="p">]</span>
                    <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;FB&#39;</span><span class="p">],</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;FW&#39;</span><span class="p">])</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;TB&#39;</span><span class="p">]):</span>
                        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">],</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;TB&#39;</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">H</span> <span class="o">=</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">]</span>
                    <span class="n">V_comp</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">H</span><span class="p">)</span>
                    <span class="k">del</span> <span class="n">W</span>
                    <span class="k">del</span> <span class="n">H</span>
                    
                <span class="n">V</span> <span class="o">+=</span> <span class="n">V_comp</span>
                <span class="k">del</span> <span class="n">V_comp</span>
                <span class="k">del</span> <span class="n">factor</span>
        
        <span class="k">return</span> <span class="n">V</span>
    </div>
<div class="viewcode-block" id="FASST.comp_spat_cmps_powers"><a class="viewcode-back" href="../../reference/audiomodel.html#pyfasst.audioModel.FASST.comp_spat_cmps_powers">[docs]</a>    <span class="k">def</span> <span class="nf">comp_spat_cmps_powers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spat_comp_ind</span><span class="p">,</span>
                              <span class="n">spec_comp_ind</span><span class="o">=</span><span class="p">[],</span> <span class="n">factor_ind</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;Compute the sum of the spectral powers corresponding to the</span>
<span class="sd">        spatial components as provided in the list `spat_comp_ind`</span>
<span class="sd">        </span>
<span class="sd">        NB: because this does not take into account the mixing process,</span>
<span class="sd">        the resulting power does not, in general, correspond to the</span>
<span class="sd">        the observed signal&#39;s parameterized spectral power.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">V</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">spat_comp_ind</span><span class="p">:</span>
            <span class="n">V</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comp_spat_comp_power</span><span class="p">(</span><span class="n">spat_comp_ind</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">V</span>
    </div>
<div class="viewcode-block" id="FASST.retrieve_subsrc_params"><a class="viewcode-back" href="../../reference/audiomodel.html#pyfasst.audioModel.FASST.retrieve_subsrc_params">[docs]</a>    <span class="k">def</span> <span class="nf">retrieve_subsrc_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">        Computes the various quantities necessary for the estimation of the</span>
<span class="sd">        main parameters:</span>
<span class="sd">        </span>
<span class="sd">        **Outputs**</span>
<span class="sd">        </span>
<span class="sd">        :returns:</span>
<span class="sd">        </span>
<span class="sd">         1. :py:attr:`spat_comp_powers` - </span>
<span class="sd">            (`total_spat_rank` x `nbFreqsSigRepr` x `nbFramesSigRepr`) ndarray</span>
<span class="sd">            the spatial component power spectra. Note that total_spat_rank</span>
<span class="sd">            is the sum of all the spatial ranks for all the sources.</span>
<span class="sd">            </span>
<span class="sd">         2. :py:attr:`mix_matrix` -</span>
<span class="sd">            (`total_spat_rank` x `nchannels` x `nbFreqsSigRepr`)</span>
<span class="sd">            :py:class:`ndarray` the mixing matrices for each source</span>
<span class="sd">            </span>
<span class="sd">         3. :py:attr:`rank_part_ind` - </span>
<span class="sd">            dictionary: each key is one source, and the values are the indices</span>
<span class="sd">            in `spat_comp_powers` and `mix_matrix` that correspond to that source.</span>
<span class="sd">            If the spatial rank of source `j` is 2, then its spectra will appear</span>
<span class="sd">            twice in `spat_comp_powers`, with mixing parameters (potentially</span>
<span class="sd">            different one from the other) appearing in two sub-matrices of</span>
<span class="sd">            :py:attr:`mix_matrix`.</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">K</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">)</span>
        <span class="n">rank_total</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">rank_part_ind</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>
            <span class="c"># this is the ranks</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;mix_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;inst&#39;</span><span class="p">:</span>
                <span class="n">rank</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;params&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rank</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;params&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;    Rank of spatial source </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span><span class="n">j</span> <span class="o">+</span>\
                      <span class="s">&quot; is </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span><span class="n">rank</span>
            <span class="n">rank_part_ind</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">rank_total</span> <span class="o">+</span>
                <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">rank</span><span class="p">))</span>
            <span class="n">rank_total</span> <span class="o">+=</span> <span class="n">rank</span>
        
        <span class="n">spat_comp_powers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">rank_total</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">])</span>
        
        <span class="n">mix_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">rank_total</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">channels</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">spat_comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">spat_comp_j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comp_spat_comp_power</span><span class="p">(</span><span class="n">spat_comp_ind</span><span class="o">=</span><span class="n">j</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rank_part_ind</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">spat_comp_powers</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">spat_comp_j</span>
            <span class="k">if</span> <span class="n">spat_comp</span><span class="p">[</span><span class="s">&#39;mix_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;inst&#39;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">):</span>
                    <span class="c">#print rank_part_ind[j]</span>
                    <span class="c">#print spat_comp[&#39;params&#39;].shape</span>
                    <span class="c">#print mix_matrix[rank_part_ind[j],:,f].shape</span>
                    <span class="n">mix_matrix</span><span class="p">[</span><span class="n">rank_part_ind</span><span class="p">[</span><span class="n">j</span><span class="p">],:,</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">spat_comp</span><span class="p">[</span><span class="s">&#39;params&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mix_matrix</span><span class="p">[</span><span class="n">rank_part_ind</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">spat_comp</span><span class="p">[</span><span class="s">&#39;params&#39;</span><span class="p">]</span>
                
        <span class="k">return</span> <span class="n">spat_comp_powers</span><span class="p">,</span> <span class="n">mix_matrix</span><span class="p">,</span> <span class="n">rank_part_ind</span>
    </div>
<div class="viewcode-block" id="FASST.compute_suff_stat"><a class="viewcode-back" href="../../reference/audiomodel.html#pyfasst.audioModel.FASST.compute_suff_stat">[docs]</a>    <span class="k">def</span> <span class="nf">compute_suff_stat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spat_comp_powers</span><span class="p">,</span> <span class="n">mix_matrix</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">        Computes the sufficient statistics, used to update the parameters.</span>
<span class="sd">        </span>
<span class="sd">        **Inputs:**</span>
<span class="sd">        </span>
<span class="sd">        :param numpy.ndarray spat_comp_powers:</span>
<span class="sd">            (`total_spat_rank`x`nbFreqsSigRepr`x`nbFramesSigRepr`) `ndarray`.</span>
<span class="sd">            the estimated power spectra for the spatial components, as computed</span>
<span class="sd">            by :py:meth:`FASST.retrieve_subsrc_params`. </span>
<span class="sd">        :param numpy.ndarray mix_matrix:</span>
<span class="sd">            (`total_spat_rank` x `nchannels` x `nbFreqsSigRepr`) `ndarray`.</span>
<span class="sd">            the mixing parameters, as a rank x n_channels x n_freqs `ndarray`.</span>
<span class="sd">            Computed from :py:meth:`FASST.retrieve_subsrc_params`</span>
<span class="sd">        </span>
<span class="sd">        **Outputs:**</span>

<span class="sd">        :returns:</span>
<span class="sd">            1. `hat_Rxx`</span>
<span class="sd">            2. `hat_Rxs`</span>
<span class="sd">            3. `hat_Rss`</span>
<span class="sd">            4. `hat_Ws`</span>
<span class="sd">            5. `loglik`</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">channels</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Nb channels not supported:&quot;</span><span class="o">+</span>
                             <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">channels</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;    Computing sufficient statistics&quot;</span>
        <span class="n">nbspatcomp</span> <span class="o">=</span> <span class="n">spat_comp_powers</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="c"># CAUTION! non-initialized arrays !</span>
        <span class="n">sigma_x_diag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">])</span>
        <span class="c">#sigma_x_off = np.zeros([self.nbFreqsSigRepr,</span>
        <span class="c">#                        self.nbFramesSigRepr], dtype=complex)</span>
        
        <span class="c"># setting the first element with spat_comp 0:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">sigma_x_diag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mix_matrix</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span>
            <span class="n">spat_comp_powers</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="n">sigma_x_diag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mix_matrix</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span>
            <span class="n">spat_comp_powers</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="n">sigma_x_off</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">mix_matrix</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span>
                      <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">mix_matrix</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span> <span class="o">*</span>
            <span class="n">spat_comp_powers</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
            <span class="p">)</span>
        
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">sigma_x_diag</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;PSD&#39;</span><span class="p">])</span>
            <span class="c"># noise PSD should be of size nbFreqs</span>
        
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nbspatcomp</span><span class="p">):</span>
            <span class="n">sigma_x_diag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mix_matrix</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span>
                <span class="n">spat_comp_powers</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="n">sigma_x_diag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mix_matrix</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span>
                <span class="n">spat_comp_powers</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="n">sigma_x_off</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">mix_matrix</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span>
                          <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">mix_matrix</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span> <span class="o">*</span>
                <span class="n">spat_comp_powers</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
                <span class="p">)</span>
            
        <span class="n">inv_sigma_x_diag</span><span class="p">,</span> <span class="n">inv_sigma_x_off</span><span class="p">,</span> <span class="n">det_sigma_x</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">inv_herm_mat_2d</span><span class="p">(</span><span class="n">sigma_x_diag</span><span class="p">,</span> <span class="n">sigma_x_off</span><span class="p">,</span>
                            <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">))</span>
        <span class="k">del</span> <span class="n">sigma_x_diag</span><span class="p">,</span> <span class="n">sigma_x_off</span>
        
        <span class="c"># compute log likelihood</span>
        <span class="n">loglik</span> <span class="o">=</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">det_sigma_x</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">+</span>
                           <span class="n">inv_sigma_x_diag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span>
                           <span class="n">inv_sigma_x_diag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span>
                           <span class="mf">2.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">inv_sigma_x_off</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                           <span class="p">)</span>
        <span class="c"># compute expectations of Rss and Ws sufficient statistics</span>
        <span class="n">Gs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">nbspatcomp</span><span class="p">,</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span> <span class="c"># {}</span>
        <span class="c"># one for each channel (stereo, here)</span>
        <span class="c">#Gs[0] = {}</span>
        <span class="c">#Gs[1] = {}</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbspatcomp</span><span class="p">):</span>
            <span class="n">Gs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">mix_matrix</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span> <span class="o">*</span> <span class="n">inv_sigma_x_diag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span>
                 <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">mix_matrix</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span> <span class="o">*</span>
                 <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">inv_sigma_x_off</span><span class="p">))</span> <span class="o">*</span>
                <span class="n">spat_comp_powers</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
                <span class="p">)</span>
            
            <span class="n">Gs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">mix_matrix</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span> <span class="o">*</span> <span class="n">inv_sigma_x_off</span> <span class="o">+</span>
                 <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">mix_matrix</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span> <span class="o">*</span> <span class="n">inv_sigma_x_diag</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span>
                <span class="n">spat_comp_powers</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
                <span class="p">)</span>

        <span class="c"># the following quantities are assigned later, so</span>
        <span class="c"># an empty allocation should do.</span>
        <span class="n">hat_Rss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                            <span class="n">nbspatcomp</span><span class="p">,</span>
                            <span class="n">nbspatcomp</span><span class="p">],</span>
                           <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">hat_Ws</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">nbspatcomp</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">])</span>
        <span class="n">hatRssLoc1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">hatRssLoc2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">hatRssLoc3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">r1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbspatcomp</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">r2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbspatcomp</span><span class="p">):</span>
                <span class="c"># TODO: could probably factor a bit more the following formula:</span>
                <span class="n">hatRssLoc1</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">hatRssLoc1</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Gs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">r2</span><span class="p">])</span>
                <span class="n">hatRssLoc1</span> <span class="o">+=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Gs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">r2</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">hatRssLoc1</span> <span class="o">*=</span> <span class="n">Gs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">r1</span><span class="p">]</span>
                
                <span class="n">hatRssLoc2</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">hatRssLoc2</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Gs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">r2</span><span class="p">])</span>
                <span class="n">hatRssLoc2</span> <span class="o">+=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Gs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">r2</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">hatRssLoc2</span> <span class="o">*=</span> <span class="n">Gs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">r1</span><span class="p">]</span>
                
                <span class="n">hatRssLoc3</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">Gs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">r1</span><span class="p">])</span>
                <span class="n">hatRssLoc3</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">mix_matrix</span><span class="p">[</span><span class="n">r2</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">hatRssLoc3</span> <span class="o">+=</span> <span class="p">(</span><span class="n">Gs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">r1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">mix_matrix</span><span class="p">[</span><span class="n">r2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">hatRssLoc3</span> <span class="o">*=</span> <span class="n">spat_comp_powers</span><span class="p">[</span><span class="n">r2</span><span class="p">]</span>
                
                <span class="n">hatRssLoc1</span> <span class="o">+=</span> <span class="n">hatRssLoc2</span>
                <span class="n">hatRssLoc1</span> <span class="o">-=</span> <span class="n">hatRssLoc3</span>
                
                <span class="c">#hatRssLoc = (Gs[0][r1] * np.conj(Gs[0][r2]) * self.Cx[0] +</span>
                <span class="c">#             Gs[1][r1] * np.conj(Gs[1][r2]) * self.Cx[2] +</span>
                <span class="c">#             Gs[0][r1] * np.conj(Gs[1][r2]) * self.Cx[1] +</span>
                <span class="c">#             Gs[1][r1]*np.conj(Gs[0][r2])*np.conj(self.Cx[1])-</span>
                <span class="c">#             (Gs[0][r1] * np.vstack(mix_matrix[r2][0]) +</span>
                <span class="c">#              Gs[1][r1] * np.vstack(mix_matrix[r2][1]))</span>
                <span class="c">#             * spat_comp_powers[r2]</span>
                <span class="c">#             )</span>
                <span class="k">if</span> <span class="n">r1</span> <span class="o">==</span> <span class="n">r2</span><span class="p">:</span>
                    <span class="n">hatRssLoc1</span> <span class="o">+=</span> <span class="n">spat_comp_powers</span><span class="p">[</span><span class="n">r1</span><span class="p">]</span>
                    <span class="n">hat_Ws</span><span class="p">[</span><span class="n">r1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">hatRssLoc1</span><span class="p">))</span>
                    
                <span class="n">hat_Rss</span><span class="p">[:,</span><span class="n">r1</span><span class="p">,</span><span class="n">r2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">hatRssLoc1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                
        <span class="c"># To assure hermitian symmetry:</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">10</span><span class="p">:</span> <span class="c"># DEBUG</span>
                <span class="n">assert_array_almost_equal</span><span class="p">(</span>
                    <span class="n">hat_Rss</span><span class="p">[</span><span class="n">f</span><span class="p">],</span>
                    <span class="p">(</span><span class="n">hat_Rss</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">hat_Rss</span><span class="p">[</span><span class="n">f</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span>
                
            <span class="n">hat_Rss</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">hat_Rss</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">hat_Rss</span><span class="p">[</span><span class="n">f</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
            
        <span class="c"># Expectations of Rxs sufficient statistics</span>
        <span class="n">hat_Rxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                            <span class="mi">2</span><span class="p">,</span>
                            <span class="n">nbspatcomp</span><span class="p">],</span>
                           <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbspatcomp</span><span class="p">):</span>
            <span class="n">hat_Rxs</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Gs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">r</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Gs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">r</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="n">hat_Rxs</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Gs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">r</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Gs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">r</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="p">)</span>
        
        <span class="k">del</span> <span class="n">Gs</span>
        
        <span class="c"># at last Rxx sufficient statistics:</span>
        <span class="n">hat_Rxx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c"># recommendation, use logarithm:</span>
        <span class="c"># hat_Rxx[]</span>
        
        <span class="k">return</span> <span class="n">hat_Rxx</span><span class="p">,</span> <span class="n">hat_Rxs</span><span class="p">,</span> <span class="n">hat_Rss</span><span class="p">,</span> <span class="n">hat_Ws</span><span class="p">,</span> <span class="n">loglik</span>
    </div>
<div class="viewcode-block" id="FASST.update_mix_matrix"><a class="viewcode-back" href="../../reference/audiomodel.html#pyfasst.audioModel.FASST.update_mix_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">update_mix_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">hat_Rxs</span><span class="p">,</span> <span class="n">hat_Rss</span><span class="p">,</span> <span class="n">mix_matrix</span><span class="p">,</span> <span class="n">rank_part_ind</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update the mixing parameters, according to the current estimated</span>
<span class="sd">        spectral component parameters.</span>
<span class="sd">        </span>
<span class="sd">        :param hat_Rxs:</span>
<span class="sd">            (`nbFreqsSigRepr` x 2 x `nbspatcomp`) `ndarray`.</span>
<span class="sd">            Estimated intercorrelation between the observation and the</span>
<span class="sd">            sources, for each frequency bin of the TF representation.</span>
<span class="sd">        :param hat_Rss:</span>
<span class="sd">            (`nbFreqsSigRepr` x `nbspatcomp` x `nbspatcomp`) `ndarray`.</span>
<span class="sd">            Estimated auto-correlation matrix for each frequency bin, </span>
<span class="sd">        :param mix_matrix:</span>
<span class="sd">            (`total_spat_rank` x `nchannels` x `nbFreqsSigRepr`) `ndarray`.</span>
<span class="sd">            the mixing parameters, as a rank x n_channels x n_freqs `ndarray`.</span>
<span class="sd">        :param rank_part_ind:</span>
<span class="sd">            a dictionary giving, for each spectral component, which spatial</span>
<span class="sd">            component should be used.</span>
<span class="sd">        </span>
<span class="sd">        The input parameters should be computed by :py:meth:`compute_suff_stat`</span>
<span class="sd">        and :py:meth:`retrieve_subsrc_params`, done automatically in</span>
<span class="sd">        :py:meth:`GEM_iteration`.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># deriving which components have which updating rule:</span>
        <span class="n">upd_inst_ind</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">upd_inst_other_ind</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">upd_conv_ind</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">upd_conv_other_ind</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">spat_comp_j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">spat_comp_j</span><span class="p">[</span><span class="s">&#39;frdm_prior&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;free&#39;</span> <span class="ow">and</span> \
                   <span class="n">spat_comp_j</span><span class="p">[</span><span class="s">&#39;mix_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;inst&#39;</span><span class="p">:</span>
                <span class="n">upd_inst_ind</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">rank_part_ind</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">upd_inst_other_ind</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">rank_part_ind</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            
            <span class="k">if</span> <span class="n">spat_comp_j</span><span class="p">[</span><span class="s">&#39;frdm_prior&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;free&#39;</span> <span class="ow">and</span> \
                   <span class="n">spat_comp_j</span><span class="p">[</span><span class="s">&#39;mix_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;conv&#39;</span><span class="p">:</span>
                <span class="n">upd_conv_ind</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">rank_part_ind</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">upd_conv_other_ind</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">rank_part_ind</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        
        <span class="c"># update linear instantaneous coefficients:</span>
        <span class="n">K_inst</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">upd_inst_ind</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">upd_inst_ind</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;    Updating mixing matrix, instantaneous sources&quot;</span>
            <span class="c">#hat_Rxs_bis = np.zeros([self.nbFreqsSigRepr,</span>
            <span class="c">#                        2,</span>
            <span class="c">#                        K_inst])</span>
            <span class="n">hat_Rxs_bis</span> <span class="o">=</span> <span class="n">hat_Rxs</span><span class="p">[:,:,</span><span class="n">upd_inst_ind</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">upd_inst_other_ind</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">):</span>
                    <span class="n">hat_Rxs_bis</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">-=</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mix_matrix</span><span class="p">[</span><span class="n">upd_inst_other_ind</span><span class="p">,:,</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                               <span class="n">hat_Rss</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">upd_inst_other_ind</span><span class="p">),</span>
                                                        <span class="n">upd_inst_ind</span><span class="p">]))</span>
                    <span class="c"># hat_Rss[f][upd_inst_other_ind][:,upd_inst_ind])</span>
            <span class="n">hat_Rxs_bis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">hat_Rxs_bis</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="n">rm_hat_Rss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">hat_Rss</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">upd_inst_ind</span><span class="p">),</span>
                                                 <span class="n">upd_inst_ind</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            
            <span class="c"># in ozerov&#39;s code:</span>
            <span class="c">##mix_matrix_inst = np.dot(hat_Rxs_bis, np.linalg.inv(rm_hat_Rss))</span>
            <span class="n">mix_matrix_inst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">rm_hat_Rss</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">hat_Rxs_bis</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="c">#                                   sym_pos=True).T</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;mix_matrix&quot;</span><span class="p">,</span> <span class="n">mix_matrix</span>
                <span class="k">print</span> <span class="s">&quot;mix_matrix_inst&quot;</span><span class="p">,</span> <span class="n">mix_matrix_inst</span>
                <span class="k">print</span> <span class="s">&quot;mix_matrix_inst.shape&quot;</span><span class="p">,</span><span class="n">mix_matrix_inst</span><span class="o">.</span><span class="n">shape</span>
                <span class="k">print</span> <span class="n">mix_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> \
                      <span class="n">mix_matrix</span><span class="p">[</span><span class="n">upd_inst_ind</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">):</span>
                <span class="n">mix_matrix</span><span class="p">[</span><span class="n">upd_inst_ind</span><span class="p">,:,</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">mix_matrix_inst</span>
                
            <span class="k">del</span> <span class="n">mix_matrix_inst</span>
            
        <span class="c"># update convolutive coefficients: </span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">upd_conv_ind</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;    Updating mixing matrix, convolutive sources&quot;</span>
            <span class="n">hat_Rxs_bis</span> <span class="o">=</span> <span class="n">hat_Rxs</span><span class="p">[:,:,</span><span class="n">upd_conv_ind</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">upd_conv_other_ind</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">):</span>
                    <span class="n">hat_Rxs_bis</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">-=</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mix_matrix</span><span class="p">[</span><span class="n">upd_conv_other_ind</span><span class="p">,:,</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                               <span class="n">hat_Rss</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">upd_conv_other_ind</span><span class="p">),</span>
                                          <span class="n">upd_conv_ind</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">mix_matrix</span><span class="p">[</span><span class="n">upd_conv_ind</span><span class="p">,:,</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">hat_Rss</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">hat_Rxs_bis</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
                <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
                    <span class="k">print</span> <span class="s">&quot;hat_Rss[f]:&quot;</span><span class="p">,</span> <span class="n">hat_Rss</span><span class="p">[</span><span class="n">f</span><span class="p">]</span>
                    <span class="k">print</span> <span class="s">&quot;hat_Rxs_bis[f]:&quot;</span><span class="p">,</span> <span class="n">hat_Rxs_bis</span><span class="p">[</span><span class="n">f</span><span class="p">]</span>
                    <span class="k">raise</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">(</span><span class="s">&#39;Singular Matrix&#39;</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="c"># re-raise the exception if that was not linalgerror...</span>
                    
            <span class="c">## smoothing</span>
            <span class="c">##for n in upd_conv_ind:</span>
            <span class="c">##    for nc in range(self.audioObject.channels):</span>
            <span class="c">##        smoothAbsMix = (</span>
            <span class="c">##            st.medianFilter(np.abs(mix_matrix[n,nc,:]),</span>
            <span class="c">##                            length=self.nbFreqsSigRepr/200)</span>
            <span class="c">##            )</span>
            <span class="c">##        mix_matrix[n,nc,:] = (</span>
            <span class="c">##            smoothAbsMix *</span>
            <span class="c">##            np.exp(1j * np.angle(mix_matrix[n,nc,:]))</span>
            <span class="c">##            )</span>
            
        <span class="c"># update the matrix in the component parameters:</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">spat_comp_k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">spat_comp_k</span><span class="p">[</span><span class="s">&#39;frdm_prior&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;free&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">spat_comp_k</span><span class="p">[</span><span class="s">&#39;mix_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;inst&#39;</span><span class="p">:</span>
                    <span class="n">spat_comp_k</span><span class="p">[</span><span class="s">&#39;params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">mix_matrix</span><span class="p">[</span><span class="n">rank_part_ind</span><span class="p">[</span><span class="n">k</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">spat_comp_k</span><span class="p">[</span><span class="s">&#39;params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">mix_matrix</span><span class="p">[</span><span class="n">rank_part_ind</span><span class="p">[</span><span class="n">k</span><span class="p">]])</span>
                    
        <span class="c"># mix_matrix should have changed outside this method... TBC</span>
        <span class="c"># should we normalize here?</span>
        <span class="c">##self.renormalize_parameters()</span>
        </div>
<div class="viewcode-block" id="FASST.separate_spatial_filter_comp"><a class="viewcode-back" href="../../reference/audiomodel.html#pyfasst.audioModel.FASST.separate_spatial_filter_comp">[docs]</a>    <span class="k">def</span> <span class="nf">separate_spatial_filter_comp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                     <span class="n">dir_results</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                                     <span class="n">suffix</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;separate_spatial_filter_comp</span>
<span class="sd">        </span>
<span class="sd">        Separates the sources using only the estimated spatial</span>
<span class="sd">        filter (i.e. the mixing parameters in self.spat_comps[j][&#39;params&#39;])</span>
<span class="sd">        </span>
<span class="sd">        In particular, we consider here the corresponding MVDR filter,</span>
<span class="sd">        as exposed in [Maazaoui2011]_.</span>
<span class="sd">        </span>
<span class="sd">        per channel, the filter steering vector, source p:</span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>
<span class="sd">        </span>
<span class="sd">            b(f,p) = \\frac{R_{aa,f}^{-1} a(f,p)}{a^{H}(f,p) R_{aa,f}^{-1} a(f,p)}</span>
<span class="sd">            </span>
<span class="sd">        with</span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>
<span class="sd">        </span>
<span class="sd">            R_{aa,f} = \\sum_q a(f,q) a^{H}(f,q)</span>
<span class="sd">            </span>
<span class="sd">        It corresponds also to the given model in FASST, assuming that all the</span>
<span class="sd">        spectral powers are equal across all sources. Here, by computing the Wiener</span>
<span class="sd">        Gain WG to get the images, we actually have</span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>
<span class="sd">        </span>
<span class="sd">            b(f,p) a(f,p)^H</span>
<span class="sd">            </span>
<span class="sd">        and the denominator therefore is the trace of the \&quot;numerator\&quot;.</span>
<span class="sd">        </span>
<span class="sd">        .. [Maazaoui2011] Maazaoui, M.; Grenier, Y. and Abed-Meraim, K.</span>
<span class="sd">           Blind Source Separation for Robot Audition using</span>
<span class="sd">           Fixed Beamforming with HRTFs, </span>
<span class="sd">           in proc. of INTERSPEECH, 2011.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># grouping the indices by spatial component</span>
        <span class="n">spec_comp_ind</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">spat_ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">)):</span>
            <span class="n">spec_comp_ind</span><span class="p">[</span><span class="n">spat_ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">spec_ind</span><span class="p">,</span> <span class="n">spec_comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c"># add the spec comp index to the corresponding spatial comp:</span>
            <span class="n">spec_comp_ind</span><span class="p">[</span><span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;spat_comp_ind&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spec_ind</span><span class="p">)</span>
            
        <span class="c"># copying from separate_spec_comps -  could modify that one later...</span>
        <span class="k">if</span> <span class="n">dir_results</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">dir_results</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s">&#39;/&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;Writing to same directory as input file: &quot;</span> <span class="o">+</span> <span class="n">dir_results</span>
        
        <span class="n">nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">channels</span>
        <span class="k">if</span> <span class="n">nc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
        
        <span class="n">nbSources</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spec_comp_ind</span><span class="p">)</span>
        <span class="n">sigma_comps_diag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nbSources</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">])</span>
        <span class="n">sigma_comps_off</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nbSources</span><span class="p">,</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
        
        <span class="c"># computing individual spatial variance</span>
        <span class="n">R_diag0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nbSources</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">])</span>
        <span class="n">R_diag1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nbSources</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">])</span>
        <span class="n">R_off</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nbSources</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbSources</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;mix_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;inst&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;Mixing params not convolutive...&#39;</span><span class="p">)</span>
                <span class="n">mix_coefficients</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;params&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
                <span class="c"># mix_coefficients.shape should be (rank, nchannels)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;mix_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;conv&#39;</span><span class="p">:</span>
                <span class="n">mix_coefficients</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;params&#39;</span><span class="p">]</span>
                <span class="c"># mix_coefficients.shape should be (rank, nchannels, freq)</span>
            
            <span class="c"># R_diag = np.zeros(2, self.nbFreqsSigRepr)</span>
            <span class="n">R_diag0</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span>
                <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mix_coefficients</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="n">R_diag1</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mix_coefficients</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="c"># element at (1,2): </span>
            <span class="n">R_off</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">((</span>
                <span class="n">mix_coefficients</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span>
                <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">mix_coefficients</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            
        <span class="n">Raa_00</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">R_diag0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">Raa_11</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">R_diag1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">Raa_01</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">R_off</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">inv_Raa_diag</span><span class="p">,</span> <span class="n">inv_Raa_off</span><span class="p">,</span> <span class="n">det_mat</span> <span class="o">=</span> <span class="n">inv_herm_mat_2d</span><span class="p">(</span>
            <span class="p">[</span><span class="n">Raa_00</span><span class="p">,</span> <span class="n">Raa_11</span><span class="p">],</span>
            <span class="n">Raa_01</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;files&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">files</span> <span class="o">=</span> <span class="p">{}</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;spatial&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="n">fileroot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">][:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbSources</span><span class="p">):</span>
            <span class="n">WG</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_Wiener_gain_2d</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">R_diag0</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">R_diag1</span><span class="p">[</span><span class="n">n</span><span class="p">]],</span>
                    <span class="n">R_off</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
                    <span class="n">inv_Raa_diag</span><span class="p">,</span>
                    <span class="n">inv_Raa_off</span><span class="p">,</span>
                <span class="n">timeInvariant</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">normalization</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">WG</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">WG</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">WG</span> <span class="o">/=</span> <span class="p">[[</span><span class="n">normalization</span><span class="p">]]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;transf&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="s">&#39;stftold&#39;</span><span class="p">:</span>
                <span class="c"># compute the stft/istft</span>
                <span class="n">ndata</span> <span class="o">=</span> <span class="n">ao</span><span class="o">.</span><span class="n">filter_stft</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">WG</span><span class="p">,</span> <span class="n">analysisWindow</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                    <span class="n">synthWindow</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;wlen&#39;</span><span class="p">]),</span>
                    <span class="n">hopsize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;hopsize&#39;</span><span class="p">],</span>
                    <span class="n">nfft</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;fsize&#39;</span><span class="p">],</span>
                    <span class="n">fs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">samplerate</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c">#raise NotImplementedError(&quot;TODO&quot;)</span>
                <span class="n">X</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">chan1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nc</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="o">.</span><span class="n">computeTransform</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span><span class="n">chan1</span><span class="p">])</span>
                    <span class="n">X</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="o">.</span><span class="n">transfo</span><span class="p">)</span>
                <span class="n">ndata</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="n">WG</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">chan1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nc</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="o">.</span><span class="n">transfo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                                                     <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">],</span>
                                                    <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">chan2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nc</span><span class="p">):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="o">.</span><span class="n">transfo</span> <span class="o">+=</span> <span class="p">(</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">WG</span><span class="p">[</span><span class="n">chan1</span><span class="p">,</span> <span class="n">chan2</span><span class="p">])</span>
                                <span class="o">*</span> <span class="n">X</span><span class="p">[</span><span class="n">chan2</span><span class="p">])</span>
                        <span class="n">ndata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="o">.</span><span class="n">invertTransform</span><span class="p">())</span>
                        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="o">.</span><span class="n">transfo</span>
                <span class="k">elif</span> <span class="n">WG</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">chan1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nc</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="o">.</span><span class="n">transfo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                                                     <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">],</span>
                                                    <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">chan2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nc</span><span class="p">):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="o">.</span><span class="n">transfo</span> <span class="o">+=</span> <span class="p">(</span>
                                <span class="n">WG</span><span class="p">[</span><span class="n">chan1</span><span class="p">,</span> <span class="n">chan2</span><span class="p">]</span>
                                <span class="o">*</span> <span class="n">X</span><span class="p">[</span><span class="n">chan2</span><span class="p">])</span>
                        <span class="n">ndata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="o">.</span><span class="n">invertTransform</span><span class="p">())</span>
                        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="o">.</span><span class="n">transfo</span>
                        
                <span class="n">ndata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ndata</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                
            <span class="n">_suffix</span> <span class="o">=</span> <span class="s">&#39;_spatial&#39;</span>
            <span class="k">if</span> <span class="n">suffix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">suffix</span><span class="p">:</span>
                <span class="n">_suffix</span> <span class="o">+=</span> <span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="n">suffix</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="n">outAudioName</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">dir_results</span> <span class="o">+</span> <span class="s">&#39;/&#39;</span> <span class="o">+</span> <span class="n">fileroot</span> <span class="o">+</span> <span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> 
                <span class="s">&#39;-&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">nbSources</span><span class="p">)</span> <span class="o">+</span> <span class="n">_suffix</span> <span class="o">+</span> <span class="s">&#39;.wav&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;spatial&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">outAudioName</span><span class="p">)</span>
            <span class="n">outAudioObj</span> <span class="o">=</span> <span class="n">ao</span><span class="o">.</span><span class="n">AudioObject</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="n">outAudioName</span><span class="p">,</span>
                                         <span class="n">mode</span><span class="o">=</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
            <span class="n">outAudioObj</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">(</span>
                <span class="n">ndata</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">nframes</span><span class="p">,:]</span> <span class="o">*</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">_maxdata</span><span class="p">)</span><span class="c">#(2**15))</span>
            <span class="n">outAudioObj</span><span class="o">.</span><span class="n">_maxdata</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">outAudioObj</span><span class="o">.</span><span class="n">_encoding</span> <span class="o">=</span> <span class="s">&#39;pcm16&#39;</span>
            <span class="n">outAudioObj</span><span class="o">.</span><span class="n">samplerate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">samplerate</span>
            <span class="n">outAudioObj</span><span class="o">.</span><span class="n">_write</span><span class="p">()</span>
        </div>
<div class="viewcode-block" id="FASST.separate_spat_comps"><a class="viewcode-back" href="../../reference/audiomodel.html#pyfasst.audioModel.FASST.separate_spat_comps">[docs]</a>    <span class="k">def</span> <span class="nf">separate_spat_comps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                            <span class="n">dir_results</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                            <span class="n">suffix</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;separate_spat_comps</span>
<span class="sd">        </span>
<span class="sd">        This separates the sources for each spatial component.</span>

<span class="sd">        :param dir_results:</span>
<span class="sd">            provide the (existing) folder where to write the results</span>
<span class="sd">        :param dict suffix:</span>
<span class="sd">            a dictionary containing the labels for each source. If None,</span>
<span class="sd">            then no suffix is appended to the file names and the files</span>
<span class="sd">            are simply numbered `XXX_nbComps`. </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spec_comp_ind</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">spat_ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">)):</span>
            <span class="n">spec_comp_ind</span><span class="p">[</span><span class="n">spat_ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">spec_ind</span><span class="p">,</span> <span class="n">spec_comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">spec_comp_ind</span><span class="p">[</span><span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;spat_comp_ind&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spec_ind</span><span class="p">)</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">separate_comps</span><span class="p">(</span><span class="n">dir_results</span><span class="o">=</span><span class="n">dir_results</span><span class="p">,</span>
                            <span class="n">spec_comp_ind</span><span class="o">=</span><span class="n">spec_comp_ind</span><span class="p">,</span>
                            <span class="n">suffix</span><span class="o">=</span><span class="n">suffix</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="FASST.separate_comps"><a class="viewcode-back" href="../../reference/audiomodel.html#pyfasst.audioModel.FASST.separate_comps">[docs]</a>    <span class="k">def</span> <span class="nf">separate_comps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                       <span class="n">dir_results</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                       <span class="n">spec_comp_ind</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                       <span class="n">suffix</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;separate_comps</span>
<span class="sd">        </span>
<span class="sd">        Separate the sources as defined by the spectral</span>
<span class="sd">        components provided in spec_comp_ind.</span>
<span class="sd">        </span>
<span class="sd">        This function differs from separate_spat_comps in the way</span>
<span class="sd">        that it does not assume the sources are defined by their spatial</span>
<span class="sd">        positions.</span>

<span class="sd">        :param dir_results:</span>
<span class="sd">            provide the (existing) folder where to write the results</span>
<span class="sd">        :param dict spec_comp_ind:</span>
<span class="sd">            a dictionary telling which spectral component to include in</span>
<span class="sd">            which separated source. If None, the default is to assume</span>
<span class="sd">            each spectral component is one source.</span>
<span class="sd">            Note that this is different to the behaviour of</span>
<span class="sd">            :py:meth:`separate_spat_comps` which assumes that each</span>
<span class="sd">            *spatial* component corresponds to one source. </span>
<span class="sd">        :param dict suffix:</span>
<span class="sd">            a dictionary containing the labels for each source. If None,</span>
<span class="sd">            then no suffix is appended to the file names and the files</span>
<span class="sd">            are simply numbered `XXX_nbComps`. </span>
<span class="sd">        </span>
<span class="sd">        Note: Trying to bring into one method</span>
<span class="sd">        ozerov&#39;s separate_spec_comps and separate_spat_comps</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dir_results</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">dir_results</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s">&#39;/&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;Writing to same directory as input file: &quot;</span> <span class="o">+</span> <span class="n">dir_results</span>
        
        <span class="n">nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">channels</span>
        <span class="k">if</span> <span class="n">nc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">spec_comp_ind</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">spec_comp_ind</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">spec_ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">)):</span>
                <span class="n">spec_comp_ind</span><span class="p">[</span><span class="n">spec_ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">spec_ind</span><span class="p">,]</span>
        
        <span class="n">nbSources</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spec_comp_ind</span><span class="p">)</span>
        <span class="n">sigma_comps_diag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nbSources</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">])</span>
        <span class="n">sigma_comps_off</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nbSources</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
        
        <span class="c"># computing individual source variance</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbSources</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;    source&quot;</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;out of&quot;</span><span class="p">,</span><span class="n">nbSources</span>
            <span class="n">spat_comp_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">spec_ind</span><span class="p">][</span><span class="s">&#39;spat_comp_ind&#39;</span><span class="p">]</span>
                 <span class="k">for</span> <span class="n">spec_ind</span> <span class="ow">in</span> <span class="n">spec_comp_ind</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;        spat_comp_ind&quot;</span><span class="p">,</span> <span class="n">spat_comp_ind</span>
            <span class="k">for</span> <span class="n">spat_ind</span> <span class="ow">in</span> <span class="n">spat_comp_ind</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">print</span> <span class="s">&quot;        spatial comp&quot;</span><span class="p">,</span><span class="n">spat_ind</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> \
                          <span class="s">&quot;out of&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">spat_comp_ind</span><span class="p">)</span>
                <span class="n">sigma_c_diag</span><span class="p">,</span> <span class="n">sigma_c_off</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">compute_sigma_comp_2d</span><span class="p">(</span><span class="n">spat_ind</span><span class="p">,</span> <span class="n">spec_comp_ind</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
                    <span class="p">)</span>
                <span class="n">sigma_comps_diag</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sigma_c_diag</span>
                <span class="n">sigma_comps_off</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sigma_c_off</span>
                <span class="k">del</span> <span class="n">sigma_c_diag</span><span class="p">,</span> <span class="n">sigma_c_off</span>
        <span class="c"># deriving inverse of mix covariance:</span>
        <span class="n">inv_sigma_x_diag</span><span class="p">,</span> <span class="n">inv_sigma_x_off</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_inv_sigma_mix_2d</span><span class="p">(</span>
            <span class="n">sigma_comps_diag</span><span class="p">,</span>
            <span class="n">sigma_comps_off</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&quot;files&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">files</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;spat_comp&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">if</span> <span class="bp">True</span><span class="p">:</span> <span class="c"># self # IF TRANSFO is STFT !!!... 20130507 corrected now?</span>
            <span class="n">fileroot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">][:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbSources</span><span class="p">):</span>
                <span class="c"># get the Wiener filters:</span>
                <span class="n">WG</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_Wiener_gain_2d</span><span class="p">(</span>
                    <span class="n">sigma_comps_diag</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
                    <span class="n">sigma_comps_off</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
                    <span class="n">inv_sigma_x_diag</span><span class="p">,</span>
                    <span class="n">inv_sigma_x_off</span><span class="p">)</span>
                <span class="c"># compute the stft/istft</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;transf&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;stftold&#39;</span><span class="p">:</span>
                    <span class="n">ndata</span> <span class="o">=</span> <span class="n">ao</span><span class="o">.</span><span class="n">filter_stft</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">WG</span><span class="p">,</span> <span class="n">analysisWindow</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                        <span class="n">synthWindow</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;wlen&#39;</span><span class="p">]),</span>
                        <span class="n">hopsize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;hopsize&#39;</span><span class="p">],</span>
                        <span class="n">nfft</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;fsize&#39;</span><span class="p">],</span>
                        <span class="n">fs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">samplerate</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">X</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">chan1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nc</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="o">.</span><span class="n">computeTransform</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span><span class="n">chan1</span><span class="p">])</span>
                        <span class="n">X</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="o">.</span><span class="n">transfo</span><span class="p">)</span>
                    <span class="n">ndata</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">if</span> <span class="n">WG</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">chan1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nc</span><span class="p">):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="o">.</span><span class="n">transfo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                                                         <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">],</span>
                                                        <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">chan2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nc</span><span class="p">):</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="o">.</span><span class="n">transfo</span> <span class="o">+=</span> <span class="p">(</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">WG</span><span class="p">[</span><span class="n">chan1</span><span class="p">,</span> <span class="n">chan2</span><span class="p">])</span>
                                    <span class="o">*</span> <span class="n">X</span><span class="p">[</span><span class="n">chan2</span><span class="p">])</span>
                            <span class="n">ndata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="o">.</span><span class="n">invertTransform</span><span class="p">())</span>
                            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="o">.</span><span class="n">transfo</span>
                    <span class="k">elif</span> <span class="n">WG</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">chan1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nc</span><span class="p">):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="o">.</span><span class="n">transfo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                                                         <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">],</span>
                                                        <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">chan2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nc</span><span class="p">):</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="o">.</span><span class="n">transfo</span> <span class="o">+=</span> <span class="p">(</span>
                                    <span class="n">WG</span><span class="p">[</span><span class="n">chan1</span><span class="p">,</span> <span class="n">chan2</span><span class="p">]</span>
                                    <span class="o">*</span> <span class="n">X</span><span class="p">[</span><span class="n">chan2</span><span class="p">])</span>
                            <span class="n">ndata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="o">.</span><span class="n">invertTransform</span><span class="p">())</span>
                            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="o">.</span><span class="n">transfo</span>
                        
                    <span class="n">ndata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ndata</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                <span class="n">_suffix</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
                <span class="k">if</span> <span class="n">suffix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">suffix</span><span class="p">:</span>
                    <span class="n">_suffix</span> <span class="o">=</span> <span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="n">suffix</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                <span class="n">outAudioName</span> <span class="o">=</span> \
                    <span class="n">dir_results</span> <span class="o">+</span> <span class="s">&#39;/&#39;</span> <span class="o">+</span> <span class="n">fileroot</span> <span class="o">+</span> <span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> \
                    <span class="s">&#39;-&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">nbSources</span><span class="p">)</span> <span class="o">+</span> <span class="n">_suffix</span> <span class="o">+</span> <span class="s">&#39;.wav&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;spat_comp&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">outAudioName</span><span class="p">)</span>
                <span class="n">outAudioObj</span> <span class="o">=</span> <span class="n">ao</span><span class="o">.</span><span class="n">AudioObject</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="n">outAudioName</span><span class="p">,</span>
                                             <span class="n">mode</span><span class="o">=</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
                <span class="n">outAudioObj</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">(</span>
                    <span class="n">ndata</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">nframes</span><span class="p">,:]</span> <span class="o">*</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">_maxdata</span><span class="p">)</span><span class="c">#(2**15))</span>
                <span class="n">outAudioObj</span><span class="o">.</span><span class="n">_maxdata</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">outAudioObj</span><span class="o">.</span><span class="n">_encoding</span> <span class="o">=</span> <span class="s">&#39;pcm16&#39;</span>
                <span class="n">outAudioObj</span><span class="o">.</span><span class="n">samplerate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">samplerate</span>
                <span class="n">outAudioObj</span><span class="o">.</span><span class="n">_write</span><span class="p">()</span>
        <span class="c">## TODO: else for the other transforms</span>
        <span class="c">##       should work all the same, but with cqt, not very good</span>
        <span class="c">## means to cut signals and paste them back together...</span>
        </div>
<div class="viewcode-block" id="FASST.mvdr_2d"><a class="viewcode-back" href="../../reference/audiomodel.html#pyfasst.audioModel.FASST.mvdr_2d">[docs]</a>    <span class="k">def</span> <span class="nf">mvdr_2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">theta</span><span class="p">,</span>
                <span class="n">distanceInterMic</span><span class="o">=.</span><span class="mi">3</span><span class="p">,</span>
                <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;mvdr_2d(self,</span>
<span class="sd">        theta, # in radians</span>
<span class="sd">        distanceInterMic=.3, # in meters</span>
<span class="sd">        )</span>
<span class="sd">        </span>
<span class="sd">        MVDR minimum variance distortion-less response spatial</span>
<span class="sd">        filter, for a given angle theta and given distance between the mics.</span>
<span class="sd">        </span>
<span class="sd">        self.Cx is supposed to provide the necessary covariance matrix, for</span>
<span class="sd">        the \&quot;Capon\&quot; filter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Cx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">)</span>
        <span class="n">Cx</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">Cx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">Cx</span><span class="p">[</span><span class="mi">1</span><span class="p">][:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">Cx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">Cx</span><span class="p">[</span><span class="mi">2</span><span class="p">][:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">Cx</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">print</span> <span class="n">Cx</span>
        
        <span class="n">inv_Cx_diag</span><span class="p">,</span> <span class="n">inv_Cx_off</span><span class="p">,</span> <span class="n">det_Cx</span> <span class="o">=</span> <span class="n">inv_herm_mat_2d</span><span class="p">(</span>
            <span class="p">[</span><span class="n">Cx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Cx</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
            <span class="n">Cx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
        <span class="n">freqs</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.</span> <span class="o">/</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;fsize&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">samplerate</span>
            <span class="p">)</span>
        
        <span class="n">filt</span> <span class="o">=</span> <span class="n">gen_steer_vec_far_src_uniform_linear_array</span><span class="p">(</span>
                   <span class="n">freqs</span><span class="p">,</span>
                   <span class="n">nchannels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">channels</span><span class="p">,</span>
                   <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span>
                   <span class="n">distanceInterMic</span><span class="o">=</span><span class="n">distanceInterMic</span><span class="p">)</span>
        
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">channels</span><span class="p">,</span> <span class="c"># nc x nc x F x N</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">channels</span><span class="p">,</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
        
        <span class="n">den</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">inv_Cx_diag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> 
            <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">filt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">inv_Cx_diag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
            <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">filt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">inv_Cx_off</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="n">W</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">filt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">*</span> <span class="n">inv_Cx_off</span>
            <span class="p">)</span>
        <span class="n">W</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">W</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
            <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">inv_Cx_diag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> 
            <span class="p">)</span>
        <span class="n">W</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">filt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">inv_Cx_diag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> 
            <span class="p">)</span>
        <span class="n">W</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">inv_Cx_off</span> <span class="o">+</span>
            <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">filt</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">inv_Cx_diag</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> 
            <span class="p">)</span>
        <span class="n">W</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">filt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">inv_Cx_off</span><span class="p">)</span> <span class="o">+</span>
            <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">filt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">inv_Cx_diag</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="p">)</span>
        <span class="c">#if self.verbose&gt;1:</span>
        <span class="c">#    print W</span>
        <span class="c"># should check that self.sig_repr_params[&#39;transf&#39;] == &#39;stft&#39;</span>
        <span class="k">return</span> <span class="n">ao</span><span class="o">.</span><span class="n">filter_stft</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">W</span><span class="p">,</span>
            <span class="n">analysisWindow</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;wlen&#39;</span><span class="p">]),</span>
            <span class="n">synthWindow</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;wlen&#39;</span><span class="p">]),</span>
            <span class="n">hopsize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;hopsize&#39;</span><span class="p">],</span>
            <span class="n">nfft</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;fsize&#39;</span><span class="p">],</span>
            <span class="n">fs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">samplerate</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="FASST.gcc_phat_tdoa_2d"><a class="viewcode-back" href="../../reference/audiomodel.html#pyfasst.audioModel.FASST.gcc_phat_tdoa_2d">[docs]</a>    <span class="k">def</span> <span class="nf">gcc_phat_tdoa_2d</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Using the cross-spectrum in self.Cx[1] to estimate the time</span>
<span class="sd">        difference of arrival detection function (the Generalized</span>
<span class="sd">        Cross-Correlation GCC), with the phase transform (GCC-PHAT) weighing</span>
<span class="sd">        function for the cross-spectrum.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">irfft</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                            <span class="n">n</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;fsize&#39;</span><span class="p">],</span>
                            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
    </div>
<div class="viewcode-block" id="FASST.compute_sigma_comp_2d"><a class="viewcode-back" href="../../reference/audiomodel.html#pyfasst.audioModel.FASST.compute_sigma_comp_2d">[docs]</a>    <span class="k">def</span> <span class="nf">compute_sigma_comp_2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spat_ind</span><span class="p">,</span> <span class="n">spec_comp_ind</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;only for stereo case self.audioObject.channels==2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">spat_comp_power</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comp_spat_comp_power</span><span class="p">(</span>
            <span class="n">spat_comp_ind</span><span class="o">=</span><span class="n">spat_ind</span><span class="p">,</span>
            <span class="n">spec_comp_ind</span><span class="o">=</span><span class="n">spec_comp_ind</span><span class="p">)</span>
        
        <span class="c"># getting the mixing coefficients for corresponding</span>
        <span class="c"># spatial source, depending on mix_type</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">spat_ind</span><span class="p">][</span><span class="s">&#39;mix_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;inst&#39;</span><span class="p">:</span>
            <span class="n">mix_coefficients</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">spat_ind</span><span class="p">][</span><span class="s">&#39;params&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
            <span class="c"># mix_coefficients.shape should be (rank, nchannels)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">spat_ind</span><span class="p">][</span><span class="s">&#39;mix_type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;conv&#39;</span><span class="p">:</span>
            <span class="n">mix_coefficients</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">spat_ind</span><span class="p">][</span><span class="s">&#39;params&#39;</span><span class="p">]</span>
            <span class="c"># mix_coefficients.shape should be (rank, nchannels, freq)</span>
        
        <span class="c"># R_diag = np.zeros(2, self.nbFreqsSigRepr)</span>
        <span class="n">R_diag0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span>
            <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mix_coefficients</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">R_diag1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span>
            <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mix_coefficients</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="c"># element at (1,2): </span>
        <span class="n">R_off</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">((</span>
            <span class="n">mix_coefficients</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span>
            <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">mix_coefficients</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        
        <span class="n">sigma_comp_diag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">print</span> <span class="n">R_diag0</span><span class="p">,</span> <span class="s">&quot;R_diag0.shape&quot;</span><span class="p">,</span> <span class="n">R_diag0</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">print</span> <span class="n">R_diag1</span><span class="p">,</span> <span class="s">&quot;R_diag1.shape&quot;</span><span class="p">,</span> <span class="n">R_diag1</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">print</span> <span class="n">R_off</span><span class="p">,</span> <span class="s">&quot;R_off.shape&quot;</span><span class="p">,</span> <span class="n">R_off</span><span class="o">.</span><span class="n">shape</span>
        
        <span class="n">sigma_comp_diag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">R_diag0</span><span class="p">)</span> <span class="o">*</span>
            <span class="n">spat_comp_power</span><span class="p">)</span>
        <span class="n">sigma_comp_diag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">R_diag1</span><span class="p">)</span> <span class="o">*</span>
            <span class="n">spat_comp_power</span><span class="p">)</span>
        
        <span class="n">sigma_comp_off</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">R_off</span><span class="p">)</span> <span class="o">*</span> <span class="n">spat_comp_power</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">sigma_comp_diag</span><span class="p">,</span> <span class="n">sigma_comp_off</span>
    </div>
<div class="viewcode-block" id="FASST.compute_inv_sigma_mix_2d"><a class="viewcode-back" href="../../reference/audiomodel.html#pyfasst.audioModel.FASST.compute_inv_sigma_mix_2d">[docs]</a>    <span class="k">def</span> <span class="nf">compute_inv_sigma_mix_2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                 <span class="n">sigma_comps_diag</span><span class="p">,</span>
                                 <span class="n">sigma_comps_off</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;only for nb channels = 2</span>
<span class="sd">        </span>
<span class="sd">        sigma_comps_diag ncomp x nchan x nfreq x nframes</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sigma_x_diag</span> <span class="o">=</span> <span class="n">sigma_comps_diag</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">sigma_x_off</span> <span class="o">=</span> <span class="n">sigma_comps_off</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">sigma_x_diag</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;PSD&#39;</span><span class="p">])</span>
            <span class="c"># noise PSD should be of size nbFreqs</span>
        
        <span class="n">inv_sigma_x_diag</span><span class="p">,</span> <span class="n">inv_sigma_x_off</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">inv_herm_mat_2d</span><span class="p">(</span><span class="n">sigma_x_diag</span><span class="p">,</span> <span class="n">sigma_x_off</span><span class="p">,</span>
                            <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">))</span>
        
        <span class="k">del</span> <span class="n">sigma_x_diag</span><span class="p">,</span> <span class="n">sigma_x_off</span>
        
        <span class="k">return</span> <span class="n">inv_sigma_x_diag</span><span class="p">,</span> <span class="n">inv_sigma_x_off</span>
    </div>
<div class="viewcode-block" id="FASST.compute_Wiener_gain_2d"><a class="viewcode-back" href="../../reference/audiomodel.html#pyfasst.audioModel.FASST.compute_Wiener_gain_2d">[docs]</a>    <span class="k">def</span> <span class="nf">compute_Wiener_gain_2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                               <span class="n">sigma_comp_diag</span><span class="p">,</span>
                               <span class="n">sigma_comp_off</span><span class="p">,</span>
                               <span class="n">inv_sigma_mix_diag</span><span class="p">,</span>
                               <span class="n">inv_sigma_mix_off</span><span class="p">,</span>
                               <span class="n">timeInvariant</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Matlab FASST Toolbox help::</span>
<span class="sd">        </span>
<span class="sd">            % WG = comp_WG_spat_comps(mix_str);</span>
<span class="sd">            %</span>
<span class="sd">            % compute Wiener gains for spatial components</span>
<span class="sd">            %</span>
<span class="sd">            %</span>
<span class="sd">            % input</span>
<span class="sd">            % -----</span>
<span class="sd">            %</span>
<span class="sd">            % mix_str           : input mix structure</span>
<span class="sd">            % </span>
<span class="sd">            %</span>
<span class="sd">            % output</span>
<span class="sd">            % ------</span>
<span class="sd">            %</span>
<span class="sd">            % WG                : Wiener gains [M x M x F x N x K_spat]</span>
<span class="sd">            %</span>
<span class="sd">            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="sd">            % Flexible Audio Source Separation Toolbox (FASST), Version 1.0</span>
<span class="sd">            %</span>
<span class="sd">            % Copyright 2011 Alexey Ozerov, Emmanuel Vincent and Frederic Bimbot</span>
<span class="sd">            % (alexey.ozerov -at- inria.fr, emmanuel.vincent -at- inria.fr,</span>
<span class="sd">            %  frederic.bimbot -at- irisa.fr)     </span>
<span class="sd">            %</span>
<span class="sd">            % This software is distributed under the terms of the GNU Public </span>
<span class="sd">            % License version 3 (http://www.gnu.org/licenses/gpl.txt)</span>
<span class="sd">            %</span>
<span class="sd">            % If you use this code please cite this research report</span>
<span class="sd">            %</span>
<span class="sd">            % A. Ozerov, E. Vincent and F. Bimbot</span>
<span class="sd">            % \&quot;A General Flexible Framework for the Handling of Prior</span>
<span class="sd">            % Information in Audio Source Separation,\&quot; </span>
<span class="sd">            % IEEE Transactions on Audio, Speech and Signal Processing 20(4),</span>
<span class="sd">            % pp. 1118-1133 (2012).</span>
<span class="sd">            % Available: http://hal.inria.fr/hal-00626962/</span>
<span class="sd">            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Here, WG is given by the product:</span>
        <span class="c">#     np.dot(sigma_comp</span>
        <span class="k">if</span> <span class="n">timeInvariant</span><span class="p">:</span>
            <span class="n">WG</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,],</span>
                          <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span><span class="c"># stands for Wiener Gains</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">WG</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">],</span>
                          <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span><span class="c"># stands for Wiener Gains</span>
        <span class="n">WG</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigma_comp_off</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">inv_sigma_mix_off</span><span class="p">)</span>
        <span class="n">WG</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">WG</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">WG</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sigma_comp_diag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">inv_sigma_mix_diag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">WG</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sigma_comp_diag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">inv_sigma_mix_diag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="n">WG</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">sigma_comp_diag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">inv_sigma_mix_off</span> <span class="o">+</span>
            <span class="n">sigma_comp_off</span> <span class="o">*</span> <span class="n">inv_sigma_mix_diag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="n">WG</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">sigma_comp_off</span><span class="p">)</span> <span class="o">*</span> <span class="n">inv_sigma_mix_diag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span>
            <span class="n">sigma_comp_diag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">inv_sigma_mix_off</span><span class="p">)</span>
            <span class="p">)</span>
        
        <span class="k">return</span> <span class="n">WG</span>
    </div>
<div class="viewcode-block" id="FASST.update_spectral_components"><a class="viewcode-back" href="../../reference/audiomodel.html#pyfasst.audioModel.FASST.update_spectral_components">[docs]</a>    <span class="k">def</span> <span class="nf">update_spectral_components</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hat_W</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update the spectral components,</span>
<span class="sd">        with `hat_W` as the expected value of power</span>
<span class="sd">        (and computed from )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;    Update the spectral components&quot;</span>
        <span class="n">omega</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmfUpdateCoeff</span>
        <span class="n">nbspeccomp</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">spec_comp_ind</span><span class="p">,</span> <span class="n">spec_comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">nbfactors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;factor&#39;</span><span class="p">])</span>
            <span class="n">spat_comp_ind</span> <span class="o">=</span> <span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;spat_comp_ind&#39;</span><span class="p">]</span>
            
            <span class="c"># DEBUG</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambdaCorr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="c"># min inter-src correlation approach</span>
                <span class="c"># this is the sum of all the spatial component powers</span>
                <span class="n">spat_comp_powers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comp_spat_cmps_powers</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span> <span class="n">eps</span><span class="p">)</span>
                <span class="c">### we need the squared of that matrix too:</span>
                <span class="c">##spat_comp_powers_sqd = spat_comp_powers ** 2</span>
                <span class="c"># the initial spatial comp. power of the current comp:</span>
                <span class="n">spat_comp_power</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">comp_spat_comp_power</span><span class="p">(</span>
                            <span class="n">spat_comp_ind</span><span class="p">,</span>
                            <span class="c">#spec_comp_ind=[spec_comp_ind],</span>
                            <span class="p">),</span>
                        <span class="n">eps</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="c"># ... and removing from the other powers - for correlation</span>
                <span class="c"># control:</span>
                <span class="n">spat_comp_pow_minus</span> <span class="o">=</span> <span class="n">spat_comp_powers</span> <span class="o">-</span> <span class="n">spat_comp_power</span>
                
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">spat_comp_pow_minus</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="p">):</span> <span class="c"># DEBUG</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="s">&quot;Not all spat_comp_pow_minus, &quot;</span><span class="o">+</span>
                        <span class="s">&quot;</span><span class="si">%d</span><span class="s"> negative values!&quot;</span> <span class="o">%</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">spat_comp_pow_minus</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="p">))</span>
                    <span class="n">spat_comp_pow_minus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">spat_comp_pow_minus</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
                
            <span class="k">for</span> <span class="n">fact_ind</span><span class="p">,</span> <span class="n">factor</span> <span class="ow">in</span> <span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;factor&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c"># update FB - freq basis</span>
                <span class="n">other_fact_ind_arr</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbfactors</span><span class="p">)</span>
                <span class="n">other_fact_ind_arr</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fact_ind</span><span class="p">)</span>
                <span class="n">other_fact_power</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">comp_spat_comp_power</span><span class="p">(</span>
                            <span class="n">spat_comp_ind</span><span class="o">=</span><span class="n">spat_comp_ind</span><span class="p">,</span>
                            <span class="n">spec_comp_ind</span><span class="o">=</span><span class="p">[</span><span class="n">spec_comp_ind</span><span class="p">],</span>
                            <span class="n">factor_ind</span><span class="o">=</span><span class="n">other_fact_ind_arr</span><span class="p">),</span>
                        <span class="n">eps</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;FB_frdm_prior&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;free&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                        <span class="k">print</span> <span class="s">&quot;    Updating frequency basis </span><span class="si">%d</span><span class="s">-</span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span><span class="p">(</span>
                            <span class="n">spec_comp_ind</span><span class="p">,</span> <span class="n">fact_ind</span><span class="p">)</span>
                    <span class="n">spat_comp_power</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">comp_spat_comp_power</span><span class="p">(</span>
                                <span class="n">spat_comp_ind</span><span class="p">,</span>
                                <span class="c">#spec_comp_ind=[spec_comp_ind]</span>
                                <span class="p">),</span>
                            <span class="n">eps</span><span class="p">)</span>
                        <span class="p">)</span>
                    <span class="c">#comp_num = hat_W[spat_comp_ind] / spat_comp_power**(2)</span>
                    <span class="c">#comp_den = 1 / spat_comp_power</span>
                    
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;TB&#39;</span><span class="p">]):</span>
                        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">],</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TB&#39;</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">H</span> <span class="o">=</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">]</span>
                        
                    <span class="n">FW_H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;FW&#39;</span><span class="p">],</span> <span class="n">H</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                    
                    <span class="c"># denominator + correlation penalization</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambdaCorr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">corrPen</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">lambdaCorr</span>
                            <span class="o">*</span> <span class="n">spat_comp_pow_minus</span> <span class="c">#np.maximum(spat_comp_powers,</span>
                            <span class="c">#           eps)</span>
                            <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">spat_comp_powers</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
                            <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">corrPen</span> <span class="o">=</span> <span class="mf">0.</span>
                    
                    <span class="n">comp_den</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">other_fact_power</span> <span class="o">*</span> 
                               <span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">spat_comp_power</span> <span class="o">+</span>
                                <span class="n">corrPen</span><span class="p">),</span>
                               <span class="n">FW_H</span><span class="p">))</span>
                    <span class="c"># numerator</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambdaCorr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">corrPen</span> <span class="o">*=</span> <span class="mi">2</span> <span class="o">*</span><span class="p">(</span>
                            <span class="n">spat_comp_power</span>
                            <span class="o">/</span> <span class="n">spat_comp_powers</span>
                            <span class="p">)</span>
                    <span class="n">comp_num</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">((</span><span class="n">hat_W</span><span class="p">[</span><span class="n">spat_comp_ind</span><span class="p">]</span>
                                <span class="o">/</span> <span class="p">(</span><span class="n">spat_comp_power</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                                <span class="c"># np.maximum(spat_comp_power**(2), eps)</span>
                                <span class="o">+</span> <span class="n">corrPen</span><span class="p">)</span>
                               <span class="o">*</span> <span class="n">other_fact_power</span><span class="p">,</span>
                               <span class="n">FW_H</span><span class="p">))</span>
                    
                    <span class="n">factor</span><span class="p">[</span><span class="s">&#39;FB&#39;</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span>
                        <span class="n">comp_num</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">comp_den</span><span class="p">,</span> <span class="n">eps</span><span class="p">))</span> <span class="o">**</span> <span class="n">omega</span>
                    <span class="k">del</span> <span class="n">comp_num</span><span class="p">,</span> <span class="n">comp_den</span><span class="p">,</span> <span class="n">spat_comp_power</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">FW_H</span>
                    
                <span class="c"># update FW - freq weight</span>
                <span class="k">if</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;FW_frdm_prior&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;free&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                        <span class="k">print</span> <span class="s">&quot;    Updating frequency weights </span><span class="si">%d</span><span class="s">-</span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span><span class="p">(</span>
                            <span class="n">spec_comp_ind</span><span class="p">,</span> <span class="n">fact_ind</span><span class="p">)</span>
                    <span class="n">spat_comp_power</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">comp_spat_comp_power</span><span class="p">(</span>
                                <span class="n">spat_comp_ind</span><span class="p">,</span>
                                <span class="n">spec_comp_ind</span><span class="o">=</span><span class="p">[</span><span class="n">spec_comp_ind</span><span class="p">]),</span>
                            <span class="n">eps</span><span class="p">)</span>
                        <span class="p">)</span>
                    
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;TB&#39;</span><span class="p">]):</span>
                        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">],</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TB&#39;</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">H</span> <span class="o">=</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">]</span>
                        
                    <span class="c"># denominator + correlation penalization</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambdaCorr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">corrPen</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">lambdaCorr</span>
                            <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">spat_comp_pow_minus</span><span class="p">,</span><span class="c">#-spat_comp_power,</span>
                                         <span class="n">eps</span><span class="p">)</span>
                            <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">spat_comp_powers</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
                            <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">corrPen</span> <span class="o">=</span> <span class="mf">0.</span>
                    <span class="n">comp_den</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;FB&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                               <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">other_fact_power</span> <span class="o">*</span> 
                                      <span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">spat_comp_power</span> <span class="o">+</span>
                                       <span class="n">corrPen</span><span class="p">),</span>
                                      <span class="c">#other_fact_power /</span>
                                      <span class="c">#spat_comp_power,</span>
                                      <span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
                        <span class="p">)</span>
                    
                    <span class="c"># numerator</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambdaCorr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span><span class="c"># </span>
                        <span class="n">corrPen</span> <span class="o">*=</span> <span class="mi">2</span> <span class="o">*</span><span class="p">(</span>
                            <span class="n">spat_comp_power</span>
                            <span class="o">/</span> <span class="n">spat_comp_powers</span>
                            <span class="p">)</span>
                    <span class="n">comp_num</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;FB&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                               <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">((</span><span class="n">hat_W</span><span class="p">[</span><span class="n">spat_comp_ind</span><span class="p">]</span>
                                       <span class="o">/</span> <span class="p">(</span><span class="n">spat_comp_power</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="c">#np.maximum(spat_comp_power**2,eps)</span>
                                       <span class="o">+</span> <span class="n">corrPen</span><span class="p">)</span>
                                      <span class="o">*</span> <span class="n">other_fact_power</span><span class="p">,</span>
                                      <span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
                        <span class="p">)</span>
                    <span class="n">factor</span><span class="p">[</span><span class="s">&#39;FW&#39;</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span>
                        <span class="n">comp_num</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">comp_den</span><span class="p">,</span> <span class="n">eps</span><span class="p">))</span> <span class="o">**</span> <span class="n">omega</span>
                    <span class="k">del</span> <span class="n">comp_num</span><span class="p">,</span> <span class="n">comp_den</span><span class="p">,</span> <span class="n">spat_comp_power</span><span class="p">,</span> <span class="n">H</span>
                    
                <span class="c"># update TW - time weights</span>
                <span class="k">if</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_frdm_prior&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;free&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_constr&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;NMF&#39;</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                            <span class="k">print</span> <span class="s">&quot;    Updating time weights </span><span class="si">%d</span><span class="s">-</span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span><span class="p">(</span>
                                <span class="n">spec_comp_ind</span><span class="p">,</span> <span class="n">fact_ind</span><span class="p">)</span>
                        <span class="n">spat_comp_power</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">comp_spat_comp_power</span><span class="p">(</span>
                                    <span class="n">spat_comp_ind</span><span class="p">,</span>
                                    <span class="n">spec_comp_ind</span><span class="o">=</span><span class="p">[</span><span class="n">spec_comp_ind</span><span class="p">]),</span>
                                <span class="n">eps</span><span class="p">)</span>
                            <span class="p">)</span>
                        
                        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;FB&#39;</span><span class="p">],</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;FW&#39;</span><span class="p">])</span>
                        
                        <span class="c"># correlation penalization</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambdaCorr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">corrPen</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">lambdaCorr</span>
                                <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">spat_comp_pow_minus</span><span class="p">,</span>
                                             <span class="c"># - spat_comp_power,</span>
                                             <span class="n">eps</span><span class="p">)</span>
                                <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">spat_comp_powers</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
                                <span class="p">)</span>
                            <span class="c">##if self.verbose&gt;2: # DEBUG</span>
                            <span class="c">##    # pedantic :</span>
                            <span class="c">##    print &quot;correlation stuff&quot;,</span>
                            <span class="c">##    print corrPen.mean(), (1./spat_comp_power).mean()</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">corrPen</span> <span class="o">=</span> <span class="mf">0.</span>
                        
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;TB&#39;</span><span class="p">]):</span>
                            <span class="c"># denominator</span>
                            <span class="n">comp_den</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                       <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">other_fact_power</span> <span class="o">*</span> 
                                              <span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">spat_comp_power</span> <span class="o">+</span>
                                               <span class="n">corrPen</span><span class="p">),</span><span class="c">#other_fact_power / </span>
                                              <span class="c">#spat_comp_power,</span>
                                              <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TB&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                                       <span class="p">)</span>
                                <span class="p">)</span>
                            <span class="c"># numerator</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambdaCorr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span><span class="c"># corrPen &gt; 0:</span>
                                <span class="n">corrPen</span> <span class="o">*=</span> <span class="mi">2</span> <span class="o">*</span><span class="p">(</span>
                                    <span class="n">spat_comp_power</span>
                                    <span class="o">/</span> <span class="n">spat_comp_powers</span>
                                    <span class="p">)</span>
                            <span class="n">comp_num</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                       <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">((</span><span class="n">hat_W</span><span class="p">[</span><span class="n">spat_comp_ind</span><span class="p">]</span> <span class="o">/</span>
                                               <span class="p">(</span><span class="n">spat_comp_power</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="c">#np.maximum(spat_comp_power**2,</span>
                                               <span class="c">#            eps)</span>
                                               <span class="o">+</span> <span class="n">corrPen</span><span class="p">)</span>
                                              <span class="o">*</span> <span class="n">other_fact_power</span><span class="p">,</span>
                                              <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TB&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                                       <span class="p">)</span>
                                <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c"># denominator</span>
                            <span class="n">comp_den</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                       <span class="n">other_fact_power</span> <span class="o">*</span> 
                                       <span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">spat_comp_power</span> <span class="o">+</span>
                                        <span class="n">corrPen</span><span class="p">),</span> <span class="c">#other_fact_power / </span>
                                       <span class="c">#spat_comp_power</span>
                                       <span class="p">)</span>
                                <span class="p">)</span>
                            <span class="c"># numerator</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambdaCorr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span><span class="c"># corrPen &gt; 0:</span>
                                <span class="n">corrPen</span> <span class="o">*=</span> <span class="mi">2</span> <span class="o">*</span><span class="p">(</span>
                                    <span class="n">spat_comp_power</span>
                                    <span class="o">/</span> <span class="n">spat_comp_powers</span>
                                    <span class="p">)</span>
                            <span class="c">##if self.verbose&gt;5: # DEBUG to discover origin of NaN</span>
                            <span class="c">##    print &quot;corrPen&quot;, corrPen</span>
                            <span class="c">##    print &quot;other_fact_power&quot;, other_fact_power</span>
                            <span class="c">##    print &quot;hat_W&quot;, hat_W[spat_comp_ind]</span>
                            <span class="c">##    print &quot;squared&quot;, np.maximum(spat_comp_power**2,eps)</span>
                                
                            <span class="n">comp_num</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                       <span class="n">other_fact_power</span> <span class="o">*</span> <span class="p">(</span><span class="n">hat_W</span><span class="p">[</span><span class="n">spat_comp_ind</span><span class="p">]</span> <span class="o">/</span>
                                        <span class="p">(</span><span class="n">spat_comp_power</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                                        <span class="o">+</span> <span class="n">corrPen</span><span class="p">)</span>
                                       <span class="p">)</span>
                                <span class="p">)</span>
                            
                        <span class="c">##if self.verbose &gt; 8: #DEBUG</span>
                        <span class="c">##    print &quot;comp_num&quot;, comp_num</span>
                        <span class="c">##    print &quot;comp_den&quot;, comp_den</span>
                        <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span>
                            <span class="n">comp_num</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">comp_den</span><span class="p">,</span> <span class="n">eps</span><span class="p">))</span> <span class="o">**</span> <span class="n">omega</span>
                        <span class="k">del</span> <span class="n">comp_num</span><span class="p">,</span> <span class="n">comp_den</span><span class="p">,</span> <span class="n">spat_comp_power</span><span class="p">,</span> <span class="n">W</span>
                    <span class="k">elif</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_constr&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;GMM&#39;</span><span class="p">,</span> <span class="s">&#39;GSMM&#39;</span><span class="p">,</span> <span class="s">&#39;HMM&#39;</span><span class="p">,</span> <span class="s">&#39;SHMM&#39;</span><span class="p">):</span>
                        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                            <span class="s">&quot;The GMM/GSMM/HMM still needs to be adapted &quot;</span><span class="o">+</span>
                            <span class="s">&quot;to take into account the different factors. &quot;</span><span class="p">)</span>
                        <span class="n">nbfaccomps</span> <span class="o">=</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                            <span class="k">print</span> <span class="s">&quot;    Updating time weights, &quot;</span><span class="o">+</span>\
                                  <span class="s">&quot;discrete state-based constraints&quot;</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;TB&#39;</span><span class="p">]):</span>
                            <span class="n">errorMsg</span> <span class="o">=</span> <span class="s">&quot;In this implementation, &quot;</span><span class="o">+</span>\
                                       <span class="s">&quot;as in Ozerov&#39;s, non-trivial &quot;</span><span class="o">+</span>\
                                       <span class="s">&quot;time blobs TB is incompatible with &quot;</span><span class="o">+</span>\
                                       <span class="s">&quot;discrete state-based constraints for&quot;</span><span class="o">+</span>\
                                       <span class="s">&quot; the time weights TW&quot;</span>
                            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">errorMsg</span><span class="p">)</span>
                        
                        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="s">&#39;TW_all&#39;</span> <span class="ow">in</span> <span class="n">factor</span><span class="p">):</span>
                            <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_all&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nbfaccomps</span><span class="p">),</span>
                                         <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
                                <span class="p">)</span>
                            
                        <span class="k">if</span> <span class="s">&#39;TW_DP_params&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">factor</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_constr&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;GMM&#39;</span><span class="p">,</span> <span class="s">&#39;GSMM&#39;</span><span class="p">):</span>
                                <span class="c"># prior probabilities</span>
                                <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_DP_params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nbfaccomps</span><span class="p">)</span> <span class="o">/</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="n">nbfaccomps</span><span class="p">))</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="c"># transition probabilities</span>
                                <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_DP_params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="n">nbfaccomps</span><span class="p">,</span> <span class="n">nbfaccomps</span><span class="p">])</span> <span class="o">/</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="n">nbfaccomps</span><span class="p">))</span>
                                
                        <span class="k">if</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_constr&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;GMM&#39;</span><span class="p">,</span> <span class="s">&#39;HMM&#39;</span><span class="p">)</span> <span class="ow">and</span> \
                               <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_all&#39;</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">1</span> <span class="ow">or</span> \
                                <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_all&#39;</span><span class="p">])</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">):</span>
                            <span class="n">factor</span><span class="p">[</span><span class="s">&#39;FB&#39;</span><span class="p">]</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_all&#39;</span><span class="p">])</span>
                            <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_all&#39;</span><span class="p">][:]</span> <span class="o">=</span> <span class="mf">1.</span>
                            
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                            <span class="k">print</span> <span class="s">&quot;    Computing the Itakura Saito distance&quot;</span><span class="o">+</span>\
                                  <span class="s">&quot; matrix&quot;</span>
                        <span class="n">ISdivMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nbfaccomps</span><span class="p">,</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">])</span>
                        <span class="k">for</span> <span class="n">compnb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbfaccomps</span><span class="p">):</span>
                            <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">][:]</span> <span class="o">=</span> <span class="mi">0</span>
                            <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">][</span><span class="n">compnb</span><span class="p">]</span> <span class="o">=</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_all&#39;</span><span class="p">][</span><span class="n">compnb</span><span class="p">]</span>
                            
                            <span class="k">if</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_constr&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;GMM&#39;</span><span class="p">,</span> <span class="s">&#39;HMM&#39;</span><span class="p">):</span>
                                <span class="c"># re-estimating the weights for discrete</span>
                                <span class="c"># state model with the constraint on the</span>
                                <span class="c"># single state presence active.</span>
                                <span class="c"># NB: for GMM and HMM, these weights are</span>
                                <span class="c">#     assumed to be 1</span>
                                <span class="n">spat_comp_power</span> <span class="o">=</span> <span class="p">(</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">comp_spat_comp_power</span><span class="p">(</span>
                                            <span class="n">spat_comp_ind</span><span class="p">,</span>
                                            <span class="n">spec_comp_ind</span><span class="o">=</span><span class="p">[</span><span class="n">spec_comp_ind</span><span class="p">],),</span>
                                        <span class="n">eps</span><span class="p">)</span>
                                    <span class="p">)</span>
                                 
                                <span class="c"># NMF like updating for estimating the weight</span>
                                <span class="n">Wbasis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;FB&#39;</span><span class="p">],</span>
                                                <span class="n">factor</span><span class="p">[</span><span class="s">&#39;FW&#39;</span><span class="p">][:,</span><span class="n">compnb</span><span class="p">])</span>
                                <span class="n">comp_num</span> <span class="o">=</span> <span class="p">(</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Wbasis</span><span class="p">,</span>
                                           <span class="n">hat_W</span><span class="p">[</span><span class="n">spat_comp_ind</span><span class="p">]</span> <span class="o">/</span>
                                           <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">spat_comp_power</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">eps</span><span class="p">))</span>
                                    <span class="p">)</span>
                                <span class="n">comp_den</span> <span class="o">=</span> <span class="p">(</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Wbasis</span><span class="p">,</span>
                                           <span class="mi">1</span> <span class="o">/</span> <span class="n">spat_comp_power</span><span class="p">)</span>
                                    <span class="p">)</span>
                                
                                <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">][</span><span class="n">compnb</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span>
                                    <span class="n">comp_num</span> <span class="o">/</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">comp_den</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
                                    <span class="p">)</span> <span class="o">**</span> <span class="n">omega</span>
                                
                                <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_all&#39;</span><span class="p">][</span><span class="n">compnb</span><span class="p">]</span><span class="o">=</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">][</span><span class="n">compnb</span><span class="p">]</span>
                                
                                <span class="k">del</span> <span class="n">comp_num</span><span class="p">,</span> <span class="n">comp_den</span><span class="p">,</span> <span class="n">spat_comp_power</span>
                                
                            <span class="c"># ratio to compute IS divergence between expected</span>
                            <span class="c"># variance hat_W and the spatial component</span>
                            <span class="c"># with the discrete state restriction</span>
                            <span class="n">spat_comp_power</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">comp_spat_comp_power</span><span class="p">(</span><span class="n">spat_comp_ind</span><span class="p">),</span>
                                <span class="n">eps</span><span class="p">)</span>
                                <span class="p">)</span>
                            
                            <span class="n">W_V_ratio</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">hat_W</span><span class="p">[</span><span class="n">spat_comp_ind</span><span class="p">]</span> <span class="o">/</span>
                                <span class="n">spat_comp_power</span><span class="p">)</span>
                            
                            <span class="n">ISdivMatrix</span><span class="p">[</span><span class="n">compnb</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">W_V_ratio</span>
                                       <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">W_V_ratio</span><span class="p">,</span> <span class="n">eps</span><span class="p">))</span>
                                       <span class="o">-</span> <span class="mi">1</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                                <span class="p">)</span>
                            
                            <span class="k">del</span> <span class="n">W_V_ratio</span><span class="p">,</span> <span class="n">spat_comp_power</span>
                        
                        <span class="c"># decode the state sequence that minimizes the</span>
                        <span class="c"># track in the IS div matrix, with best</span>
                        <span class="c"># trade-off with the provided TW_DP_params</span>
                        <span class="c"># (temporal constraints)</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                            <span class="k">print</span> <span class="s">&quot;    Decoding the state sequence&quot;</span>
                        <span class="k">if</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_constr&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;GMM&#39;</span><span class="p">,</span> <span class="s">&#39;GSMM&#39;</span><span class="p">):</span>
                            <span class="n">active_state_seq</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span>
                                    <span class="n">ISdivMatrix</span> <span class="o">-</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
                                        <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_DP_params&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)),</span>
                                    <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                                <span class="p">)</span>
                            <span class="k">del</span> <span class="n">ISdivMatrix</span>
                        <span class="k">elif</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_constr&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;HMM&#39;</span><span class="p">,</span> <span class="s">&#39;SHMM&#39;</span><span class="p">):</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                                <span class="k">print</span> <span class="s">&quot;        Viterbi algorithm to &quot;</span><span class="o">+</span>\
                                      <span class="s">&quot;determine the active state sequence&quot;</span>
                            <span class="n">accumulateVec</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">ISdivMatrix</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">nbfaccomps</span><span class="p">)</span>
                                <span class="p">)</span>
                            <span class="n">antecedentMat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nbfaccomps</span><span class="p">,</span>
                                                      <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">],</span>
                                                     <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">):</span>
                                <span class="n">tmpMat</span> <span class="o">=</span> <span class="p">(</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">accumulateVec</span><span class="p">)</span> <span class="o">-</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_DP_params&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">eps</span><span class="p">))</span>
                                
                                <span class="n">antecedentMat</span><span class="p">[:,</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">tmpMat</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                                    <span class="p">)</span>
                                <span class="n">accumulateVec</span> <span class="o">+=</span> <span class="p">(</span>
                                    <span class="n">tmpMat</span><span class="p">[</span><span class="n">antecedentMat</span><span class="p">[:,</span><span class="n">n</span><span class="p">],</span>
                                           <span class="nb">range</span><span class="p">(</span><span class="n">nbfaccomps</span><span class="p">)]</span> <span class="o">+</span> 
                                    <span class="n">ISdivMatrix</span><span class="p">[:,</span><span class="n">n</span><span class="p">]</span>
                                    <span class="p">)</span>
                                <span class="c"># to avoid overflow?</span>
                                <span class="n">accumulateVec</span> <span class="o">-=</span> <span class="n">accumulateVec</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                            
                            <span class="k">del</span> <span class="n">tmpMat</span>
                            
                            <span class="n">active_state_seq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">,</span>
                                                        <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
                            <span class="n">active_state_seq</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">accumulateVec</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">framenb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                                <span class="n">active_state_seq</span><span class="p">[</span><span class="n">framenb</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                                    <span class="n">antecedentMat</span><span class="p">[</span><span class="n">active_state_seq</span><span class="p">[</span><span class="n">framenb</span><span class="p">],</span>
                                                  <span class="n">framenb</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                                    <span class="p">)</span>
                            
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                                <span class="s">&quot;No implementation for time constraint other &quot;</span><span class="o">+</span>
                                <span class="s">&quot;than GMM, GSMM, HMM and SHMM&quot;</span><span class="p">)</span>
                        
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                            <span class="k">print</span> <span class="s">&quot;    Update Time Weights&quot;</span>
                            
                        <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">][:]</span> <span class="o">=</span> <span class="mf">0.</span>
                        <span class="k">for</span> <span class="n">framenb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">):</span>
                            <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">][</span><span class="n">active_state_seq</span><span class="p">[</span><span class="n">framenb</span><span class="p">],</span><span class="n">framenb</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_all&#39;</span><span class="p">][</span><span class="n">active_state_seq</span><span class="p">[</span><span class="n">framenb</span><span class="p">],</span>
                                                 <span class="n">framenb</span><span class="p">]</span>
                                <span class="p">)</span>
                            
                        <span class="k">if</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_DP_frdm_prior&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;free&#39;</span><span class="p">:</span>
                            <span class="k">print</span> <span class="s">&quot;    Updating the transition probabilities&quot;</span>
                            <span class="k">if</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_constr&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;GMM&#39;</span><span class="p">,</span> <span class="s">&#39;GSMM&#39;</span><span class="p">):</span>
                                <span class="k">for</span> <span class="n">compnb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbfaccomps</span><span class="p">):</span>
                                    <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_DP_params&#39;</span><span class="p">][</span><span class="n">compnb</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                                        <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">active_state_seq</span><span class="o">==</span><span class="n">compnb</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.</span> <span class="o">/</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span>
                                        <span class="p">)</span>
                            <span class="k">elif</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_constr&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;HMM&#39;</span><span class="p">,</span> <span class="s">&#39;SHMM&#39;</span><span class="p">):</span>
                                <span class="k">for</span> <span class="n">prevstate</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbfaccomps</span><span class="p">):</span>
                                    <span class="n">upd_den</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                                        <span class="n">active_state_seq</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">prevstate</span><span class="p">)</span>
                                    <span class="k">if</span> <span class="n">upd_den</span><span class="p">:</span>
                                        <span class="k">for</span> <span class="n">nextstate</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbfaccomps</span><span class="p">):</span>
                                            <span class="n">upd_num</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                                                <span class="p">(</span><span class="n">active_state_seq</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span>
                                                 <span class="n">prevstate</span><span class="p">)</span> <span class="o">*</span>
                                                <span class="p">(</span><span class="n">active_state_seq</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">==</span>
                                                 <span class="n">nextstate</span><span class="p">))</span>
                                            <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_DP_params&#39;</span><span class="p">][</span><span class="n">prevstate</span><span class="p">,</span>
                                                                   <span class="n">nextstate</span><span class="p">]</span><span class="o">=</span><span class="p">(</span>
                                                <span class="n">upd_num</span> <span class="o">/</span> <span class="n">upd_den</span>
                                                <span class="p">)</span> <span class="c"># TODO: check this part</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                                    <span class="s">&quot;Required time constraints not &quot;</span><span class="o">+</span>
                                    <span class="s">&quot;implemented.&quot;</span><span class="p">)</span>
                        
                <span class="c"># update TB = time basis</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;TB&#39;</span><span class="p">])</span> <span class="ow">and</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TB_frdm_prior&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;free&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;    Updating Time basis&quot;</span>
                    <span class="n">spat_comp_power</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">comp_spat_comp_power</span><span class="p">(</span>
                                <span class="n">spat_comp_ind</span><span class="p">,</span>
                                <span class="n">spec_comp_ind</span><span class="o">=</span><span class="p">[</span><span class="n">spec_comp_ind</span><span class="p">],),</span>
                            <span class="n">eps</span><span class="p">)</span>
                        <span class="p">)</span>
                    <span class="n">W</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;FB&#39;</span><span class="p">],</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;FW&#39;</span><span class="p">]),</span>
                               <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">])</span>
                        <span class="p">)</span>
                    <span class="c"># denominator + correlation penalization</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambdaCorr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">corrPen</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">lambdaCorr</span>
                            <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">spat_comp_pow_minus</span><span class="p">,</span><span class="c"># - spat_comp_power,</span>
                                         <span class="n">eps</span><span class="p">)</span>
                            <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">spat_comp_powers</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
                            <span class="p">)</span>
                        <span class="c">##if self.verbose&gt;2:#DEBUG</span>
                        <span class="c">##    # pedantic :</span>
                        <span class="c">##    print corrPen.mean(), (1./spat_comp_power).mean()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">corrPen</span> <span class="o">=</span> <span class="mf">0.</span>
                    <span class="n">comp_den</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                               <span class="n">other_fact_power</span> <span class="o">*</span> 
                               <span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">spat_comp_power</span> <span class="o">+</span>
                                <span class="n">corrPen</span><span class="p">))</span>
                        <span class="p">)</span>
                    <span class="c"># numerator</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambdaCorr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span><span class="c"># corrPen &gt; 0:</span>
                        <span class="n">corrPen</span> <span class="o">*=</span> <span class="mi">2</span> <span class="o">*</span><span class="p">(</span>
                            <span class="n">spat_comp_power</span>
                            <span class="o">/</span> <span class="n">spat_comp_powers</span>
                            <span class="p">)</span>
                    <span class="n">comp_num</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                               <span class="p">(</span><span class="n">hat_W</span><span class="p">[</span><span class="n">spat_comp_ind</span><span class="p">]</span>
                                <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">spat_comp_power</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
                                <span class="o">+</span> <span class="n">corrPen</span><span class="p">)</span>
                               <span class="o">*</span> <span class="n">other_fact_power</span><span class="p">)</span>
                        <span class="p">)</span>
                    <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TB&#39;</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span>
                        <span class="n">comp_num</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">comp_den</span><span class="p">,</span> <span class="n">eps</span><span class="p">))</span> <span class="o">**</span> <span class="n">omega</span>
                    <span class="k">del</span> <span class="n">comp_num</span><span class="p">,</span> <span class="n">comp_den</span><span class="p">,</span> <span class="n">spat_comp_power</span><span class="p">,</span> <span class="n">W</span>
    </div>
<div class="viewcode-block" id="FASST.renormalize_parameters"><a class="viewcode-back" href="../../reference/audiomodel.html#pyfasst.audioModel.FASST.renormalize_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">renormalize_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;renormalize_parameters</span>
<span class="sd">        </span>
<span class="sd">        Re-normalize the components</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;    re-normalizing components&quot;</span>
        <span class="k">pass</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;         normalizing spatial components...&quot;</span>
        <span class="c"># renormalize spatial components</span>
        <span class="n">Kspat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">)</span>
        <span class="n">spat_global_energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Kspat</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">spat_ind</span><span class="p">,</span> <span class="n">spat_comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">spat_global_energy</span><span class="p">[</span><span class="n">spat_ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">mean</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">spat_comp</span><span class="p">[</span><span class="s">&#39;params&#39;</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">spat_comp</span><span class="p">[</span><span class="s">&#39;params&#39;</span><span class="p">]</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">spat_global_energy</span><span class="p">[</span><span class="n">spat_ind</span><span class="p">])</span>
            
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">5</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;spat_global_energy&quot;</span><span class="p">,</span> <span class="n">spat_global_energy</span>
        
        <span class="c"># renormalize spectral components</span>
        <span class="n">Kspec</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">spec_ind</span><span class="p">,</span> <span class="n">spec_comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">global_energy</span> <span class="o">=</span> <span class="n">spat_global_energy</span><span class="p">[</span><span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;spat_comp_ind&#39;</span><span class="p">]]</span>
            
            <span class="n">nbfactors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;factor&#39;</span><span class="p">])</span>
            
            <span class="k">for</span> <span class="n">fact_ind</span><span class="p">,</span> <span class="n">factor</span> <span class="ow">in</span> <span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;factor&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">factor</span><span class="p">[</span><span class="s">&#39;FB&#39;</span><span class="p">]</span> <span class="o">*=</span> <span class="n">global_energy</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;FB&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="c">#.mean(axis=0)</span>
                <span class="n">w</span><span class="p">[</span><span class="n">w</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
                <span class="n">factor</span><span class="p">[</span><span class="s">&#39;FB&#39;</span><span class="p">]</span> <span class="o">/=</span> <span class="n">w</span>
                <span class="n">factor</span><span class="p">[</span><span class="s">&#39;FW&#39;</span><span class="p">]</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_constr&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;GMM&#39;</span><span class="p">,</span> <span class="s">&#39;HMM&#39;</span><span class="p">):</span>
                    <span class="n">w</span> <span class="o">=</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;FW&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">w</span><span class="p">[</span><span class="n">w</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
                    <span class="n">factor</span><span class="p">[</span><span class="s">&#39;FW&#39;</span><span class="p">]</span> <span class="o">/=</span> <span class="n">w</span>
                    <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">]</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
                    <span class="c"># Only testing this: in order to avoid</span>
                    <span class="c"># big crash, if for one factor, everything in TW</span>
                    <span class="c"># turns out to get 0, then &quot;restart&quot; it with random</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">:</span>
                        <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="o">*</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
                        <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">]</span> <span class="o">*=</span> <span class="mf">1e3</span> <span class="o">*</span> <span class="n">eps</span> <span class="c"># so it s not too small</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                            <span class="k">print</span> <span class="s">&quot;    renorm: reinitialized TW for spec&quot;</span><span class="p">,</span>
                            <span class="k">print</span> <span class="n">spec_ind</span><span class="p">,</span> <span class="s">&quot;factor&quot;</span><span class="p">,</span> <span class="n">fact_ind</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;TB&#39;</span><span class="p">]):</span>
                        <span class="n">w</span> <span class="o">=</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TB&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                        <span class="n">w</span><span class="p">[</span><span class="n">w</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
                        <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TB&#39;</span><span class="p">]</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
                        <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">]</span> <span class="o">*=</span> <span class="n">w</span>
                        
                    <span class="n">global_energy</span> <span class="o">=</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">fact_ind</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">nbfactors</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">]</span> <span class="o">/=</span> <span class="n">global_energy</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                        <span class="s">&quot;Temporal discrete state mngmt not done yet. &quot;</span><span class="p">)</span>
            </div>
<div class="viewcode-block" id="FASST.setComponentParameter"><a class="viewcode-back" href="../../reference/audiomodel.html#pyfasst.audioModel.FASST.setComponentParameter">[docs]</a>    <span class="k">def</span> <span class="nf">setComponentParameter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newValue</span><span class="p">,</span> <span class="n">spec_ind</span><span class="p">,</span> <span class="n">fact_ind</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                              <span class="n">partLabel</span><span class="o">=</span><span class="s">&#39;FB&#39;</span><span class="p">,</span> <span class="n">prior</span><span class="o">=</span><span class="s">&#39;free&#39;</span><span class="p">,</span>
                              <span class="n">keepDimensions</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A helper function to set a</span>
<span class="sd">        :py:attr:`FASST.spec_comp[spec_ind][&#39;factor&#39;][fact_ind][partLabel]` to</span>
<span class="sd">        the given value.</span>
<span class="sd">        </span>
<span class="sd">        TODO 20130522 finish this function to make it general purpose...</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">###### DEBUG #####</span>
        <span class="k">print</span> <span class="s">&quot;NOT IMPLEMENTED YET, PLEASE SET THE COMPONENTS DIRECTLY&quot;</span>
        <span class="k">pass</span>
        <span class="c">###### DEBUG #####</span>
        <span class="k">if</span> <span class="n">keepDimenstions</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">newValue</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comp</span><span class="p">[</span><span class="n">spec_ind</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="n">fact_ind</span><span class="p">][</span><span class="n">partLabel</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;the provided value does not have the correct&quot;</span><span class="o">+</span>
                                 <span class="s">&quot; size:&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">newValue</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">+</span>
                                 <span class="s">&quot; instead of &quot;</span><span class="o">+</span>
                                 <span class="nb">str</span><span class="p">(</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">spec_comp</span><span class="p">[</span><span class="n">spec_ind</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="n">fact_ind</span><span class="p">][</span><span class="n">partLabel</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># nightmare of error checking for sizes... </span>
            <span class="k">if</span> <span class="n">partLabel</span> <span class="o">==</span> <span class="s">&#39;FB&#39;</span><span class="p">:</span>
                <span class="n">newShape</span> <span class="o">=</span> <span class="n">newValue</span><span class="o">.</span><span class="n">shape</span>
                <span class="n">oldShape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_comp</span><span class="p">[</span>
                    <span class="n">spec_ind</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="n">fact_ind</span><span class="p">][</span><span class="s">&#39;FB&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
                <span class="k">if</span> <span class="n">newShape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;FB: cannot change dimension of &quot;</span><span class="o">+</span>
                                     <span class="s">&quot;signal representation.&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">newShape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">oldShape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                        <span class="k">print</span> <span class="s">&quot;    Changing the Freq Weights for FB:&quot;</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">spec_comp</span><span class="p">[</span><span class="n">spec_ind</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="n">fact_ind</span><span class="p">][</span><span class="s">&#39;FB&#39;</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spec_comp</span><span class="p">[</span><span class="n">spec_ind</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="n">fact_ind</span><span class="p">][</span><span class="s">&#39;FB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">newValue</span>
            <span class="k">elif</span> <span class="n">partLabel</span> <span class="o">==</span> <span class="s">&#39;FW&#39;</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="n">partLabel</span> <span class="o">==</span> <span class="s">&#39;TW&#39;</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="n">partLabel</span> <span class="o">==</span> <span class="s">&#39;TB&#39;</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;No such thing as &quot;</span><span class="o">+</span>
                                 <span class="n">partLabel</span><span class="o">+</span>
                                 <span class="s">&quot; in components!&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec_comp</span><span class="p">[</span><span class="n">spec_ind</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="n">fact_ind</span><span class="p">][</span>
            <span class="n">partLabel</span><span class="o">+</span><span class="s">&#39;_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">prior</span>
                </div>
<div class="viewcode-block" id="FASST.initialize_all_spec_comps_with_NMF"><a class="viewcode-back" href="../../reference/audiomodel.html#pyfasst.audioModel.FASST.initialize_all_spec_comps_with_NMF">[docs]</a>    <span class="k">def</span> <span class="nf">initialize_all_spec_comps_with_NMF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                           <span class="n">sameInitAll</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                           <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes an NMF on the one-channel mix (averaging diagonal</span>
<span class="sd">        of self.Cx, which are the power spectra of the corresponding</span>
<span class="sd">        channel)</span>

<span class="sd">        .. math::</span>
<span class="sd">        </span>
<span class="sd">            C_x \\approx W H</span>
<span class="sd">        </span>
<span class="sd">        then, for all spec_comp in self.spec_comps, we set::</span>
<span class="sd">        </span>
<span class="sd">            spec_comp[&#39;FB&#39;] = W</span>
<span class="sd">            spec_comp[&#39;TW&#39;] = H</span>
<span class="sd">            </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sameInitAll</span><span class="p">:</span>
            <span class="c"># initialize the components with the same parameters</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialize_all_spec_comps_with_NMF_same</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># initialize the components with individual params,</span>
            <span class="c"># in particular, initializing the NMF with the available</span>
            <span class="c"># components (but only with factor 0)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialize_all_spec_comps_with_NMF_indiv</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="FASST.initialize_all_spec_comps_with_NMF_indiv"><a class="viewcode-back" href="../../reference/audiomodel.html#pyfasst.audioModel.FASST.initialize_all_spec_comps_with_NMF_indiv">[docs]</a>    <span class="k">def</span> <span class="nf">initialize_all_spec_comps_with_NMF_indiv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                                                 <span class="n">updateFreqBasis</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                                 <span class="n">updateTimeWeight</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;initialize the spectral components with an NMF decomposition,</span>
<span class="sd">        with individual decomposition of the monophonic signal TF</span>
<span class="sd">        representation.</span>

<span class="sd">        TODO make keepFBind and keepTWind, in order to provide</span>
<span class="sd">        finer control on which indices are updated. Also requires</span>
<span class="sd">        a modified NMF decomposition function.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># list of the sizes of the 0th factors, of all components</span>
        <span class="n">nbSpecComps</span> <span class="o">=</span> <span class="p">[</span><span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;FB&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                       <span class="k">for</span> <span class="n">spec_comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
        <span class="n">totalNMFComps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">nbSpecComps</span><span class="p">)</span>
        
        <span class="c"># initializing the NMF FreqBasis (FB) and TimeWeight (TW)</span>
        <span class="c"># with the corresponding quantities in self.spec_comps:</span>
        <span class="n">FBinit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span> <span class="n">totalNMFComps</span><span class="p">])</span>
        <span class="n">TWinit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">totalNMFComps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">])</span>
        
        <span class="k">for</span> <span class="n">spec_ind</span><span class="p">,</span> <span class="n">spec_comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">ind_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">nbSpecComps</span><span class="p">[:</span><span class="n">spec_ind</span><span class="p">])</span>
            <span class="n">ind_stop</span> <span class="o">=</span> <span class="n">ind_start</span> <span class="o">+</span> <span class="n">nbSpecComps</span><span class="p">[</span><span class="n">spec_ind</span><span class="p">]</span>
            <span class="n">FBinit</span><span class="p">[:,</span><span class="n">ind_start</span><span class="p">:</span><span class="n">ind_stop</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;FB&#39;</span><span class="p">])</span>
            <span class="n">TWinit</span><span class="p">[</span><span class="n">ind_start</span><span class="p">:</span><span class="n">ind_stop</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TW&#39;</span><span class="p">])</span>
        
        <span class="c"># computing the monaural signal representation</span>
        <span class="c">#     summing the contributions over all the channels:</span>
        <span class="n">nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">channels</span>
        <span class="n">Cx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">chan</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nc</span><span class="p">):</span>
            <span class="c"># stored an &quot;efficient&quot; way, so index &quot;complicated&quot;:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="n">nc</span><span class="o">-</span><span class="n">chan</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">Cx</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
            
        <span class="n">Cx</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="n">nc</span><span class="p">)</span>
        
        <span class="n">W</span><span class="p">,</span> <span class="n">H</span> <span class="o">=</span> <span class="n">NMF_decomp_init</span><span class="p">(</span><span class="n">SX</span><span class="o">=</span><span class="n">Cx</span><span class="p">,</span> <span class="n">nbComps</span><span class="o">=</span><span class="n">totalNMFComps</span><span class="p">,</span>
                               <span class="n">niter</span><span class="o">=</span><span class="n">niter</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">,</span>
                               <span class="n">Winit</span><span class="o">=</span><span class="n">FBinit</span><span class="p">,</span> <span class="n">Hinit</span><span class="o">=</span><span class="n">TWinit</span><span class="p">,</span>
                               <span class="n">updateW</span><span class="o">=</span><span class="n">updateFreqBasis</span><span class="p">,</span>
                               <span class="n">updateH</span><span class="o">=</span><span class="n">updateTimeWeight</span><span class="p">)</span>
        
        <span class="c"># copy the result in the corresponding spec_comps:</span>
        <span class="k">for</span> <span class="n">spec_ind</span><span class="p">,</span> <span class="n">spec_comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">ind_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">nbSpecComps</span><span class="p">[:</span><span class="n">spec_ind</span><span class="p">])</span>
            <span class="n">ind_stop</span> <span class="o">=</span> <span class="n">ind_start</span> <span class="o">+</span> <span class="n">nbSpecComps</span><span class="p">[</span><span class="n">spec_ind</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">updateFreqBasis</span><span class="p">:</span>
                <span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;FB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
                        <span class="n">W</span><span class="p">[:,</span><span class="n">ind_start</span><span class="p">:</span><span class="n">ind_stop</span><span class="p">],</span>
                        <span class="n">eps</span><span class="p">)</span>
                    <span class="p">)</span>
            <span class="k">if</span> <span class="n">updateTimeWeight</span><span class="p">:</span>
                <span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TW&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span> 
                    <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">H</span><span class="p">[</span><span class="n">ind_start</span><span class="p">:</span><span class="n">ind_stop</span><span class="p">],</span><span class="n">eps</span><span class="p">))</span>
                
        <span class="bp">self</span><span class="o">.</span><span class="n">renormalize_parameters</span><span class="p">()</span>
    </div>
<div class="viewcode-block" id="FASST.initialize_all_spec_comps_with_NMF_same"><a class="viewcode-back" href="../../reference/audiomodel.html#pyfasst.audioModel.FASST.initialize_all_spec_comps_with_NMF_same">[docs]</a>    <span class="k">def</span> <span class="nf">initialize_all_spec_comps_with_NMF_same</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                                                <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize all the components with the same amplitude and spectral</span>
<span class="sd">        matrices `W` and `H`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;factor&#39;</span><span class="p">])</span><span class="o">==</span><span class="mi">1</span>
                       <span class="k">for</span> <span class="n">spec_comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="o">.</span><span class="n">values</span><span class="p">()]):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s">&quot;NMF init not implemented for multi factor models.&quot;</span><span class="p">)</span>
        
        <span class="n">nbSpecComps</span> <span class="o">=</span> <span class="p">[</span><span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;FB&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                       <span class="k">for</span> <span class="n">spec_comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
        <span class="n">nbComps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">nbSpecComps</span><span class="p">)</span>
        
        <span class="n">nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">channels</span>
        <span class="c"># computing the signal representation</span>
        <span class="n">Cx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">chan</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nc</span><span class="p">):</span>
            <span class="c"># stored an &quot;efficient&quot; way, so index &quot;complicated&quot;:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="n">nc</span><span class="o">-</span><span class="n">chan</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">Cx</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
            
        <span class="n">Cx</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="n">nc</span><span class="p">)</span>
        
        <span class="c"># computing NMF of Cx:</span>
        <span class="n">W</span><span class="p">,</span> <span class="n">H</span> <span class="o">=</span> <span class="n">NMF_decomposition</span><span class="p">(</span><span class="n">SX</span><span class="o">=</span><span class="n">Cx</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">,</span>
                                 <span class="n">nbComps</span><span class="o">=</span><span class="n">nbComps</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="n">niter</span><span class="p">)</span>
        
        <span class="c"># reordering so that most energy in first components</span>
        <span class="n">Hsum</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">indexSort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">Hsum</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">W</span><span class="p">[:,</span><span class="n">indexSort</span><span class="p">]</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">H</span><span class="p">[</span><span class="n">indexSort</span><span class="p">]</span>
        
        <span class="k">for</span> <span class="n">spec_comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">ncomp</span> <span class="o">=</span> <span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;FB&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;FB&#39;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">W</span><span class="p">[:,</span> <span class="p">:</span><span class="n">ncomp</span><span class="p">]</span>
            <span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TW&#39;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">H</span><span class="p">[:</span><span class="n">ncomp</span><span class="p">]</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">renormalize_parameters</span><span class="p">()</span>
    </div>
<div class="viewcode-block" id="FASST.initializeConvParams"><a class="viewcode-back" href="../../reference/audiomodel.html#pyfasst.audioModel.FASST.initializeConvParams">[docs]</a>    <span class="k">def</span> <span class="nf">initializeConvParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initMethod</span><span class="o">=</span><span class="s">&#39;demix&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;setting the spatial parameters</span>

<span class="sd">        :param str initMethod:</span>
<span class="sd">            initialization method. Can be either of: &#39;demix&#39;, &#39;rand&#39;.</span>
<span class="sd">            If &#39;demix&#39;, then the spatial parameters are initialized by the</span>
<span class="sd">            anechoic steering vector corresponding to the first directions</span>
<span class="sd">            estimated by the DEMIX algorithm [Arberet2010]_, using the</span>
<span class="sd">            algorithm implemented in :py:mod:`pyfasst.demixTF`.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">channels</span>
        <span class="k">for</span> <span class="n">spat_ind</span><span class="p">,</span> <span class="n">spat_comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">spat_comp</span><span class="p">[</span><span class="s">&#39;mix_type&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&#39;inst&#39;</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Spatial component </span><span class="si">%d</span><span class="s"> &quot;</span><span class="o">%</span><span class="n">spat_ind</span><span class="o">+</span>
                              <span class="s">&quot;already not instantaneous, overwriting...&quot;</span><span class="p">)</span>
            
            <span class="c"># spat_comp[&#39;time_dep&#39;] = &#39;indep&#39;</span>
            <span class="n">spat_comp</span><span class="p">[</span><span class="s">&#39;mix_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;conv&#39;</span>
            <span class="c"># spat_comp[&#39;frdm_prior&#39;] = &#39;free&#39;</span>
        
        <span class="k">if</span> <span class="n">initMethod</span> <span class="o">==</span> <span class="s">&#39;demix&#39;</span><span class="p">:</span>
            <span class="n">maxclusters</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">))</span>
            <span class="n">neighbours</span> <span class="o">=</span> <span class="mi">15</span>
            
            <span class="c"># default for demix to work best: #FIXME!!!</span>
            <span class="n">wlen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">demixParams</span><span class="p">[</span><span class="s">&#39;wlen&#39;</span><span class="p">]</span><span class="c"># 2048</span>
            <span class="n">hopsize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">demixParams</span><span class="p">[</span><span class="s">&#39;hopsize&#39;</span><span class="p">]</span><span class="c">#1024 </span>
            
            <span class="n">demixInst</span> <span class="o">=</span> <span class="n">demix</span><span class="o">.</span><span class="n">DEMIX</span><span class="p">(</span>
                <span class="n">audio</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span>
                <span class="n">nsources</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">),</span> <span class="c"># spatial comps for demix</span>
                <span class="n">wlen</span><span class="o">=</span><span class="n">wlen</span><span class="p">,</span>
                <span class="n">hopsize</span><span class="o">=</span><span class="n">hopsize</span><span class="p">,</span>
                <span class="n">neighbors</span><span class="o">=</span><span class="n">neighbours</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">,</span>
                <span class="n">maxclusters</span><span class="o">=</span><span class="n">maxclusters</span><span class="p">)</span>
            
            <span class="n">demixInst</span><span class="o">.</span><span class="n">comp_pcafeatures</span><span class="p">()</span>
            <span class="n">demixInst</span><span class="o">.</span><span class="n">comp_parameters</span><span class="p">()</span>
            <span class="n">demixInst</span><span class="o">.</span><span class="n">init_subpts_set</span><span class="p">()</span>
            <span class="n">demixInst</span><span class="o">.</span><span class="n">comp_clusters</span><span class="p">()</span>
            <span class="n">demixInst</span><span class="o">.</span><span class="n">refine_clusters</span><span class="p">()</span>
            
            <span class="c"># mixing parameters from DEMIX estimation:</span>
            <span class="c">#     results in an nsrc x nfreqs x nc array</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">demixInst</span><span class="o">.</span><span class="n">steeringVectorsFromCentroids</span><span class="p">()</span>
            <span class="k">del</span> <span class="n">demixInst</span>
        <span class="k">elif</span> <span class="s">&#39;rand&#39;</span> <span class="ow">in</span> <span class="n">initMethod</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">),</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                                <span class="n">nc</span><span class="p">,)</span>
                <span class="o">+</span> <span class="mi">1j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">),</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                                       <span class="n">nc</span><span class="p">,)</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Init method not implemented.&quot;</span><span class="p">)</span>
            
        <span class="c"># filling the spatial components:</span>
        <span class="k">for</span> <span class="n">nspat</span><span class="p">,</span> <span class="p">(</span><span class="n">spat_ind</span><span class="p">,</span> <span class="n">spat_comp</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">spat_comp_param_inst</span> <span class="o">=</span> <span class="n">spat_comp</span><span class="p">[</span><span class="s">&#39;params&#39;</span><span class="p">]</span>
            <span class="n">spat_comp</span><span class="p">[</span><span class="s">&#39;params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">nspat</span><span class="p">],</span>
                                            <span class="n">nc</span><span class="p">,</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">],</span>
                                           <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">nspat</span><span class="p">]):</span>
                <span class="n">spat_comp</span><span class="p">[</span><span class="s">&#39;params&#39;</span><span class="p">][</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">A</span><span class="p">[</span><span class="n">spat_ind</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
                    <span class="p">)</span>
    </div></div>
<div class="viewcode-block" id="MultiChanNMFInst_FASST"><a class="viewcode-back" href="../../reference/audiomodel.html#pyfasst.audioModel.MultiChanNMFInst_FASST">[docs]</a><span class="k">class</span> <span class="nc">MultiChanNMFInst_FASST</span><span class="p">(</span><span class="n">FASST</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">    This class implements the Multi-channel Non-Negative Matrix Factorisation</span>
<span class="sd">    (NMF)</span>
<span class="sd">    </span>
<span class="sd">    **Inputs:**</span>
<span class="sd">    </span>
<span class="sd">    :param audio:</span>
<span class="sd">        as in :py:class:`FASST`, `audio` is the filename of the file to be</span>
<span class="sd">        processed or directly a :py:class:`pyfasst.audioObject.AudioObject`</span>
<span class="sd">    :param integer nbComps:</span>
<span class="sd">        the number of desired sources/components</span>
<span class="sd">    :param integer nbNMFComps:</span>
<span class="sd">        the number of NMF components for each of the components.</span>
<span class="sd">        TODO: allow to pass a list so that the user can control the number of</span>
<span class="sd">        elements source by source, individually</span>
<span class="sd">    :param spatial_rank:</span>
<span class="sd">        the spatial rank of all the components. If it&#39;s a `nbComps`-long list,</span>
<span class="sd">        then `spatial_rank[n]` will be the spatial rank for the `n`-th source.</span>
<span class="sd">    :type spatial_rank: integer or list</span>
<span class="sd">    </span>
<span class="sd">    **Example:**</span>
<span class="sd">    </span>
<span class="sd">    ::</span>
<span class="sd">    </span>
<span class="sd">        &gt;&gt;&gt; import pyfasst.audioModel as am</span>
<span class="sd">        &gt;&gt;&gt; filename = &#39;data/tamy.wav&#39;</span>
<span class="sd">        &gt;&gt;&gt; # initialize the model</span>
<span class="sd">        &gt;&gt;&gt; model = am.MultiChanNMFInst_FASST(</span>
<span class="sd">                audio=filename,</span>
<span class="sd">                nbComps=2, nbNMFComps=32, spatial_rank=1,</span>
<span class="sd">                verbose=1, iter_num=50)</span>
<span class="sd">        &gt;&gt;&gt; # estimate the parameters</span>
<span class="sd">        &gt;&gt;&gt; log_lik = model.estim_param_a_post_model()</span>
<span class="sd">        &gt;&gt;&gt; # separate the sources using these parameters</span>
<span class="sd">        &gt;&gt;&gt; model.separate_spat_comps(dir_results=&#39;data/&#39;)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">audio</span><span class="p">,</span>
                 <span class="n">nbComps</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">nbNMFComps</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                 <span class="n">spatial_rank</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MultiChanNMFInst_FASST</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">audio</span><span class="o">=</span><span class="n">audio</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comp_transf_Cx</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span> <span class="o">=</span> <span class="n">nbComps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbNMFComps</span> <span class="o">=</span> <span class="n">nbNMFComps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">spatial_rank</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="mi">0</span><span class="p">],]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_structures</span><span class="p">()</span>
    
    <span class="k">def</span> <span class="nf">_initialize_structures</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c">#, nbComps, nbNMFComps, spatial_rank):</span>
        <span class="sd">&quot;&quot;&quot;Initializes the structures: spatial components (instantaneous) and</span>
<span class="sd">        spectral components (1 factor, with NMF simple structure).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">channels</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span><span class="p">):</span>
            <span class="c"># initialize the spatial component</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;time_dep&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;indep&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;mix_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;inst&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;free&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">nc</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="c"># spreading the sources evenly for init on stereo</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">((</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">+</span>
                              <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.01</span><span class="p">),</span>
                              <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">((</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">+</span>
                              <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)]))</span>
            
            <span class="c"># initialize single factor spectral component</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;spat_comp_ind&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;FB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="mf">0.75</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">nbNMFComps</span><span class="p">))</span> <span class="o">+</span>
                <span class="mf">0.25</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;FW&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbNMFComps</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TW&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="mf">0.75</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbNMFComps</span><span class="p">,</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">))</span> <span class="o">+</span>
                <span class="mf">0.25</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;FB_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;free&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;FW_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;fixed&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TW_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;free&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TB_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TW_constr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;NMF&#39;</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">renormalize_parameters</span><span class="p">()</span>
        
<div class="viewcode-block" id="MultiChanNMFInst_FASST.setSpecCompFB"><a class="viewcode-back" href="../../reference/audiomodel.html#pyfasst.audioModel.MultiChanNMFInst_FASST.setSpecCompFB">[docs]</a>    <span class="k">def</span> <span class="nf">setSpecCompFB</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">compNb</span><span class="p">,</span> <span class="n">FB</span><span class="p">,</span> <span class="n">FB_frdm_prior</span><span class="o">=</span><span class="s">&#39;fixed&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">        sets the spectral component&#39;s frequency basis.</span>

<span class="sd">        :param integer compNb:</span>
<span class="sd">            the component to be initialized</span>
<span class="sd">        :param numpy.ndarray FB:</span>
<span class="sd">            the initial array to put in</span>
<span class="sd">            :py:attr:`spec_comp[compNb][&#39;factor&#39;][0][&#39;FB&#39;]`</span>
<span class="sd">        :param str FB_frdm_prior:</span>
<span class="sd">            either &#39;fixed&#39; or &#39;free&#39;. </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">speccomp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">compNb</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span> <span class="o">!=</span> <span class="n">FB</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s">&quot;Size of provided FB is not consistent&quot;</span><span class="o">+</span>
                                 <span class="s">&quot; with inner attributes&quot;</span><span class="p">)</span>
        <span class="n">speccomp</span><span class="p">[</span><span class="s">&#39;FB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">FB</span><span class="p">)</span>
        <span class="n">ncomp</span> <span class="o">=</span> <span class="n">FB</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="n">speccomp</span><span class="p">[</span><span class="s">&#39;FW&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">ncomp</span><span class="p">)</span>
        <span class="n">speccomp</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="mf">0.75</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">ncomp</span><span class="p">,</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">))</span> <span class="o">+</span>
                <span class="mf">0.25</span><span class="p">)</span>
        <span class="n">speccomp</span><span class="p">[</span><span class="s">&#39;FB_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">FB_frdm_prior</span>
</div></div>
<div class="viewcode-block" id="MultiChanNMFConv"><a class="viewcode-back" href="../../reference/audiomodel.html#pyfasst.audioModel.MultiChanNMFConv">[docs]</a><span class="k">class</span> <span class="nc">MultiChanNMFConv</span><span class="p">(</span><span class="n">MultiChanNMFInst_FASST</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">    Takes the multichannel NMF instantaneous class, and makes it</span>
<span class="sd">    convolutive!</span>
<span class="sd">    </span>
<span class="sd">    Simply adds a method :py:meth:`makeItConvolutive` in order to transform</span>
<span class="sd">    instantaneous mixing parameters into convolutive ones.</span>

<span class="sd">    **Example:**</span>
<span class="sd">    </span>
<span class="sd">    ::</span>
<span class="sd">  </span>
<span class="sd">        &gt;&gt;&gt; import pyfasst.audioModel as am</span>
<span class="sd">        &gt;&gt;&gt; filename = &#39;data/tamy.wav&#39;</span>
<span class="sd">        &gt;&gt;&gt; # initialize the model</span>
<span class="sd">        &gt;&gt;&gt; model = am.MultiChanNMFConv(</span>
<span class="sd">                audio=filename,</span>
<span class="sd">                nbComps=2, nbNMFComps=32, spatial_rank=1,</span>
<span class="sd">                verbose=1, iter_num=50)</span>
<span class="sd">        &gt;&gt;&gt; # to be more flexible, the user _has to_ make the parameters</span>
<span class="sd">        &gt;&gt;&gt; # convolutive by hand. This way, she can also start to estimate</span>
<span class="sd">        &gt;&gt;&gt; # parameters in an instantaneous setting, as an initialization, </span>
<span class="sd">        &gt;&gt;&gt; # and only after &quot;upgrade&quot; to a convolutive setting:</span>
<span class="sd">        &gt;&gt;&gt; model.makeItConvolutive()</span>
<span class="sd">        &gt;&gt;&gt; # estimate the parameters</span>
<span class="sd">        &gt;&gt;&gt; log_lik = model.estim_param_a_post_model()</span>
<span class="sd">        &gt;&gt;&gt; # separate the sources using these parameters</span>
<span class="sd">        &gt;&gt;&gt; model.separate_spat_comps(dir_results=&#39;data/&#39;)</span>

<span class="sd">    The following example shows the results for a more synthetic example</span>
<span class="sd">    (synthetis anechoic mixture of the voice and the guitar, with a delay of 0</span>
<span class="sd">    for the voice and 10 samples from the left to the right channel</span>
<span class="sd">    for the guitar)::</span>
<span class="sd">    </span>
<span class="sd">        &gt;&gt;&gt; import pyfasst.audioModel as am</span>
<span class="sd">        &gt;&gt;&gt; filename = &#39;data/dev1__tamy-que_pena_tanto_faz___thetas-0.79,0.79_delays-10.00,0.00.wav&#39;</span>
<span class="sd">        &gt;&gt;&gt; # initialize the model</span>
<span class="sd">        &gt;&gt;&gt; model = am.MultiChanNMFConv(</span>
<span class="sd">                audio=filename,</span>
<span class="sd">                nbComps=2, nbNMFComps=32, spatial_rank=1,</span>
<span class="sd">                verbose=1, iter_num=200)</span>
<span class="sd">        &gt;&gt;&gt; # to be more flexible, the user _has to_ make the parameters</span>
<span class="sd">        &gt;&gt;&gt; # convolutive by hand. This way, she can also start to estimate</span>
<span class="sd">        &gt;&gt;&gt; # parameters in an instantaneous setting, as an initialization, </span>
<span class="sd">        &gt;&gt;&gt; # and only after &quot;upgrade&quot; to a convolutive setting:</span>
<span class="sd">        &gt;&gt;&gt; model.makeItConvolutive()</span>
<span class="sd">        &gt;&gt;&gt; # we can initialize these parameters with the DEMIX algorithm:</span>
<span class="sd">        &gt;&gt;&gt; model.initializeConvParams(initMethod=&#39;demix&#39;)</span>
<span class="sd">        &gt;&gt;&gt; # and estimate the parameters:</span>
<span class="sd">        &gt;&gt;&gt; log_lik = model.estim_param_a_post_model()</span>
<span class="sd">        &gt;&gt;&gt; # separate the sources using these parameters</span>
<span class="sd">        &gt;&gt;&gt; model.separate_spat_comps(dir_results=&#39;data/&#39;)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">audio</span><span class="p">,</span>
                 <span class="n">nbComps</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">nbNMFComps</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                 <span class="n">spatial_rank</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MultiChanNMFConv</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">audio</span><span class="o">=</span><span class="n">audio</span><span class="p">,</span>
                                               <span class="n">nbComps</span><span class="o">=</span><span class="n">nbComps</span><span class="p">,</span>
                                               <span class="n">nbNMFComps</span><span class="o">=</span><span class="n">nbNMFComps</span><span class="p">,</span>
                                               <span class="n">spatial_rank</span><span class="o">=</span><span class="n">spatial_rank</span><span class="p">,</span>
                                               <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c"># self.makeItConvolutive()</span>
        <span class="c"># DIY: upgrade to convolutive after a few instantaneous, maybe? </span>
        
<div class="viewcode-block" id="MultiChanNMFConv.makeItConvolutive"><a class="viewcode-back" href="../../reference/audiomodel.html#pyfasst.audioModel.MultiChanNMFConv.makeItConvolutive">[docs]</a>    <span class="k">def</span> <span class="nf">makeItConvolutive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;If the spatial parameters are instantaneous, then it will be turned</span>
<span class="sd">        into a convolutive version of it. In this case, it duplicates the</span>
<span class="sd">        instantaneous parameter on all the frequencies and spatial rank.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">channels</span>
        <span class="k">for</span> <span class="n">nspat</span><span class="p">,</span> <span class="p">(</span><span class="n">spat_ind</span><span class="p">,</span> <span class="n">spat_comp</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">spat_comp</span><span class="p">[</span><span class="s">&#39;mix_type&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&#39;inst&#39;</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Spatial component </span><span class="si">%d</span><span class="s"> &quot;</span><span class="o">%</span><span class="n">spat_ind</span><span class="o">+</span>
                              <span class="s">&quot;already not instantaneous, skipping...&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># spat_comp[&#39;time_dep&#39;] = &#39;indep&#39;</span>
                <span class="n">spat_comp</span><span class="p">[</span><span class="s">&#39;mix_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;conv&#39;</span>
                <span class="c"># spat_comp[&#39;frdm_prior&#39;] = &#39;free&#39;</span>
                <span class="n">spat_comp_param_inst</span> <span class="o">=</span> <span class="n">spat_comp</span><span class="p">[</span><span class="s">&#39;params&#39;</span><span class="p">]</span>
                <span class="n">spat_comp</span><span class="p">[</span><span class="s">&#39;params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">nspat</span><span class="p">],</span>
                                                <span class="n">nc</span><span class="p">,</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">],</span>
                                               <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">):</span>
                    <span class="n">spat_comp</span><span class="p">[</span><span class="s">&#39;params&#39;</span><span class="p">][:,:,</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">spat_comp_param_inst</span><span class="o">.</span><span class="n">T</span>
</div></div>
<div class="viewcode-block" id="MultiChanHMM"><a class="viewcode-back" href="../../reference/audiomodel.html#pyfasst.audioModel.MultiChanHMM">[docs]</a><span class="k">class</span> <span class="nc">MultiChanHMM</span><span class="p">(</span><span class="n">MultiChanNMFConv</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Conveniently adds methods to transform a :py:class:`MultiChanNMFConv`</span>
<span class="sd">    object such that the time structure is configured as a hidden Markov</span>
<span class="sd">    model (HMM) </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">audio</span><span class="p">,</span>
                 <span class="n">nbComps</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">nbNMFComps</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                 <span class="n">spatial_rank</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MultiChanHMM</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">audio</span><span class="o">=</span><span class="n">audio</span><span class="p">,</span>
                                               <span class="n">nbComps</span><span class="o">=</span><span class="n">nbComps</span><span class="p">,</span>
                                               <span class="n">nbNMFComps</span><span class="o">=</span><span class="n">nbNMFComps</span><span class="p">,</span>
                                               <span class="n">spatial_rank</span><span class="o">=</span><span class="n">spatial_rank</span><span class="p">,</span>
                                               <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
<div class="viewcode-block" id="MultiChanHMM.makeItHMM"><a class="viewcode-back" href="../../reference/audiomodel.html#pyfasst.audioModel.MultiChanHMM.makeItHMM">[docs]</a>    <span class="k">def</span> <span class="nf">makeItHMM</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Turns the required parameters into HMM time constraints</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">spec_ind</span><span class="p">,</span> <span class="n">spec_comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">fac_ind</span><span class="p">,</span> <span class="n">factor</span> <span class="ow">in</span> <span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;factor&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_constr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;HMM&#39;</span>
                <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_DP_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;free&#39;</span>
    </div>
<div class="viewcode-block" id="MultiChanHMM.makeItSHMM"><a class="viewcode-back" href="../../reference/audiomodel.html#pyfasst.audioModel.MultiChanHMM.makeItSHMM">[docs]</a>    <span class="k">def</span> <span class="nf">makeItSHMM</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Turns the required parameters into SHMM time constraints</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">spec_ind</span><span class="p">,</span> <span class="n">spec_comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">fac_ind</span><span class="p">,</span> <span class="n">factor</span> <span class="ow">in</span> <span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;factor&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">nbfaccomps</span> <span class="o">=</span> <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_constr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;SHMM&#39;</span>
                <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_DP_params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="mi">9</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span> <span class="n">nbfaccomps</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_DP_params&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">1.</span>
                <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_DP_params&#39;</span><span class="p">]</span> <span class="o">/=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_DP_params&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>
                <span class="n">factor</span><span class="p">[</span><span class="s">&#39;TW_DP_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;fixed&#39;</span>
                <span class="c"># factor[&#39;TW_DP_frdm_prior&#39;] = &#39;free&#39;</span>
        </div></div>
<div class="viewcode-block" id="multiChanSourceF0Filter"><a class="viewcode-back" href="../../reference/audiomodel.html#pyfasst.audioModel.multiChanSourceF0Filter">[docs]</a><span class="k">class</span> <span class="nc">multiChanSourceF0Filter</span><span class="p">(</span><span class="n">FASST</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;multi channel source/filter model</span>
<span class="sd">    nbcomps components, nbcomps-1 SF models, 1 residual component</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">audio</span><span class="p">,</span>
                 <span class="n">nbComps</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> 
                 <span class="n">nbNMFResComps</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
                 <span class="n">nbFilterComps</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> 
                 <span class="n">nbFilterWeigs</span><span class="o">=</span><span class="p">[</span><span class="mi">4</span><span class="p">,],</span> 
                 <span class="n">minF0</span><span class="o">=</span><span class="mi">39</span><span class="p">,</span> <span class="n">maxF0</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> <span class="n">minF0search</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span> <span class="n">maxF0search</span><span class="o">=</span><span class="mi">800</span><span class="p">,</span>
                 <span class="n">stepnoteF0</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">chirpPerF0</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
                 <span class="n">spatial_rank</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">sparsity</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        **DESCRIPTION**</span>
<span class="sd">        __init__(self, audio,</span>
<span class="sd">                 nbComps=3, ## nb of components</span>
<span class="sd">                 nbNMFResComps=3, ## nb of residual components</span>
<span class="sd">                 nbFilterComps=20, ## nb of filter components</span>
<span class="sd">                 nbFilterWeigs=4, ## nb of filter components</span>
<span class="sd">                 minF0=80, maxF0=800, ## range for comb spectra</span>
<span class="sd">                 stepnoteF0=4, chirpPerF0=1, </span>
<span class="sd">                 spatial_rank=1,</span>
<span class="sd">                 sparsity=None,</span>
<span class="sd">                 **kwargs)</span>
<span class="sd">        </span>
<span class="sd">        **ARGUMENTS**</span>
<span class="sd">        </span>
<span class="sd">        nbComps (int)</span>
<span class="sd">            The number of (spatial) components in FASST framework.</span>
<span class="sd">            </span>
<span class="sd">        nbNMFComps (int)</span>
<span class="sd">            The number of NMF components in each spatial component.</span>
<span class="sd">            </span>
<span class="sd">        sparsity (list of size 1 or nbComps)</span>
<span class="sd">            </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">multiChanSourceF0Filter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">audio</span><span class="o">=</span><span class="n">audio</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comp_transf_Cx</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sourceParams</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;minF0&#39;</span><span class="p">:</span> <span class="n">minF0</span><span class="p">,</span>
                             <span class="s">&#39;maxF0&#39;</span><span class="p">:</span> <span class="n">maxF0</span><span class="p">,</span>
                             <span class="s">&#39;stepnoteF0&#39;</span><span class="p">:</span> <span class="n">stepnoteF0</span><span class="p">,</span>
                             <span class="s">&#39;chirpPerF0&#39;</span><span class="p">:</span> <span class="n">chirpPerF0</span><span class="p">,</span>
                             <span class="s">&#39;minF0search&#39;</span><span class="p">:</span> <span class="n">minF0search</span><span class="p">,</span>
                             <span class="s">&#39;maxF0search&#39;</span><span class="p">:</span> <span class="n">maxF0search</span><span class="p">,}</span>
                             <span class="c"># __c quoi ca...__ &#39;chirpPerF02072&#39;: chirpPerF0}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span> <span class="o">=</span> <span class="n">nbComps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbNMFResComps</span> <span class="o">=</span> <span class="n">nbNMFResComps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbFilterComps</span> <span class="o">=</span> <span class="n">nbFilterComps</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nbFilterWeigs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nbFilterWeigs</span> <span class="o">=</span> <span class="p">[</span><span class="n">nbFilterWeigs</span><span class="p">[</span><span class="mi">0</span><span class="p">],]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nbFilterWeigs</span> <span class="o">=</span> <span class="n">nbFilterWeigs</span>
            
        <span class="c"># initialize the spatial_ranks, reformating here.</span>
        <span class="c"># 20130611 TODO check that it does not break too much everywhere!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatial_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">spatial_rank</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatial_rank</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spatial_rank</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_rank</span><span class="p">[</span><span class="mi">0</span><span class="p">],]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span>
        
        <span class="c"># the source dictionary is shared among all the components,</span>
        <span class="c"># so storing it one for all:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">F0Table</span><span class="p">,</span> <span class="n">WF0</span><span class="p">,</span> <span class="n">trfoBis</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">SLS</span><span class="o">.</span><span class="n">slf</span><span class="o">.</span><span class="n">generate_WF0_TR_chirped</span><span class="p">(</span>
                <span class="n">transform</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="p">,</span>
                <span class="n">minF0</span><span class="o">=</span><span class="n">minF0</span><span class="p">,</span> <span class="n">maxF0</span><span class="o">=</span><span class="n">maxF0</span><span class="p">,</span>
                <span class="n">stepNotes</span><span class="o">=</span><span class="n">stepnoteF0</span><span class="p">,</span>
                <span class="n">Ot</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">perF0</span><span class="o">=</span><span class="n">chirpPerF0</span><span class="p">,</span> 
                <span class="n">depthChirpInSemiTone</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">loadWF0</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">,)</span>
            <span class="p">)</span>
        
        <span class="c"># removing patterns in low energy bins - setting to eps:</span>
        <span class="k">for</span> <span class="n">nwf0comp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">WF0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span> 
            <span class="n">indLowEnergy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">WF0</span><span class="p">[:,</span><span class="n">nwf0comp</span><span class="p">]</span><span class="o">&lt;</span><span class="n">WF0</span><span class="p">[:,</span><span class="n">nwf0comp</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">*</span><span class="mf">1e-4</span><span class="p">)</span>
            <span class="n">WF0</span><span class="p">[</span><span class="n">indLowEnergy</span><span class="p">,</span> <span class="n">nwf0comp</span><span class="p">]</span> <span class="o">=</span> <span class="n">eps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sourceFreqComps</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">WF0</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">],</span>
                       <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">))]))</span>
            <span class="p">)</span>
        <span class="k">del</span> <span class="n">WF0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbSourceComps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sourceFreqComps</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sourceFreqWeights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbSourceComps</span><span class="p">)</span>
        <span class="c"># ... and the same for the filter part</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filterFreqComps</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">generateHannBasis</span><span class="p">(</span>
                <span class="n">numberFrequencyBins</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                <span class="n">sizeOfFourier</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;fsize&#39;</span><span class="p">],</span>
                <span class="n">Fs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">samplerate</span><span class="p">,</span>
                <span class="n">frequencyScale</span><span class="o">=</span><span class="s">&#39;linear&#39;</span><span class="p">,</span>
                <span class="n">numberOfBasis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFilterComps</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sparsity</span> <span class="o">=</span> <span class="n">sparsity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_structures</span><span class="p">()</span>
    
    <span class="k">def</span> <span class="nf">_initialize_structures</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;initialize the structures for the model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span> <span class="c"># essential for DEBUG</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatial_rank</span>
        <span class="n">nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">channels</span>
        <span class="n">sparsity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparsity</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c"># initialize the spatial component</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;time_dep&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;indep&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;mix_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;inst&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;free&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">nc</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="c"># spreading the sources evenly for init on stereo</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">((</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span><span class="p">)))</span> <span class="o">+</span>
                              <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.01</span><span class="p">),</span>
                              <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">((</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span><span class="p">)))</span> <span class="o">+</span>
                              <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)]))</span>
            
            <span class="c"># initialize source factor spectral component</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;spat_comp_ind&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;FB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sourceFreqComps</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;FW&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sourceFreqWeights</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TW&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="mf">0.75</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbSourceComps</span><span class="p">,</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">))</span> <span class="o">+</span>
                <span class="mf">0.25</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;FB_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;fixed&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;FW_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;fixed&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TW_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;free&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TB_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TW_constr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;NMF&#39;</span>
            
            <span class="c"># initialize filter factor spectral components</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="s">&#39;FB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filterFreqComps</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="s">&#39;FW&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="mf">0.75</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFilterComps</span><span class="p">,</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">nbFilterWeigs</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span> <span class="o">+</span>
                <span class="mf">0.25</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="s">&#39;TW&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="mf">0.75</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFilterWeigs</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">))</span> <span class="o">+</span>
                <span class="mf">0.25</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="s">&#39;TB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="s">&#39;FB_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;fixed&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="s">&#39;FW_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;free&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="s">&#39;TW_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;free&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="s">&#39;TB_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="s">&#39;TW_constr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;NMF&#39;</span>
            
        <span class="c"># residual component:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resSpatialRank</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="c">#2</span>
        <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c"># initialize the spatial component</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;time_dep&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;indep&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;mix_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;inst&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;free&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">resSpatialRank</span><span class="p">)</span>
        <span class="c"># 20120920 trying no initialization for residual:</span>
        <span class="c">##if nc == 2: # spreading the sources evenly for init on stereo</span>
        <span class="c">##    self.spat_comps[j][&#39;params&#39;] = (</span>
        <span class="c">##        np.array([np.sin((j+1) * np.pi / (2.*(self.nbComps + 1))) +</span>
        <span class="c">##                np.random.randn(self.resSpatialRank)*np.sqrt(0.01),</span>
        <span class="c">##                np.cos((j+1) * np.pi / (2.*(self.nbComps + 1))) +</span>
        <span class="c">##                np.random.randn(self.resSpatialRank)*np.sqrt(0.01)]))</span>
            
        <span class="c"># initialize single factor spectral component</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;spat_comp_ind&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;FB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mf">0.75</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">nbNMFResComps</span><span class="p">))</span> <span class="o">+</span>
            <span class="mf">0.25</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;FW&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbNMFResComps</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TW&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mf">0.75</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbNMFResComps</span><span class="p">,</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">))</span> <span class="o">+</span>
            <span class="mf">0.25</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;FB_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;free&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;FW_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;fixed&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TW_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;free&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TB_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TW_constr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;NMF&#39;</span>
        
        <span class="k">if</span> <span class="n">sparsity</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">sparsity</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;sparsity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">sparsity</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span><span class="p">:</span>
            <span class="c"># sparsity induces a &quot;sparse&quot; activation of</span>
            <span class="c"># self.spec_comps[j][&#39;factor&#39;][0][&#39;TW&#39;], that is,</span>
            <span class="c"># the time weights for the source part.</span>
            <span class="c"># This is implemented as in:</span>
            <span class="c"># Durrieu, J.-L. &amp; Thiran, J.-P.</span>
            <span class="c">#    Sparse Non-Negative Decomposition Of Speech Power Spectra For</span>
            <span class="c">#    Formant Tracking</span>
            <span class="c"># in proc. of the IEEE International Conference on Acoustics,</span>
            <span class="c"># Speech and Signal Processing, Pragues, Czech Republic, 2011.</span>
            <span class="c">#</span>
            <span class="c"># This means that at each GEM iteration, the TW coefficients</span>
            <span class="c"># are further shrinked down to be concentrating around a</span>
            <span class="c"># single component (a single F0 in SF model)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;sparsity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sparsity</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;sparsity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sparsity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">renormalize_parameters</span><span class="p">()</span>
        
<div class="viewcode-block" id="multiChanSourceF0Filter.initSpecCompsWithLabelAndFiles"><a class="viewcode-back" href="../../reference/audiomodel.html#pyfasst.audioModel.multiChanSourceF0Filter.initSpecCompsWithLabelAndFiles">[docs]</a>    <span class="k">def</span> <span class="nf">initSpecCompsWithLabelAndFiles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instrus</span><span class="o">=</span><span class="p">[],</span> <span class="n">instru2modelfile</span><span class="o">=</span><span class="p">{},</span>
                                       <span class="n">freqBasisAdaptive</span><span class="o">=</span><span class="s">&#39;fixed&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the spectral components with the instrument labels as</span>
<span class="sd">        well as with the components stored in the provided dictionary in</span>
<span class="sd">        `instru2modelfile`</span>
<span class="sd">        </span>
<span class="sd">        `instrus` is a list with labels:</span>
<span class="sd">            `&#39;SourceFilter&#39;`:</span>
<span class="sd">                keep the intialized source filter model</span>
<span class="sd">            `&#39;Free_&lt;nb_comp&gt;&#39;`:</span>
<span class="sd">                initialize the model with an adaptable</span>
<span class="sd">                spectral component using `nb_comp` elements in the NMF</span>
<span class="sd">                frequency basis</span>
<span class="sd">                </span>
<span class="sd">            `&lt;key_in_instru2modelfile&gt;`:</span>
<span class="sd">                initialize with the :py:class:GSMM</span>
<span class="sd">                available and stored in the archive npz with filename</span>
<span class="sd">                `instru2modelfile[key_in_instru2modelfile]`</span>
<span class="sd">                </span>
<span class="sd">        NB: needs the gmm-gsmm module to be installed and in the pythonpath</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">instrumentNames</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">instrus</span><span class="p">):</span>
            <span class="n">instrumentNames</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="s">&#39;SourceFilter&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
                <span class="k">print</span> <span class="s">&quot;    Source&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="s">&quot;left as general Source-Filter model.&quot;</span>
            <span class="k">elif</span> <span class="s">&#39;Free&#39;</span> <span class="ow">in</span> <span class="n">i</span><span class="p">:</span> <span class="c"># assumes Free_nbNMFComps</span>
                <span class="n">nbNMFComps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;_&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">print</span> <span class="s">&quot;    Source&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="s">&quot;set as free NMF source.&quot;</span>
                <span class="c"># initialize single factor spectral component</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;spat_comp_ind&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;FB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="mf">0.75</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">,</span>
                                                  <span class="n">nbNMFComps</span><span class="p">))</span> <span class="o">+</span>
                    <span class="mf">0.25</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;FW&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">nbNMFComps</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TW&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="mf">0.75</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">nbNMFComps</span><span class="p">,</span>
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">))</span> <span class="o">+</span>
                    <span class="mf">0.25</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;FB_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;free&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;FW_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;fixed&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TW_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;free&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TB_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TW_constr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;NMF&#39;</span>
                <span class="c"># sparsity stuff</span>
                <span class="n">sparsity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparsity</span>
                <span class="k">if</span> <span class="n">sparsity</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">sparsity</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;sparsity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">sparsity</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;sparsity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sparsity</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;sparsity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sparsity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span> <span class="c">#if i != &#39;SourceFilter&#39;:</span>
                <span class="k">print</span> <span class="s">&quot;    Source&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="s">&quot;is&quot;</span><span class="p">,</span> <span class="n">i</span>
                <span class="n">modelfile</span> <span class="o">=</span> <span class="n">instru2modelfile</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">struc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">modelfile</span><span class="p">)</span>
                <span class="n">gsmm</span> <span class="o">=</span> <span class="n">struc</span><span class="p">[</span><span class="s">&#39;gsmm&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="c"># Keeping only spectra that are not flat:</span>
                <span class="n">decisionSpectra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">gsmm</span><span class="o">.</span><span class="n">sigw</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="c"># keeping only the spectra with enough weight:</span>
                <span class="c">#     hard decision, remove all spectra with w == min(w)</span>
                <span class="c"># decisionOnWeight = np.where(gsmm.w!=gsmm.w.min())[0]</span>
                <span class="c">#     harder decision: remove all with w under a threshold:</span>
                <span class="n">decisionOnWeight</span> <span class="o">=</span> <span class="p">(</span><span class="n">gsmm</span><span class="o">.</span><span class="n">w</span> <span class="o">&gt;</span> <span class="n">gsmm</span><span class="o">.</span><span class="n">w</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">*</span><span class="mf">1e-3</span><span class="p">)</span>
                
                <span class="n">keepIndex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">decisionSpectra</span><span class="o">+</span><span class="n">decisionOnWeight</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                
                <span class="n">FB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">gsmm</span><span class="o">.</span><span class="n">sigw</span><span class="p">[</span><span class="n">keepIndex</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                <span class="c">#self.setSpecCompFB(compNb=n, FB=FB, FB_frdm_prior=&#39;fixed&#39;)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">setSpecCompFB</span><span class="p">(</span><span class="n">compNb</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">FB</span><span class="o">=</span><span class="n">FB</span><span class="p">,</span>
                                   <span class="n">FB_frdm_prior</span><span class="o">=</span><span class="n">freqBasisAdaptive</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s">&#39;label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
                <span class="n">struc</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="n">instrumentNames</span>
        </div>
<div class="viewcode-block" id="multiChanSourceF0Filter.setSpecCompFB"><a class="viewcode-back" href="../../reference/audiomodel.html#pyfasst.audioModel.multiChanSourceF0Filter.setSpecCompFB">[docs]</a>    <span class="k">def</span> <span class="nf">setSpecCompFB</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">compNb</span><span class="p">,</span> <span class="n">FB</span><span class="p">,</span> <span class="n">FB_frdm_prior</span><span class="o">=</span><span class="s">&#39;fixed&#39;</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;SetSpecCompFB</span>
<span class="sd">        </span>
<span class="sd">        sets the spectral component&#39;s frequency basis.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">speccomp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">compNb</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span> <span class="o">!=</span> <span class="n">FB</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s">&quot;Size of provided FB is not consistent&quot;</span><span class="o">+</span>
                                 <span class="s">&quot; with inner attributes&quot;</span><span class="p">)</span>
        <span class="n">speccomp</span><span class="p">[</span><span class="s">&#39;FB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">FB</span><span class="p">)</span>
        <span class="n">ncomp</span> <span class="o">=</span> <span class="n">FB</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="n">speccomp</span><span class="p">[</span><span class="s">&#39;FW&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">ncomp</span><span class="p">)</span>
        <span class="n">speccomp</span><span class="p">[</span><span class="s">&#39;TW&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="mf">0.75</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">ncomp</span><span class="p">,</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">nbFramesSigRepr</span><span class="p">))</span> <span class="o">+</span>
                <span class="mf">0.25</span><span class="p">)</span>
        <span class="n">speccomp</span><span class="p">[</span><span class="s">&#39;FB_frdm_prior&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">FB_frdm_prior</span>
    </div>
<div class="viewcode-block" id="multiChanSourceF0Filter.initializeFreeMats"><a class="viewcode-back" href="../../reference/audiomodel.html#pyfasst.audioModel.multiChanSourceF0Filter.initializeFreeMats">[docs]</a>    <span class="k">def</span> <span class="nf">initializeFreeMats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;initialize free matrices, with NMF decomposition</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># we initialize the matrices with NMF decomposition using the</span>
        <span class="c"># source matrix as basis W, the residual is left uninitialized</span>
        <span class="n">nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">channels</span>
        <span class="c"># computing the signal representation</span>
        <span class="n">Cx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">chan</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nc</span><span class="p">):</span>
            <span class="c"># stored an &quot;efficient&quot; way, so index &quot;complicated&quot;:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="n">nc</span><span class="o">-</span><span class="n">chan</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">Cx</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Cx</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
        
        <span class="n">Cx</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="n">nc</span><span class="p">)</span>
        
        <span class="c"># computing NMF of Cx:</span>
        <span class="n">W</span><span class="p">,</span> <span class="n">H</span> <span class="o">=</span> <span class="n">NMF_decomp_init</span><span class="p">(</span><span class="n">SX</span><span class="o">=</span><span class="n">Cx</span><span class="p">,</span>
                               <span class="n">Winit</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">sourceFreqComps</span><span class="p">,</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;FW&#39;</span><span class="p">]),</span>
                               <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">,</span>
                               <span class="n">nbComps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nbSourceComps</span><span class="p">,</span>
                               <span class="n">niter</span><span class="o">=</span><span class="n">niter</span><span class="p">,</span>
                               <span class="n">updateW</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">updateH</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                               <span class="p">)</span>
        
        <span class="k">for</span> <span class="n">ncomp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">spec_comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">ncomp</span><span class="p">]</span>
            <span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TW&#39;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">H</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">renormalize_parameters</span><span class="p">()</span>
    </div>
<div class="viewcode-block" id="multiChanSourceF0Filter.makeItConvolutive"><a class="viewcode-back" href="../../reference/audiomodel.html#pyfasst.audioModel.multiChanSourceF0Filter.makeItConvolutive">[docs]</a>    <span class="k">def</span> <span class="nf">makeItConvolutive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Takes the spatial parameters and sets them to a convolutive</span>
<span class="sd">        mixture, in case the parameter has not yet been changed to</span>
<span class="sd">        &#39;conv&#39; mode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">channels</span>
        <span class="k">for</span> <span class="n">nspat</span><span class="p">,</span> <span class="p">(</span><span class="n">spat_ind</span><span class="p">,</span> <span class="n">spat_comp</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">spat_comp</span><span class="p">[</span><span class="s">&#39;mix_type&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&#39;inst&#39;</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Spatial component </span><span class="si">%d</span><span class="s"> &quot;</span><span class="o">%</span><span class="n">spat_ind</span><span class="o">+</span>
                              <span class="s">&quot;already not instantaneous, skipping...&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># spat_comp[&#39;time_dep&#39;] = &#39;indep&#39;</span>
                <span class="n">spat_comp</span><span class="p">[</span><span class="s">&#39;mix_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;conv&#39;</span>
                <span class="c"># spat_comp[&#39;frdm_prior&#39;] = &#39;free&#39;</span>
                <span class="n">spat_comp_param_inst</span> <span class="o">=</span> <span class="n">spat_comp</span><span class="p">[</span><span class="s">&#39;params&#39;</span><span class="p">]</span>
                <span class="n">spat_comp</span><span class="p">[</span><span class="s">&#39;params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">nspat</span><span class="p">],</span>
                                                <span class="n">nc</span><span class="p">,</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">],</span>
                                               <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFreqsSigRepr</span><span class="p">):</span>
                    <span class="n">spat_comp</span><span class="p">[</span><span class="s">&#39;params&#39;</span><span class="p">][:,:,</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">spat_comp_param_inst</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
    </div>
<div class="viewcode-block" id="multiChanSourceF0Filter.estim_param_a_post_model"><a class="viewcode-back" href="../../reference/audiomodel.html#pyfasst.audioModel.multiChanSourceF0Filter.estim_param_a_post_model">[docs]</a>    <span class="k">def</span> <span class="nf">estim_param_a_post_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;estim_param_a_post_model</span>
<span class="sd">        </span>
<span class="sd">        Estimation of model parameters, using the sparsity constraints.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">logSigma0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">spec</span><span class="p">[</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TW&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                                   <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">logSigmaInf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">9.0</span><span class="p">)</span>
        
        <span class="n">logliks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iter_num</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;sim_ann_opt&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;ann&#39;</span><span class="p">,</span> <span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;PSD&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;ann_PSD_lim&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;sim_ann_opt&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="s">&#39;no_ann&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;PSD&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;ann_PSD_lim&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;To add noise to the signal, provide the &quot;</span><span class="o">+</span>
                          <span class="s">&quot;sim_ann_opt from any of &#39;ann&#39;, &quot;</span><span class="o">+</span>
                          <span class="s">&quot;&#39;no_ann&#39; or &#39;ann_ns_inj&#39; &quot;</span><span class="p">)</span>
            
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iter_num</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;Iteration&quot;</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;on&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_num</span>
            <span class="c"># adding the noise psd if required:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;sim_ann_opt&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;ann&#39;</span><span class="p">,</span> <span class="s">&#39;ann_ns_inj&#39;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;PSD&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;ann_PSD_lim&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span>
                     <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iter_num</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">+</span>
                     <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="s">&#39;ann_PSD_lim&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">/</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">iter_num</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                
            <span class="c"># running the GEM iteration:</span>
            <span class="n">logliks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GEM_iteration</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;    log-likelihood:&quot;</span><span class="p">,</span> <span class="n">logliks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="k">print</span> <span class="s">&quot;        improvement:&quot;</span><span class="p">,</span> <span class="n">logliks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">logliks</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    
            <span class="c"># sparsity</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">logSigma0</span> <span class="o">+</span>
                           <span class="p">(</span><span class="n">logSigmaInf</span> <span class="o">-</span> 
                            <span class="n">logSigma0</span><span class="p">)</span> <span class="o">/</span> 
                           <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iter_num</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reweigh_sparsity_constraint</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">logliks</span>
    </div>
<div class="viewcode-block" id="multiChanSourceF0Filter.reweigh_sparsity_constraint"><a class="viewcode-back" href="../../reference/audiomodel.html#pyfasst.audioModel.multiChanSourceF0Filter.reweigh_sparsity_constraint">[docs]</a>    <span class="k">def</span> <span class="nf">reweigh_sparsity_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;reweigh_sparsity_constraint</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;reweigh_sparsity_constraint:&quot;</span>
            <span class="k">print</span> <span class="s">&quot;    sigma&quot;</span><span class="p">,</span> <span class="n">sigma</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span><span class="p">):</span>
            <span class="n">spec_comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;sparsity&#39;</span><span class="p">]</span> <span class="ow">and</span> \
                   <span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TW&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">TW</span> <span class="o">=</span> <span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TW&#39;</span><span class="p">]</span>
                <span class="n">K</span> <span class="o">=</span> <span class="n">TW</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c"># barycenter from energy of factor 0 TW component</span>
                <span class="n">muTW</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">K</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> 
                           <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">K</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> 
                           <span class="n">TW</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,:])</span> <span class="o">/</span> 
                    <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">K</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
                           <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">TW</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,:],</span> <span class="n">eps</span><span class="p">))</span>
                    <span class="p">)</span>
                <span class="c"># smoothing the sequence:</span>
                <span class="n">muTW</span>  <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">medianFilter</span><span class="p">(</span><span class="n">muTW</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">spec_comp</span><span class="p">[</span><span class="s">&#39;sparsity&#39;</span><span class="p">])</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">print</span> <span class="s">&quot;        muTW NaNs in comp </span><span class="si">%d</span><span class="s">:&quot;</span> <span class="o">%</span><span class="n">j</span><span class="p">,</span>
                    <span class="k">print</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">muTW</span><span class="p">))</span>
                
                <span class="n">twmask</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span>
                           <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">K</span><span class="p">))</span> <span class="o">-</span> <span class="n">muTW</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span>
                           <span class="n">sigma</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="n">twmask</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">twmask</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">twmask</span><span class="p">[:,</span><span class="n">twmask</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">/=</span> <span class="n">twmask</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">twmask</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">TW</span> <span class="o">*=</span> <span class="n">twmask</span>
</div></div>
<div class="viewcode-block" id="multichanLead"><a class="viewcode-back" href="../../reference/audiomodel.html#pyfasst.audioModel.multichanLead">[docs]</a><span class="k">class</span> <span class="nc">multichanLead</span><span class="p">(</span><span class="n">multiChanSourceF0Filter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Multiple Channel Source Separation, with Lead/Accompaniment initial</span>
<span class="sd">    separation</span>

<span class="sd">    This instantiation of :class:`multiChanSourceF0Filter` provides convenient</span>
<span class="sd">    methods (:func:`multichanLead.runDecomp` for instance) to separate the</span>
<span class="sd">    lead instrument from the accompaniment, as in [Durrieu2011]_, and</span>
<span class="sd">    then use the obtained parameters/signals in order to initialize the more</span>
<span class="sd">    general source separation algorithm.</span>

<span class="sd">    Tentative plan for estimation:</span>
<span class="sd">        </span>
<span class="sd">        1) estimate the Lead/Accompaniment using SIMM</span>

<span class="sd">        2) estimate the spatial parameters for each of the separated signals</span>

<span class="sd">        3) plug the SIMM params and the spatial params into pyFASST, and</span>

<span class="sd">        4) re-estimate</span>

<span class="sd">        5) write the estimated signals and enjoy success!</span>

<span class="sd">    NB: as for now, the sole Lead/Accompaniment separation achieves better</span>
<span class="sd">    separation than the combination of all the possibilities, probably</span>
<span class="sd">    because of a more flexible framework for the former than for the latter.</span>
<span class="sd">    Some results have been published at the</span>
<span class="sd">    `SiSEC &lt;http://sisec.wiki.irisa.fr&gt;`_ 2013 evaluation campaign.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;multichanLead</span>
<span class="sd">        </span>
<span class="sd">        subclasses multiChanSourceF0Filter</span>
<span class="sd">        </span>
<span class="sd">        Provides additional methods to estimate the lead/accompaniment parameters</span>
<span class="sd">        meant to be used as initial parameters for one of the sources.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">multichanLead</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c"># removing some data from the object, recomputing when needed:</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">Cx</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span>
        <span class="c">##del self.spec_comps</span>
        
<div class="viewcode-block" id="multichanLead.runDecomp"><a class="viewcode-back" href="../../reference/audiomodel.html#pyfasst.audioModel.multichanLead.runDecomp">[docs]</a>    <span class="k">def</span> <span class="nf">runDecomp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instrus</span><span class="o">=</span><span class="p">[],</span>
                  <span class="n">instru2modelfile</span><span class="o">=</span><span class="p">{},</span>
                  <span class="n">dir_results</span><span class="o">=</span><span class="s">&#39;tmp/&#39;</span><span class="p">,</span> <span class="n">maxFrames</span><span class="o">=</span><span class="mi">4000</span><span class="p">,</span>
                  <span class="n">niter_nmf</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">niter_simm</span><span class="o">=</span><span class="mi">30</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Running the scheme that should make me famous.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># checking the folder for results</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">dir_results</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">dir_results</span><span class="p">)</span>
        
        <span class="c"># running some checks that the input is alright:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">instrus</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="s">&#39;SourceFilter&#39;</span> <span class="ow">or</span>
                   <span class="n">i</span> <span class="ow">in</span> <span class="n">instru2modelfile</span> <span class="ow">or</span>
                   <span class="n">i</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&quot;Free_&quot;</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Instrument </span><span class="si">%s</span><span class="s"> not known.&#39;</span> <span class="o">%</span><span class="n">i</span><span class="p">)</span>
        
        <span class="c"># just running everything in __init__:</span>
        <span class="c"># estimating the separated </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">estimSUIMM</span><span class="p">(</span><span class="n">maxFrames</span><span class="o">=</span><span class="n">maxFrames</span><span class="p">,</span>
                        <span class="n">dir_results</span><span class="o">=</span><span class="n">dir_results</span><span class="p">,</span>
                        <span class="n">simmIterNum</span><span class="o">=</span><span class="n">niter_simm</span><span class="p">)</span>
        
        <span class="c">##############</span>
        <span class="c"># entering vacuum of nightmare of research trial and errors...</span>
        <span class="c"># thus expect many undesirable commented lines...</span>
        
        <span class="c"># putting everything in the right containers:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comp_transf_Cx</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_structures</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">makeItConvolutive</span><span class="p">()</span>
        
        <span class="c"># running DEMIX:</span>
        <span class="c">## 20130604 no need anymore, only for ALead:</span>
        <span class="n">ALead</span><span class="p">,</span> <span class="n">AAccp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">demixOnSepSIMM</span><span class="p">(</span><span class="n">unvoiced</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="c">#   spatial components:</span>
        <span class="c">#    accompaniment parameters:</span>
        <span class="c">## THE FOLLOWING SEEMS TO LEAD TO ISSUES and results not so good...</span>
        <span class="c">## 20130604 do this after initialize with NMF...</span>
        <span class="c">## for j in range(1, self.nbComps-1):</span>
        <span class="c">##     for r in range(self.rank):</span>
        <span class="c">##       ## the following assumes the instruments are sorted in the</span>
        <span class="c">##       ## right order, but we still need to think about that !</span>
        <span class="c">##       # self.spat_comps[j][&#39;params&#39;][r][:,:] = AAccp[j-1].T</span>
        <span class="c">##       # so for now, we just go for the sum of all the mixing params</span>
        <span class="c">##       self.spat_comps[j][&#39;params&#39;][r][:,:] = AAccp.sum(axis=0).T</span>
        <span class="c">## Trying randomized init:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initializeConvParams</span><span class="p">(</span><span class="n">initMethod</span><span class="o">=</span><span class="s">&#39;rand&#39;</span><span class="p">)</span>
        <span class="c">#    no modif for noise component...</span>
        <span class="c">#    lead instrument spatial mat:</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;params&#39;</span><span class="p">][</span><span class="n">r</span><span class="p">][:,:]</span> <span class="o">=</span> <span class="n">ALead</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
        
        <span class="c">#   spectral components:</span>
        
        <span class="c">## Using the instrument models to initialize the matrices:</span>
        <span class="c"># For convenience, we do this in a separate method:</span>
        <span class="n">instrumentNames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initSpecCompsWithLabelAndFiles</span><span class="p">(</span>
            <span class="n">instrus</span><span class="o">=</span><span class="n">instrus</span><span class="p">,</span>
            <span class="n">instru2modelfile</span><span class="o">=</span><span class="n">instru2modelfile</span><span class="p">,</span>
            <span class="n">freqBasisAdaptive</span><span class="o">=</span><span class="s">&#39;fixed&#39;</span><span class="p">)</span>
        <span class="c">## instrumentNames = {}</span>
        <span class="c">## for n, i in enumerate(instrus):</span>
        <span class="c">##     instrumentNames[n] = i</span>
        <span class="c">##     if i == &#39;SourceFilter&#39;:</span>
        <span class="c">##         print &quot;    Source&quot;, n, &quot;left as general Source-Filter model.&quot;</span>
        <span class="c">##     elif &#39;Free&#39; in i: # assumes Free_nbNMFComps</span>
        <span class="c">##         nbNMFComps = int(i.split(&#39;_&#39;)[-1])</span>
        <span class="c">##         print &quot;    Source&quot;, n, &quot;set as free NMF source.&quot;</span>
        <span class="c">##         # initialize single factor spectral component</span>
        <span class="c">##         self.spec_comps[n] = {}</span>
        <span class="c">##         self.spec_comps[n][&#39;spat_comp_ind&#39;] = n</span>
        <span class="c">##         self.spec_comps[n][&#39;factor&#39;] = {}</span>
        <span class="c">##         self.spec_comps[n][&#39;factor&#39;][0] = {}</span>
        <span class="c">##         self.spec_comps[n][&#39;factor&#39;][0][&#39;FB&#39;] = (</span>
        <span class="c">##             0.75 * np.abs(np.random.randn(self.nbFreqsSigRepr,</span>
        <span class="c">##                                           nbNMFComps)) +</span>
        <span class="c">##             0.25)</span>
        <span class="c">##         self.spec_comps[n][&#39;factor&#39;][0][&#39;FW&#39;] = (</span>
        <span class="c">##             np.eye(nbNMFComps))</span>
        <span class="c">##         self.spec_comps[n][&#39;factor&#39;][0][&#39;TW&#39;] = (</span>
        <span class="c">##             0.75 * np.abs(np.random.randn(nbNMFComps,</span>
        <span class="c">##                                           self.nbFramesSigRepr)) +</span>
        <span class="c">##             0.25)</span>
        <span class="c">##         self.spec_comps[n][&#39;factor&#39;][0][&#39;TB&#39;] = []</span>
        <span class="c">##         self.spec_comps[n][&#39;factor&#39;][0][&#39;FB_frdm_prior&#39;] = &#39;free&#39;</span>
        <span class="c">##         self.spec_comps[n][&#39;factor&#39;][0][&#39;FW_frdm_prior&#39;] = &#39;fixed&#39;</span>
        <span class="c">##         self.spec_comps[n][&#39;factor&#39;][0][&#39;TW_frdm_prior&#39;] = &#39;free&#39;</span>
        <span class="c">##         self.spec_comps[n][&#39;factor&#39;][0][&#39;TB_frdm_prior&#39;] = []</span>
        <span class="c">##         self.spec_comps[n][&#39;factor&#39;][0][&#39;TW_constr&#39;] = &#39;NMF&#39;</span>
        <span class="c">##         # sparsity stuff</span>
        <span class="c">##         sparsity = self.sparsity</span>
        <span class="c">##         if sparsity is None or len(sparsity) not in (1, self.nbComps):</span>
        <span class="c">##             self.spec_comps[n][&#39;sparsity&#39;] = False</span>
        <span class="c">##         elif len(sparsity) == self.nbComps:</span>
        <span class="c">##             self.spec_comps[n][&#39;sparsity&#39;] = sparsity[n]</span>
        <span class="c">##         else:</span>
        <span class="c">##             self.spec_comps[n][&#39;sparsity&#39;] = sparsity[0]</span>
        <span class="c">##     else: #if i != &#39;SourceFilter&#39;:</span>
        <span class="c">##         print &quot;    Source&quot;, n, &quot;is&quot;, i</span>
        <span class="c">##         modelfile = instru2modelfile[i]</span>
        <span class="c">##         struc = np.load(modelfile)</span>
        <span class="c">##         gsmm = struc[&#39;gsmm&#39;].tolist()</span>
        <span class="c">##         # Keeping only spectra that are not flat:</span>
        <span class="c">##         decisionSpectra = np.any(np.diff(gsmm.sigw, axis=1)!=0, axis=1)</span>
        <span class="c">##         # keeping only the spectra with enough weight:</span>
        <span class="c">##         #     hard decision, remove all spectra with w == min(w)</span>
        <span class="c">##         # decisionOnWeight = np.where(gsmm.w!=gsmm.w.min())[0]</span>
        <span class="c">##         #     harder decision: remove all with w under a threshold:</span>
        <span class="c">##         decisionOnWeight = (gsmm.w &gt; gsmm.w.max()*1e-3)</span>
        <span class="c">##         </span>
        <span class="c">##         keepIndex = np.where(decisionSpectra+decisionOnWeight)[0]</span>
        <span class="c">##         </span>
        <span class="c">##         FB = np.ascontiguousarray(gsmm.sigw[keepIndex].T)</span>
        <span class="c">##         #self.setSpecCompFB(compNb=n, FB=FB, FB_frdm_prior=&#39;fixed&#39;)</span>
        <span class="c">##         self.setSpecCompFB(compNb=n, FB=FB, FB_frdm_prior=&#39;free&#39;)</span>
        <span class="c">##         struc.close()</span>
        
        <span class="n">suffix</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">instrumentNames</span><span class="p">)</span>
        <span class="c"># suffix[len(suffix)] = &#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;suffix&#39;</span><span class="p">,</span> <span class="n">suffix</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">renormalize_parameters</span><span class="p">()</span>
        
        <span class="c"># initialize parameters with NMF:</span>
        <span class="c"># putting the HF0 from the SIMM model back in:</span>
        <span class="c">#    lead instrument</span>
        <span class="c">##self.spec_comps[0][&#39;factor&#39;][0][&#39;TW&#39;][:-1] = (</span>
        <span class="c">##    self.simmModel.SIMMParams[&#39;HF00&#39;])</span>
        <span class="n">startincqt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tft</span><span class="o">.</span><span class="n">time_stamps</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">stopincqt</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">startincqt</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">simmModel</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HF00&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span>
            <span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TW&#39;</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">startincqt</span><span class="p">:</span><span class="n">stopincqt</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">simmModel</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HF00&#39;</span><span class="p">])</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize_all_spec_comps_with_NMF</span><span class="p">(</span><span class="n">updateFreqBasis</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                                <span class="n">niter</span><span class="o">=</span><span class="n">niter_nmf</span><span class="p">)</span>
        <span class="c"># putting the HF0 from the SIMM model back in:</span>
        <span class="c">#    lead instrument</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span>
            <span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TW&#39;</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">startincqt</span><span class="p">:</span><span class="n">stopincqt</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">simmModel</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HF00&#39;</span><span class="p">])</span>
        <span class="c">##self.spec_comps[0][&#39;factor&#39;][0][&#39;TW&#39;][:-1] = (</span>
        <span class="c">##    self.simmModel.SIMMParams[&#39;HF00&#39;])</span>
        <span class="c">#        the following are too variable to be kept for now:</span>
        <span class="c">#self.spec_comps[0][&#39;factor&#39;][1][&#39;TW&#39;][:-1] = (</span>
        <span class="c">#    self.simmModel.SIMMParams[&#39;HPHI&#39;])</span>
        <span class="c">#self.spec_comps[0][&#39;factor&#39;][1][&#39;FW&#39;][:-1] = (</span>
        <span class="c">#    self.simmModel.SIMMParams[&#39;HGAMMA&#39;])</span>
        <span class="c">#self.spec_comps[0][&#39;factor&#39;][1][&#39;FB&#39;][:-1] = (</span>
        <span class="c">#    self.simmModel.SIMMParams[&#39;WGAMMA&#39;])</span>
        
        <span class="c">#    accompaniment: nothing for now.</span>
        <span class="c">#    accompaniment: avoid or reduce effect of stuff in source 0, maybe:</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">instrumentNames</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;SourceFilter&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spec_comps</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;factor&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;TW&#39;</span><span class="p">][</span>
                    <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">startincqt</span><span class="p">:</span><span class="n">stopincqt</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">*</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">simmModel</span><span class="o">.</span><span class="n">SIMMParams</span><span class="p">[</span><span class="s">&#39;HF00&#39;</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
        <span class="c">#    noise: nothing for now.</span>
        
        <span class="c">## 20130605T0104</span>
        <span class="c">##    Should we iterate a sequence of (estim_param_a_post_model, demix)</span>
        <span class="c">##    here? </span>
        
        <span class="c"># separate the files with these parameters:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">renormalize_parameters</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">separate_spat_comps</span><span class="p">(</span><span class="n">dir_results</span><span class="o">=</span><span class="n">dir_results</span><span class="p">,</span>
                                 <span class="n">suffix</span><span class="o">=</span><span class="n">suffix</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">print</span> <span class="n">suffix</span>
        
        <span class="c"># replace this with method:</span>
        <span class="c"># run DEMIX on the separated files:</span>
        <span class="c">##estFiles = self.files[&#39;spat_comp&#39;]</span>
        <span class="c">##nbSources = len(self.spat_comps)</span>
        <span class="c">##if self.verbose&gt;1:</span>
        <span class="c">##    print nbSources, &quot;sources:&quot;, estFiles</span>
        <span class="c">##for nest, estfilename in enumerate(estFiles):</span>
        <span class="c">##    if self.verbose&gt;1:</span>
        <span class="c">##        print estfilename</span>
        <span class="c">##    A = self.demixOnGivenFile(estfilename, nsources=1)</span>
        <span class="c">##    for r in range(self.rank[nest]):</span>
        <span class="c">##        self.spat_comps[nest][&#39;params&#39;][r][:,:] = (</span>
        <span class="c">##            A[0].T + 1e-3 * np.random.randn(*A[0].T.shape))</span>
        <span class="c">##</span>
        <span class="c">##self.renormalize_parameters()</span>
        
        <span class="n">estFiles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initConvDemixOnSepSrc</span><span class="p">(</span><span class="n">suffix</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">separate_spatial_filter_comp</span><span class="p">(</span><span class="n">dir_results</span><span class="o">=</span><span class="n">dir_results</span><span class="p">,</span>
                                          <span class="n">suffix</span><span class="o">=</span><span class="n">suffix</span><span class="p">)</span>
        
        <span class="c"># Re-estimating all the parameters:</span>
        <span class="n">logliks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estim_param_a_post_model</span><span class="p">()</span>
        
        <span class="c"># Separate and Write them...</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Writing files to&quot;</span><span class="p">,</span> <span class="n">dir_results</span>
            <span class="k">print</span> <span class="bp">self</span><span class="o">.</span><span class="n">files</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">separate_spat_comps</span><span class="p">(</span><span class="n">dir_results</span><span class="o">=</span><span class="n">dir_results</span><span class="p">,</span>
                                 <span class="n">suffix</span><span class="o">=</span><span class="n">suffix</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">logliks</span>
    </div>
<div class="viewcode-block" id="multichanLead.estimSIMM"><a class="viewcode-back" href="../../reference/audiomodel.html#pyfasst.audioModel.multichanLead.estimSIMM">[docs]</a>    <span class="k">def</span> <span class="nf">estimSIMM</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maxFrames</span><span class="o">=</span><span class="mi">4000</span><span class="p">,</span> <span class="n">dir_results</span><span class="o">=</span><span class="s">&#39;tmp/&#39;</span><span class="p">,</span> <span class="n">simmIterNum</span><span class="o">=</span><span class="mi">30</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This method runs the SIMM estimation on the provided audio file.</span>
<span class="sd">        </span>
<span class="sd">        The lead source is assumed to be self.spec_comps[0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c">##numCompAccomp = (</span>
        <span class="c">##        np.sum([spec_comp[&#39;factor&#39;][0][&#39;FB&#39;].shape[1]</span>
        <span class="c">##                for ncomp, spec_comp in self.spec_comps.items()])-</span>
        <span class="c">##        self.spec_comps[0][&#39;factor&#39;][0][&#39;FB&#39;].shape[1]</span>
        <span class="c">##        )</span>
        <span class="n">numCompAccomp</span> <span class="o">=</span> <span class="mi">40</span> <span class="c"># TODO: check if this improves solo/acc separation</span>
        <span class="k">if</span> <span class="n">simmIterNum</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">simmIterNum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_num</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">simmModel</span> <span class="o">=</span> <span class="n">SLS</span><span class="o">.</span><span class="n">SeparateLeadProcess</span><span class="p">(</span>
            <span class="n">inputAudioFilename</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span>
            <span class="n">stepNotes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sourceParams</span><span class="p">[</span><span class="s">&#39;stepnoteF0&#39;</span><span class="p">],</span>
            <span class="n">chirpPerF0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sourceParams</span><span class="p">[</span><span class="s">&#39;chirpPerF0&#39;</span><span class="p">],</span>
            <span class="n">nbIter</span><span class="o">=</span><span class="n">simmIterNum</span><span class="p">,</span>
            <span class="n">windowSize</span><span class="o">=</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;wlen&#39;</span><span class="p">]</span><span class="o">/</span>
                <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">audioObject</span><span class="o">.</span><span class="n">samplerate</span><span class="p">)),</span> <span class="c"># in seconds</span>
            <span class="n">hopsize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;hopsize&#39;</span><span class="p">],</span>
            <span class="n">NFT</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;fsize&#39;</span><span class="p">],</span>
            <span class="n">numCompAccomp</span><span class="o">=</span><span class="n">numCompAccomp</span><span class="p">,</span>
            <span class="n">K_numFilters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFilterWeigs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">P_numAtomFilters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nbFilterComps</span><span class="p">,</span>
            <span class="c">#imageCanvas=canvas,</span>
            <span class="n">minF0search</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sourceParams</span><span class="p">[</span><span class="s">&#39;minF0search&#39;</span><span class="p">],</span>
            <span class="n">maxF0search</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sourceParams</span><span class="p">[</span><span class="s">&#39;maxF0search&#39;</span><span class="p">],</span>
            <span class="n">minF0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sourceParams</span><span class="p">[</span><span class="s">&#39;minF0&#39;</span><span class="p">],</span>
            <span class="n">maxF0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sourceParams</span><span class="p">[</span><span class="s">&#39;maxF0&#39;</span><span class="p">],</span>
            <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">,</span>
            <span class="n">tfrepresentation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;transf&#39;</span><span class="p">],</span>
            <span class="n">cqtfmax</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;tffmax&#39;</span><span class="p">],</span><span class="c">#4000,</span>
            <span class="n">cqtfmin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;tffmin&#39;</span><span class="p">],</span><span class="c">#50,</span>
            <span class="n">cqtbins</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;tfbpo&#39;</span><span class="p">],</span><span class="c">#48,</span>
            <span class="n">cqtWinFunc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;tfWinFunc&#39;</span><span class="p">],</span>
            <span class="c">#slf.minqt.sqrt_blackmanharris,</span>
            <span class="n">cqtAtomHopFactor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_repr_params</span><span class="p">[</span><span class="s">&#39;hopfactor&#39;</span><span class="p">],</span><span class="c">#0.25,</span>
            <span class="n">outputDirSuffix</span><span class="o">=</span><span class="s">&#39;tmp/&#39;</span><span class="p">,</span> <span class="c"># dir_results,</span>
            <span class="c"># this is not working, have to find a way</span>
            <span class="n">initHF00</span><span class="o">=</span><span class="s">&#39;random&#39;</span><span class="p">,</span>
            <span class="n">freeMemory</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">simmModel</span><span class="o">.</span><span class="n">autoMelSepAndWrite</span><span class="p">(</span><span class="n">maxFrames</span><span class="o">=</span><span class="n">maxFrames</span><span class="p">)</span>
        </div>
<div class="viewcode-block" id="multichanLead.estimSUIMM"><a class="viewcode-back" href="../../reference/audiomodel.html#pyfasst.audioModel.multichanLead.estimSUIMM">[docs]</a>    <span class="k">def</span> <span class="nf">estimSUIMM</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maxFrames</span><span class="o">=</span><span class="mi">4000</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;separates the audio signal into lead+accompaniment,</span>
<span class="sd">        including more noisy components for the lead than `self.estimSIMM`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&quot;simmModel&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">estimSIMM</span><span class="p">(</span><span class="n">maxFrames</span><span class="o">=</span><span class="n">maxFrames</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">simmModel</span><span class="o">.</span><span class="n">estimStereoSUIMMParamsWriteSeps</span><span class="p">(</span><span class="n">maxFrames</span><span class="o">=</span><span class="n">maxFrames</span><span class="p">)</span>
        
    </div>
<div class="viewcode-block" id="multichanLead.demixOnSepSIMM"><a class="viewcode-back" href="../../reference/audiomodel.html#pyfasst.audioModel.multichanLead.demixOnSepSIMM">[docs]</a>    <span class="k">def</span> <span class="nf">demixOnSepSIMM</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unvoiced</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;run DEMIX on the separated signals resulting from SIMM model</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;simmModel&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">estimSIMM</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">unvoiced</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">estimSUIMM</span><span class="p">()</span>
                
        <span class="k">if</span> <span class="n">unvoiced</span><span class="p">:</span>
            <span class="n">suffix</span> <span class="o">=</span> <span class="s">&#39;_VUIMM&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">suffix</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
        <span class="c"># DEMIX on lead instrument</span>
        <span class="n">leadfilename</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">simmModel</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;voc_output_file&#39;</span><span class="p">][:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span>
            <span class="n">suffix</span> <span class="o">+</span> <span class="s">&#39;.wav&#39;</span><span class="p">)</span>
        <span class="n">ALead</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">demixOnGivenFile</span><span class="p">(</span>
            <span class="n">leadfilename</span><span class="p">,</span>
            <span class="n">nsources</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="c"># DEMIX on accompaniment</span>
        <span class="n">accpfilename</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">simmModel</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;mus_output_file&#39;</span><span class="p">][:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span>
            <span class="n">suffix</span> <span class="o">+</span> <span class="s">&#39;.wav&#39;</span><span class="p">)</span>
        <span class="n">AAccp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">demixOnGivenFile</span><span class="p">(</span>
            <span class="n">accpfilename</span><span class="p">,</span>
            <span class="n">nsources</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nbComps</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">ALead</span><span class="p">,</span> <span class="n">AAccp</span>
    </div>
<div class="viewcode-block" id="multichanLead.demixOnGivenFile"><a class="viewcode-back" href="../../reference/audiomodel.html#pyfasst.audioModel.multichanLead.demixOnGivenFile">[docs]</a>    <span class="k">def</span> <span class="nf">demixOnGivenFile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">nsources</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;running the DEMIX algorithm from :demix.DEMIX:</span>
<span class="sd">        </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">maxclusters</span> <span class="o">=</span> <span class="mi">40</span>
        <span class="n">neighbours</span> <span class="o">=</span> <span class="mi">15</span>
        
        <span class="c"># default for demix to work best: #FIXME!!!</span>
        <span class="c">#wlen = 2048</span>
        <span class="c">#hopsize = 1024</span>
        
        <span class="n">demixInst</span> <span class="o">=</span> <span class="n">demix</span><span class="o">.</span><span class="n">DEMIX</span><span class="p">(</span>
            <span class="n">audio</span><span class="o">=</span><span class="n">filename</span><span class="p">,</span>
            <span class="n">nsources</span><span class="o">=</span><span class="n">nsources</span><span class="p">,</span> <span class="c"># spatial comps for demix</span>
            <span class="c">#wlen=wlen,</span>
            <span class="c">#hopsize=hopsize,</span>
            <span class="c">#neighbors=neighbours,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">,</span>
            <span class="n">maxclusters</span><span class="o">=</span><span class="n">maxclusters</span><span class="p">,</span>
            <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">demixParams</span><span class="p">)</span>
            
        <span class="c">#demixInst.comp_pcafeatures()</span>
        <span class="c">#demixInst.comp_parameters()</span>
        <span class="c">#demixInst.init_subpts_set()</span>
        <span class="n">demixInst</span><span class="o">.</span><span class="n">comp_clusters</span><span class="p">()</span>
        <span class="n">demixInst</span><span class="o">.</span><span class="n">refine_clusters</span><span class="p">()</span>
        
        <span class="c"># mixing parameters from DEMIX estimation:</span>
        <span class="c">#     results in an nsrc x nfreqs x nc array</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">demixInst</span><span class="o">.</span><span class="n">steeringVectorsFromCentroids</span><span class="p">()</span>
        <span class="k">del</span> <span class="n">demixInst</span>
        <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warnMsg</span> <span class="o">=</span> <span class="s">&quot;There are no clusters in demix, returning dummy matrix.&quot;</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">warnMsg</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span> <span class="n">warnMsg</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">0.25</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="n">nsources</span><span class="p">,</span>
                                                   <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
        <span class="k">return</span> <span class="n">A</span>
    </div>
<div class="viewcode-block" id="multichanLead.initConvDemixOnSepSrc"><a class="viewcode-back" href="../../reference/audiomodel.html#pyfasst.audioModel.multichanLead.initConvDemixOnSepSrc">[docs]</a>    <span class="k">def</span> <span class="nf">initConvDemixOnSepSrc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">suffix</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;initialize the convolutive parameters with DEMIX, running on each of</span>
<span class="sd">        the separated sources</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&quot;files&quot;</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;The sources were not separated, compute them first&quot;</span><span class="o">+</span>
                          <span class="s">&quot; with separate_spat_comps.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="n">estFiles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s">&#39;spat_comp&#39;</span><span class="p">]</span>
        <span class="n">nbSources</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">print</span> <span class="n">nbSources</span><span class="p">,</span> <span class="s">&quot;sources:&quot;</span><span class="p">,</span> <span class="n">estFiles</span>
        <span class="k">for</span> <span class="n">nest</span><span class="p">,</span> <span class="n">estfilename</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">estFiles</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">print</span> <span class="n">estfilename</span>
            <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">demixOnGivenFile</span><span class="p">(</span><span class="n">estfilename</span><span class="p">,</span> <span class="n">nsources</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">nest</span><span class="p">]):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spat_comps</span><span class="p">[</span><span class="n">nest</span><span class="p">][</span><span class="s">&#39;params&#39;</span><span class="p">][</span><span class="n">r</span><span class="p">][:,:]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="mf">1e-3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="o">*</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">renormalize_parameters</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="n">estFiles</span>
    </div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">pyFASST 0.1 documentation</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Jean-Louis Durrieu.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>